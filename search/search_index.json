{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Interfaz de usuario, bloque de iOS b\u00e1sico","text":"<p>En este bloque de la asignatura vamos a ver una introducci\u00f3n al desarrollo de interfaces para aplicaciones iOS. Aunque ya hemos visto algunos conceptos b\u00e1sicos sobre interfaces en la asignatura de Tecnolog\u00edas de Desarrollo, aqu\u00ed profundizaremos un poco m\u00e1s sobre ellos y veremos detalles que no vimos antes, como nuevos componentes de interfaz (sliders, pickers,...) o c\u00f3mo se hacen aplicaciones con varias \"pantallas\" (varios controladores). Completaremos este bloque con una introducci\u00f3n a las tablas, que son la forma est\u00e1ndar en la que podemos mostrar informaci\u00f3n en forma de listas y tambi\u00e9n autolayout, un mecanismo que nos permite adaptar autom\u00e1ticamente la interfaz al tama\u00f1o de la pantalla del dispositivo actual.</p>"},{"location":"SUMMARY/","title":"Contenidos","text":"<ul> <li>View controllers<ul> <li>Funciones de los view controllers</li> <li>Storyboards</li> <li>Segues</li> <li>NIBs</li> <li>Ejercicios</li> </ul> </li> <li>Vistas. Componentes de la interfaz<ul> <li>Interacci\u00f3n con la interfaz por c\u00f3digo</li> <li>Propiedades de una vista</li> <li>Algunos componentes de interfaz de usuario</li> <li>Ejercicios</li> </ul> </li> <li>Autolayout<ul> <li>El por qu\u00e9 de autolayout</li> <li>Manejo de restricciones con Xcode</li> <li>M\u00e1s sobre las restricciones</li> <li>Formular restricciones usando c\u00f3digo</li> <li>Ejercicios</li> </ul> </li> <li>Tablas<ul> <li>Introducci\u00f3n</li> <li>Tablas est\u00e1ticas</li> <li>Tablas din\u00e1micas</li> <li>Gesti\u00f3n de tablas</li> <li>Ejercicios</li> </ul> </li> <li>Controladores contenedores<ul> <li>Tab bar controllers</li> <li>Navigation controllers</li> </ul> </li> <li>Proyecto</li> </ul>"},{"location":"1_controllers/apuntes/","title":"View Controllers","text":""},{"location":"1_controllers/apuntes/#view-controllers-funciones-basicas","title":"View controllers. Funciones b\u00e1sicas","text":"<p>Hay dos tipos b\u00e1sicos de controladores: los que muestran directamente contenido (content controllers) y los que contienen otros contenedores (container controllers). Estos \u00faltimos contienen a otros controladores. Lo que hace el contenedor es redimensionar y colocar la vista principal de sus hijos, pero cada uno de ellos es responsable de mostrar su propio contenido</p> <p></p>"},{"location":"1_controllers/apuntes/#otras-tareas-de-los-view-controllers","title":"Otras tareas de los view controllers","text":"<p>Adem\u00e1s de gestionar la jerarqu\u00eda de vistas, los controladores act\u00faan como el \u201cpegamento\u201d que relaciona la vista con el modelo. El controlador es el lugar t\u00edpico para poner el c\u00f3digo que reacciona a los eventos del usuario, como por ejemplo qu\u00e9 hacer cuando se pulsa un bot\u00f3n.</p> <p>Es nuestra responsabilidad como desarrolladores asegurarnos de que no colocamos demasiada l\u00f3gica en el c\u00f3digo del controller. La l\u00f3gica deber\u00eda ir en el modelo, no en el controller, que deber\u00eda contener el m\u00ednimo c\u00f3digo imprescindible para comunicar vista y modelo.</p> <p>Por otro lado, los controllers son los responsables de adaptar las dimensiones de los componentes de la interfaz a las dimensiones reales de la pantalla. Para ello se usan varios mecanismos: autolayout, size classes y traits, que veremos a nivel introductorio en las siguientes sesiones.</p>"},{"location":"1_controllers/apuntes/#ciclo-de-vida-de-un-controller","title":"Ciclo de vida de un controller","text":"<p>Cada controlador va pasando por una serie de estados conforme se carga la aplicaci\u00f3n, se muestra la pantalla que este gestiona, se cambia de pantalla, etc. </p> <p>Hay tres m\u00e9todos principales en los que podemos colocar c\u00f3digo propio, seg\u00fan el momento en que queramos que se ejecute:</p> <ul> <li><code>viewDidLoad()</code>: este m\u00e9todo ya lo hemos usado en nuestras aplicaciones. Se dispara cuando se carga la ra\u00edz de la jerarqu\u00eda de vistas del controlador. T\u00edpicamente se ejecutar\u00eda una sola vez en toda la aplicaci\u00f3n, y por ello se  suele usar para inicializar propiedades del controlador. No obstante si el sistema anda bajo de memoria puede liberar la correspondiente al controlador y como resultado este m\u00e9todo podr\u00eda ejecutarse m\u00e1s de una vez.</li> <li><code>viewWillAppear()</code>: se ejecuta inmediatamente antes de dibujar la vista.  </li> <li><code>viewDidAppear()</code>: se ejecuta cuando la vista ya se ha dibujado. \u00datil para colocar c\u00f3digo relativo por ejemplo a animaciones.</li> </ul> <p>Los m\u00e9todos anteriores y sus \u201ccomplementarios\u201d (con <code>disappear</code> en lugar de <code>appear</code>) se recogen en el siguiente esquema</p> <p></p>"},{"location":"1_controllers/apuntes/#instanciar-controladores-y-vistas","title":"Instanciar controladores y vistas","text":"<p>Podemos hacerlo de varias formas. De m\u00e1s sencilla a m\u00e1s compleja (pero tambi\u00e9n m\u00e1s flexible)</p> <ul> <li>Gr\u00e1ficamente, con storyboards: tanto las vistas como el controlador est\u00e1n en el storyboard</li> <li>Gr\u00e1ficamente, con <code>.nib</code>: en cada archivo <code>nib</code> guardamos una pantalla (con su jerarqu\u00eda de vistas), pero no el controlador, que se crea por c\u00f3digo</li> <li>Totalmente por c\u00f3digo: tenemos que instanciar el controlador y en su m\u00e9todo  <code>loadView</code> crear la jerarqu\u00eda de vistas que queremos que contenga (<code>UIView</code>, <code>UIButton</code>, lo que sea) y asignar la ra\u00edz de la jerarqu\u00eda de vistas a <code>self.view</code>.</li> </ul> <p>Dado el tiempo disponible, solo vamos a ver la primera opci\u00f3n con m\u00e1s detalle. En general los storyboards van a ser suficientes para aplicaciones no demasiado complejas.</p>"},{"location":"1_controllers/apuntes/#navegacion-con-storyboards","title":"Navegaci\u00f3n con Storyboards","text":"<p>Los storyboards son la forma recomendada por Apple de crear interfaces de usuario. Un storyboard contiene la representaci\u00f3n gr\u00e1fica de las \u201cpantallas\u201d (los controladores) que componen nuestra aplicaci\u00f3n y de las relaciones entre ellas. Adem\u00e1s el sistema se encarga autom\u00e1ticamente de moverse por las pantallas cuando sucedan determinados eventos, instanciando los controladores y las vistas autom\u00e1ticamente.</p> <p></p>"},{"location":"1_controllers/apuntes/#el-controller-inicial","title":"El controller inicial","text":"<p>En cada momento habr\u00e1 un view controller inicial que es el que se muestra cuando se carga la aplicaci\u00f3n. Se distingue visualmente porque tiene una flecha apuntando a \u00e9l desde la izquierda:</p> <p></p> <p>Para convertir un view controller en inicial, teni\u00e9ndolo seleccionado ir al icono de propiedades  del \u00e1rea de <code>Utilities</code> y marcar sobre el checkbox <code>Is initial view controller</code></p> <p></p> <p>Tambi\u00e9n podemos arrastrar la flecha que indica que un controlador es el inicial desde el actual hasta el que queremos convertir en inicial.</p>"},{"location":"1_controllers/apuntes/#el-controller-de-cada-pantalla","title":"El controller de cada pantalla","text":"<p>Simplificando, cada pantalla de nuestra app est\u00e1 controlada por una clase descendiente de la clase de UIKit <code>UIViewController</code>. Como ya hemos visto unas cuantas veces, la pantalla inicial de cada app est\u00e1 asociada a la clase <code>ViewController</code> de la plantilla. Puedes ver esto en Xcode, seleccionando con el rat\u00f3n el view controller y yendo al icono del <code>Identity inspector</code> en el panel de la derecha: . </p> <p>Para seleccionar el view controller con el rat\u00f3n pulsa el icono del c\u00edrculo amarillo con un cuadrado dentro que aparece en la barra de su parte superior. </p> <p></p> <p>Otra opci\u00f3n es seleccionarlo en el panel que aparece a la izquierda del storyboard con el \u00e1rbol de componentes</p> <p></p> <p>Podemos a\u00f1adir nuevas pantallas a nuestra app arrastrando al storyboard un componente de tipo <code>View Controller</code> del panel de componentes de UI. </p> <p>Por defecto, estos nuevos view controller estar\u00e1n asociados a clases propias de iOS, y si queremos personalizar su comportamiento tendremos que crear una clase propia que herede de <code>UIViewController</code> e implemente los m\u00e9todos b\u00e1sicos de gesti\u00f3n del ciclo de vida. En Xcode hay una plantilla para ello. Hay que:</p> <ol> <li>ir al men\u00fa <code>File &gt; New &gt; File...</code> </li> <li>En la primera pantalla del asistente que aparecer\u00e1 seleccionar <code>Cocoa Touch Class</code>, pulsar <code>Next</code></li> <li>Poner un nombre a nuestra clase, por ejemplo <code>ViewControllerSecundario</code> y en <code>Subclass of</code> poner <code>UIViewController</code>, ya que necesitamos que herede de esta clase. </li> <li>Dejar desmarcada la casilla <code>also create .XIB File</code>. </li> <li>Pulsar <code>Next</code></li> <li>Finalmente nos dejar\u00e1 elegir d\u00f3nde guardar f\u00edsicamente el archivo swift, podemos dejarlo por defecto y pulsar <code>Create</code></li> </ol> <p>Si todo va bien ver\u00e1s que entre los archivos del proyecto aparece la nueva clase creada y que tiene la estructura tipica de un view controller (tiene por ejemplo un <code>viewDidLoad</code>).</p> <p>Ya solo nos queda asociar la clase creada a la \"pantalla\" del storyboard. Recordemos que eso se hace en el <code>Identity inspector</code>  del panel de la derecha.</p>"},{"location":"1_controllers/apuntes/#segues","title":"Segues","text":"<p>Son las transiciones entre los controllers. Podemos crear un segue visualmente con <code>Ctrl+Arrastrar</code> entre un elemento cualquiera de un view controller (por ejemplo un bot\u00f3n), que ser\u00e1 el de controller de origen, y el controller destino. Se nos dar\u00e1 opci\u00f3n a elegir el tipo de segue en un men\u00fa contextual.</p> <p></p>"},{"location":"1_controllers/apuntes/#tipos-basicos-de-segue","title":"Tipos b\u00e1sicos de segue","text":"<p>Como vemos en el men\u00fa contextual hay cuatro tipos de segue. Dos de ellos son mostrar (show) y otros dos presentar (present). Adem\u00e1s podemos programar nuestro propio tipo de segue con custom.</p> <ul> <li>Show es la forma recomendada habitualmente, ya que permite que el controlador actual \u201cdecida\u201d c\u00f3mo mostrar f\u00edsicamente el nuevo. Por ejemplo si el controlador actual \u201cocupa\u201d toda la pantalla, el nuevo tambi\u00e9n lo har\u00e1, pero si por ejemplo es un tab bar controller solo cambiar\u00e1 la parte de la pantalla que muestra contenido, no la barra de herramientas </li> <li>Present quiere decir que el nuevo controller se mostrar\u00e1 de forma modal, de manera similar a cuando en un interfaz gr\u00e1fico se muestra por ejemplo un cuadro de di\u00e1logo modal. No obstante esto no quiere decir que siempre el controller antiguo se siga viendo \u201cpor debajo\u201d, ya que en dispositivos con tama\u00f1o de pantalla limitado el nuevo ocupar\u00e1 toda la pantalla. Este estilo suele llevar aparejada una animaci\u00f3n.</li> </ul> <p>Como vemos en el men\u00fa contextual, en el caso del show se distingue adem\u00e1s entre <code>Show</code> \u201ca secas\u201d y <code>Show detail</code>. El primero es el indicado cuando el nuevo controller va a sustituir completamente al anterior y el segundo se usa \u00fanicamente en el \"split view controller\", que sirve para mostrar vistas estilo \"maestro/detalle\" a \"pantalla partida\".</p> <p>En el caso del present, se distingue entre <code>Present Modally</code> y <code>Present As Popover</code>. El primero ser\u00eda lo que todo el mundo entiende por \u201cmodal\u201d: el nuevo controller se pone \u201cencima\u201d del anterior. El segundo es el t\u00edpico popover que aparece en el iPad.</p> <p></p> <p>En realidad la forma concreta de mostrar exactamente el nuevo controlador la decide iOS dependiendo de las dimensiones actuales del dispositivo. Por ejemplo en un iPhone SE en vertical no aparecer\u00e1 un popover aunque lo especifiquemos, la que la pantalla es muy peque\u00f1a para ello.</p>"},{"location":"1_controllers/apuntes/#estilos-de-presentacion-y-de-transicion","title":"Estilos de presentaci\u00f3n y de transici\u00f3n","text":"<p>Podemos usar diversos estilos a la hora de presentar de forma modal un controller. Por ejemplo podemos indicar que el nuevo controlador debe ocupar toda la pantalla, o bien solo el alto dejando una zona a los lados, o bien un recuadro central como un cuadro de di\u00e1logo\u2026</p> <p></p> <p>Estos estilos se definen en una propiedad del controller a presentar, y no del segue. En Xcode podemos cambiarlos con la propiedad <code>Presentation</code> en el attribute inspector  del controller. En Swift especificamos el estilo dando valores a la propiedad <code>modalPresentationStyle</code> del controller que vamos a presentar.</p> <p>Por otro lado, tambi\u00e9n podemos especificar una animaci\u00f3n para la transici\u00f3n entre el controller actual y el siguiente. La propiedad la tenemos en el segue y tambi\u00e9n en el controller destino. En Xcode se controla gr\u00e1ficamente con la propiedad <code>Transition style</code> del view controller o <code>Transition</code> del segue.</p>"},{"location":"1_controllers/apuntes/#pasar-datos-de-un-controller-a-otro-en-un-segue","title":"Pasar datos de un controller a otro en un segue","text":"<p>Cuando se va a saltar de un controller a otro a trav\u00e9s de un segue, se llama al m\u00e9todo <code>prepare(for:sender:)</code> del controller origen. Podemos sobreescribir este m\u00e9todo para pasarle datos al controller destino. El primer par\u00e1metro va a instanciarse al segue y a partir de este podemos obtener una referencia al destino.</p> <p>Por ejemplo supongamos que tenemos dos controller conectados por un segue, y este se dispara con un bot\u00f3n en el primero.</p> <p>Supongamos que el primer controller es un objeto de la clase <code>ViewController</code>, mientras que el segundo es de la clase <code>ViewControllerSecundario</code>. En el c\u00f3digo de <code>ViewControllerSecundario</code> podr\u00eda haber algo como:</p> <pre><code>class ViewControllerSecundario : UIViewController {\n    var mensaje = \"\"\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        print(self.mensaje)\n    }\n}\n</code></pre> <p>Es decir, imprimimos un mensaje cuando se carga la pantalla (lo normal ser\u00eda mostrarlo en un <code>label</code> o similar, pero para los prop\u00f3sitos de este ejemplo nos basta con que salga en la consola).</p> <p>Podemos acceder a esta propiedad <code>texto</code> desde el controller anterior sobreescribiendo el m\u00e9todo <code>prepare(for:sender:)</code></p> <pre><code>override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n        if (segue.identifier==\"siguiente\") {\n            if let vc2 = segue.destination as? ViewControllerSecundario {\n                vc2.mensaje = \"Bienvenidos a la pantalla 2\"\n            }\n        }\n }\n</code></pre>"},{"location":"1_controllers/apuntes/#cerrar-un-controller","title":"Cerrar un controller","text":"<p>Para cerrar un controller podemos llamar al m\u00e9todo <code>dismiss</code> del controller:</p> <pre><code>self.dismiss(animation:true)\n</code></pre> <p>con el <code>true</code> indicamos que queremos que el cierre se haga con una animaci\u00f3n.</p> <p>Como veremos posteriormente, cuando tengamos al controller dentro de una jerarqu\u00eda de pantallas creada con un navigation controller tendremos un bot\u00f3n dibujado autom\u00e1ticamente por iOS para volver atr\u00e1s. En ese caso podr\u00edamos hacer la vuelta atr\u00e1s por c\u00f3digo con <code>self.navigationController?.popViewController(animated: true)</code></p>"},{"location":"1_controllers/apuntes/#segues-que-vuelven-atras-unwind-segues","title":"Segues que vuelven atr\u00e1s (unwind segues)","text":"<p>Los segues que vuelven atr\u00e1s se llaman unwind segues y se crean de forma distinta a los segues convencionales, ya que la \"parte principal\" del segue se crea en el controller destino, y no en el origen. Esto nos permite \"deshacer\" por ejemplo varias transiciones a la vez, volviendo varias pantallas atr\u00e1s.</p> <p>Una ventaja del unwinding es que nos permite volver a cualquier controller directamente, aunque no fuera el anterior que se mostr\u00f3.</p> <p>En el controller destino de la vuelta debemos implementar lo que se llama un unwind action, un m\u00e9todo que puede tener el nombre que deseemos pero debe tener una signatura espec\u00edfica:</p> <ul> <li>Est\u00e1 marcada con un <code>@IBAction</code></li> <li>Tiene como \u00fanico par\u00e1metro un <code>UIStoryboardSegue</code>, que es el segue que se est\u00e1 usando para volver atr\u00e1s. Por ejemplo</li> </ul> <pre><code>@IBAction func miUnwind(segue: UIStoryboardSegue) {\n    print(\"Volviendo atr\u00e1s por \\(segue.identifier)...\")\n}\n</code></pre> <p>Ahora en la pantalla que dispara el unwind debemos conectar usando <code>Ctrl+Arrastrar</code> el elemento de interfaz que produce la vuelta atr\u00e1s con el icono de <code>Exit</code> que aparece en la parte de arriba.</p> <p></p> <p>Si intentamos hacer esta operaci\u00f3n de <code>Ctrl+Arrastrar</code> sin haber implementado el m\u00e9todo anterior, veremos que no tiene efecto.</p> <p>En versiones m\u00e1s modernas de Xcode (a partir de la 15) el procedimiento con el rat\u00f3n es el inverso, hay que: 1) Dar click con el bot\u00f3n derecho sobre el icono de exit. 2) En la lista de m\u00e9todos de unwind que aparecer\u00e1 clicar sobre el que queremos y arrastrar hacia el componente de interfaz de usuario que debe disparar el unwind. </p> <p>En el m\u00e9todo del unwinding, n\u00f3tese que podemos usar el par\u00e1metro, que es el segue, para obtener el <code>destination</code>, que ahora ser\u00e1 el controller al que volvemos.</p> <p>Finalmente, decir que cuando se produce un unwind, el controlador desde el que se vuelve tambi\u00e9n recibe una llamada a <code>prepare(for:sender:)</code>, m\u00e9todo que podemos sobreescribir si queremos aprovechar para realizar alguna operaci\u00f3n antes de volver.</p>"},{"location":"1_controllers/ejercicios/","title":"Ejercicio de view controllers (2,5 puntos)","text":"<p>Vamos a hacer una aplicaci\u00f3n que vamos a llamar \u201cPioneras\u201d, y que nos dar\u00e1 datos de algunas mujeres pioneras de la inform\u00e1tica. La aplicaci\u00f3n tendr\u00e1 una pantalla principal en la que aparecer\u00e1n sus im\u00e1genes, y haciendo tap sobre cada una podremos ir a las pantallas secundarias donde se nos dar\u00e1 m\u00e1s informaci\u00f3n.</p>"},{"location":"1_controllers/ejercicios/#realizar-la-estructura-basica-de-la-aplicacion-075-puntos","title":"Realizar la estructura b\u00e1sica de la aplicaci\u00f3n (0,75 puntos)","text":"<ol> <li>En este archivo tenemos las im\u00e1genes y los textos sobre las tres pioneras: Ada Lovelace, Grace Hopper y Barbara Liskov<ul> <li>Arrastra las im\u00e1genes al <code>Assets.xcassets</code> (puedes arrastrar la carpeta \"im\u00e1genes\" o los archivos de dentro). Se crear\u00e1n 3 \"Image sets\" con los nombres de los archivos originales (sin la extensi\u00f3n).</li> <li>Puedes hacer lo mismo con los textos, por cada uno se crear\u00e1 un \"Dataset\" con el nombre del archivo original, sin la extensi\u00f3n. F\u00edjate en que estos assets acaban su nombre por <code>_bio</code> para que no colisionen sus nombres con los de las im\u00e1genes.</li> </ul> </li> <li>Crea tres botones en la pantalla principal, y para cada uno de ellos en lugar de texto vamos a usar como imagen de fondo la de cada mujer <ul> <li>Si seleccionas el bot\u00f3n, en el panel derecho, en las propiedades, tienes una secci\u00f3n \"Background configuration\". Cambia la primera propiedad, \"Background\" por \"Custom\", y en el \"image\" de esta secci\u00f3n pon la que proceda. </li> <li>Al final, cada bot\u00f3n deber\u00eda ocupar todo el ancho de la pantalla y un tercio del alto. Pon las restricciones de autolayout que sean necesarias para conseguir esto. Lo m\u00e1s sencillo es meter a los tres botones en un \"stack view\", y ponerle 4 restricciones de distancia 0 a los bordes. Para que los botones ocupen el mismo espacio, la propiedad <code>distribution</code> del stack view debe ser <code>Fill equally</code> (haz tambi\u00e9n que el <code>spacing</code> sea peque\u00f1o, si no los botones saldr\u00e1n demasiado separados entre s\u00ed).</li> </ul> </li> </ol>"},{"location":"1_controllers/ejercicios/#crear-la-pantalla-secundaria-y-la-navegacion-hasta-ella-075-puntos","title":"Crear la pantalla secundaria y la navegaci\u00f3n hasta ella (0,75 puntos)","text":"<ul> <li>Crea una pantalla secundaria (un view controller) con un bot\u00f3n \"volver atr\u00e1s\" y un campo de texto de varias l\u00edneas (un text view). </li> <li>A\u00f1\u00e1dele las restricciones de autolayout necesarias para que:<ul> <li>El campo de texto quede centrado en horizontal y vertical, y a una distancia horizontal de 40 de uno de los bordes de la pantalla. </li> <li>El bot\u00f3n debe aparecer centrado en horizontal, y a una distancia de 60 puntos de la parte superior de la \"safe area\" y de 60 de la parte superior del campo de texto.</li> </ul> </li> </ul> <ul> <li>Con <code>Ctrl+arrastrar</code> podemos crear un segue desde cada uno de los botones hasta la pantalla. Habr\u00e1n tres segues que lleguen a la misma, no deber\u00eda ser problema.</li> <li> <p>Implementa la opci\u00f3n de volver atr\u00e1s de la secundaria a la principal: </p> <ul> <li> <p>En el controller de la primera pantalla crea un m\u00e9todo para que funcione el unwinding (no hace falta que haga nada, solo que exista)</p> <pre><code>@IBAction func retornoDeSecundaria(segue: UIStoryboardSegue) {\n\n}\n</code></pre> </li> <li> <p>Con <code>Ctrl+Arrastrar</code> conecta el bot\u00f3n \u201catr\u00e1s\u201d con el icono de \u201cExit\u201d de la parte superior del controller. Ejecuta el proyecto y comprueba que puedes ir a la secundaria desde la princpal y luego volver atr\u00e1s. Evidentemente el texto con la biograf\u00eda todav\u00eda no cambiar\u00e1.</p> </li> </ul> </li> </ul>"},{"location":"1_controllers/ejercicios/#crear-un-controlador-personalizado-para-la-pantalla-secundaria-1-punto","title":"Crear un controlador personalizado para la pantalla secundaria (1 punto)","text":"<p>Si seleccionas el view controller de la pantalla secundaria y miras el identity inspector en el panel de la derecha de Xcode, ver\u00e1s que el controlador de la pantalla secundaria es un tipo propio de iOS, el <code>UIViewController</code>. Vamos a cambiarlo por uno implementado por nosotros:</p> <ol> <li>Crea una nueva clase de Cocoa Touch, (File&gt; New &gt; File\u2026, plantilla \u201ccocoa touch class\u201d). En la segunda pantalla del asistente dale a la clase el nombre <code>SecundarioViewController</code> y haz que sea una subclase de <code>UIViewController</code>. Deja sin marcar la opci\u00f3n de crear el .XIB</li> <li>En el storyboard, selecciona el controller de la pantalla secundaria (es mejor que lo hagas pulsando en el primero de los iconos que aparecen en  la parte superior)  </li> <li>Una vez seleccionado, ve al identity inspector en panel derecho de Xcode y en el apartado de <code>Custom class</code> selecciona como clase la que has creado, <code>SecundarioViewController</code></li> </ol>"},{"location":"1_controllers/ejercicios/#anadirle-un-outlet-al-controlador-secundario","title":"A\u00f1adirle un outlet al controlador secundario","text":"<p>Tienes que a\u00f1adir un outlet al campo de texto para que su contenido se pueda cambiar desde el controlador secundario. Hazlo como habitualmente, con ctrl+arrastrar entre el campo y el <code>SecundarioViewController</code>, en el modo <code>assistant</code> del editor.</p>"},{"location":"1_controllers/ejercicios/#hacer-que-el-texto-cambie-segun-el-boton-pulsado","title":"Hacer que el texto cambie seg\u00fan el bot\u00f3n pulsado","text":"<ul> <li> <p>Para que le podamos decir al controlador secundario qu\u00e9 asset tiene que usar, debes crear una propiedad en el <code>SecundarioViewController</code> llamada <code>nombreAsset</code> de tipo <code>String</code></p> </li> <li> <p>Para establecer una asociaci\u00f3n sencilla entre cada segue y los datos a mostrar puedes usar el identificador del segue. Haz clic sobre \u00e9l y en el <code>Attributes inspector</code> cambia su <code>identifier</code>, respectivamente por <code>lovelace</code>, <code>hopper</code> y <code>liskov</code></p> </li> <li> <p>ahora en la clase <code>ViewController</code>, que es el controlador de la pantalla principal, puedes implementar el <code>prepare(for:,sender:)</code>. Mira los apuntes para los detalles. En \u00e9l debes:</p> <ul> <li>Obtener el controlador secundario, a partir del segue (tendr\u00e1s que hacer un cast con <code>as!</code> para convertirlo al tipo adecuado)</li> <li>establecer el valor de la propiedad <code>nombreAsset</code> del controlador secundario al identificador del segue concatenado con <code>_bio</code>. ya que as\u00ed se llaman los assets de texto.</li> </ul> </li> <li> <p>Finalmente, en el <code>viewDidLoad()</code> del <code>SecundarioViewController</code> puedes acceder a la propiedad <code>self.nomAsset</code>, cargar el asset y mostrarlo en el campo de texto. Puedes cargar los datos del asset como sigue:</p> </li> </ul> <pre><code>//CAMBIA nombre_del_asset por el que proceda\nvar texto = \"\"\nlet asset = NSDataAsset(name: nombreAsset)\nif let data = asset?.data {\n    texto = String(data: data, encoding: .utf8) ?? \"\"\n    self.campoTexto.text = texto\n    //AQUI TE FALTA COLOCAR EL TEXTO EN EL TEXT VIEW\n    //...\n}\n</code></pre>"},{"location":"2_vistas/apuntes/","title":"Vistas","text":"<p>Como ya hemos visto, todas las aplicaciones iOS que usan la librer\u00eda UIKit siguen el paradigma modelo/vista/controlador. En esta sesi\u00f3n vamos a ver las vistas, es decir, los componentes de interfaz de usuario de nuestra aplicaci\u00f3n.  </p> <p>Primero veremos algunos de los componentes m\u00e1s usados de UIKit y luego c\u00f3mo gestionar las propiedades comunes a todos los componentes (tama\u00f1o, posici\u00f3n, etc) con c\u00f3digo Swift.</p>"},{"location":"2_vistas/apuntes/#componentes-de-interfaz-de-usuario","title":"Componentes de interfaz de usuario","text":"<p>A lo largo de los ejemplos que hemos ido haciendo en las sesiones anteriores ya hemos probado unos cuantos de los controles b\u00e1sicos de interfaz de usuario que nos proporciona iOS: botones, etiquetas, im\u00e1genes, \u2026 Vamos a ver aqu\u00ed algunas de las caracter\u00edsticas de los controles, aunque solo vamos a dar unas pinceladas, ya que una descripci\u00f3n exhaustiva de cada propiedad ser\u00eda imposible y tediosa. </p> <p>Se os recomienda consultar la documentaci\u00f3n de Apple, en concreto hay dos tipos de documentaci\u00f3n que os pueden resultar \u00fatiles:</p> <ul> <li>Desde el punto de vista del dise\u00f1o y la usabilidad, la parte de las Human Interface Guidelines dedicada a los componentes de UI.</li> <li>Desde el punto de vista de desarrollo pod\u00e9is consultar el apartado \"views and controls\" de la documentaci\u00f3n de UIKit, con la referencia del API y la forma de usar cada componente en nuestro c\u00f3digo.</li> </ul> <p>Aunque aqu\u00ed hablemos de controles indistintamente para referirnos a las etiquetas, botones, \u2026 en realidad este t\u00e9rmino tiene un significado m\u00e1s preciso en iOS. La clase <code>UIControl</code> es de la que heredan los controles m\u00e1s \u201cinteractivos\u201d como los botones, mientras que las etiquetas lo hacen de <code>UIView</code> (no obstante todos los<code>UIControl</code> son tambi\u00e9n vistas ya que a su vez esta clase hereda de <code>UIView</code>).</p>"},{"location":"2_vistas/apuntes/#campos-de-texto","title":"Campos de texto","text":"<p>Un campo de texto nos proporciona un espacio donde el usuario puede introducir y editar texto. Se define en la clase <code>UITextField</code>, y pertenece a un grupo de vistas denominados controles, junto a otros componentes como por ejemplo los botones. Esto es as\u00ed porque permiten al usuario interactuar con la aplicaci\u00f3n. No heredan directamente de <code>UIView</code>, sino de su subclase <code>UIControl</code>, que incorpora los m\u00e9todos para tratar eventos de la interfaz mediante el patr\u00f3n target-action como hemos visto anteriormente.</p> <p>target-action es el nombre gen\u00e9rico que se da en iOS a la idea de vincular un componente de UI con un manejador de evento. Ya hemos visto c\u00f3mo se hace en Xcode (arrastrar+Ctrl desde el componente en el storyboard hasta el c\u00f3digo del controller). Tambi\u00e9n se puede hacer en c\u00f3digo Swift, aunque no lo veremos aqu\u00ed.</p> <p>Sus propiedades se pueden encontrar en la secci\u00f3n <code>Text Field</code> del inspector de atributos. Podremos especificar un texto por defecto (<code>Text</code>), o bien un texto a mostrar sombreado en caso de que el usuario no haya introducido nada (<code>Placeholder Text</code>). Esto ser\u00e1 \u00fatil por ejemplo para dar una pista al usuario sobre lo que debe introducir en dicho campo.</p> <p>Si nos fijamos en el inspector de conexiones del campos de texto, veremos la lista de eventos que podemos conectar a nuestras acciones. Esta lista de eventos es com\u00fan para cualquier control. En el caso de un campo de texto por ejemplo nos puede interesar el evento <code>Value Changed</code>.</p>"},{"location":"2_vistas/apuntes/#teclado-en-pantalla","title":"Teclado en pantalla","text":"<p>Cuando un campo de texto adquiere el foco porque el usuario hace tap sobre \u00e9l, autom\u00e1ticamente aparece el teclado software on screen. El problema es que no desaparece por defecto. Tenemos que quitarlo de pantalla con c\u00f3digo Swift. En concreto, tenemos que escribir un action que responda al evento <code>Did end on exit</code> del campo de texto. </p> <p>Cuando crees el action indica en el men\u00fa popup que el <code>type</code> debe ser <code>UITextField</code>. Esta opci\u00f3n es el par\u00e1metro que se le pasar\u00e1 al action y representa el objeto que ha disparado el evento, en nuestro caso el campo de texto. Si lo pasamos como <code>AnyObject</code> no tendremos acceso a los m\u00e9todos del API de <code>UITextField</code> (salvo que hici\u00e9ramos una conversi\u00f3n con <code>as</code>)</p> <p>En teor\u00eda dentro de este action debemos hacer que el campo deje de ser el objeto que hace de first responder para que el teclado deje de mostrarse</p> <p>El first responder es el objeto que recibe en primer lugar ciertas clases de eventos, por ejemplo los de teclado o movimiento. Cuando hacemos tap sobre un campo de texto, iOS hace que este pase a ser el first responder, y esto es lo que hace que autom\u00e1ticamente aparezca el teclado onscreen.</p> <pre><code> @IBAction func introPulsado(_ sender: UITextField) {\n    sender.resignFirstResponder()\n }\n</code></pre> <p>Aunque en muchas fuentes (libros, tutoriales en web, \u2026) aparece el m\u00e9todo del <code>resignFirstResponder</code>, curiosamente parece bastar con tener un action que responda al <code>Did end on exit</code>, aunque no haga nada para ocultar el teclado.*</p> <p>Por desgracia, no todos los tipos de teclado en pantalla tienen un bot\u00f3n de \u201cintro\u201d y por tanto no disparan el evento <code>Did end on exit</code>, por ejemplo el teclado num\u00e9rico no lo hace. En ese caso hay que usar una soluci\u00f3n algo m\u00e1s rebuscada. Por ejemplo, es muy t\u00edpico que al pulsar sobre cualquier parte de la pantalla que no sea el campo el teclado se oculte. Esto podemos conseguirlo detectando el evento de toque sobre la vista. Si un evento no se procesa en los componentes de la vista va \u201csubiendo\u201d en la jerarqu\u00eda hasta llegar al view controller, por lo que en \u00e9l podr\u00edamos hacer esto (no es necesario crear un action, ya que el evento no va a ir directamente al controller, solo escribir el c\u00f3digo):</p> <pre><code>override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with: UIEvent?) {\n   print(\"\u00a1touch en la pantalla!\")\n   //Necesitamos un outlet para acceder al campo de texto.\n   //Aqu\u00ed suponemos que lo hemos llamado \"campoDeTexto\"\n   self.campoDeTexto.resignFirstResponder()\n}\n</code></pre>"},{"location":"2_vistas/apuntes/#botones","title":"Botones","text":"<p>Al igual que los campos de texto, los botones son otro tipo de control (heredan de <code>UIControl</code>). Se definen en la clase <code>UIButton</code>, que puede ser inicializada de la misma forma que el resto de vistas.</p> <p>Si nos fijamos en el inspector de atributos de un bot\u00f3n (en la secci\u00f3n <code>Button</code>), vemos que podemos elegir el tipo de bot\u00f3n (atributo <code>Type</code>). Podemos seleccionar una serie de estilos prefedinidos para los botones, o bien darle un estilo propio (<code>Custom</code>).</p> <p>El texto que aparece en el bot\u00f3n se especifica en la propiedad <code>Title</code>, y podemos configurar tambi\u00e9n su color, sombreado, o a\u00f1adir una imagen como icono.</p> <p>En el inspector de conexiones, el evento que utilizaremos m\u00e1s com\u00fanmente en los botones es <code>Touch Up Inside</code>, que se producir\u00e1 cuando levantemos el dedo tras pulsar dentro del bot\u00f3n. Este ser\u00e1 el momento en el que se realizar\u00e1 la acci\u00f3n asociada al bot\u00f3n.</p>"},{"location":"2_vistas/apuntes/#alertas-y-action-sheets","title":"Alertas y action sheets","text":"<p>Son cuadros de di\u00e1logo modales que se usan para informar al usuario de eventos importantes. No se crean gr\u00e1ficamente en Xcode sino por c\u00f3digo Pueden simplemente informar de algo o adem\u00e1s pedir al usuario que elija uno entre varios cursos de acci\u00f3n.</p> <p>Vamos a ver primero c\u00f3mo crear una alerta. En realidad el API para alertas y action sheets es el mismo, solo se diferencian en una constante que se le pasa al inicializador. Luego veremos las diferencias en cuanto a su significado de cara al usuario.</p> <p>Por ejemplo veamos c\u00f3mo se mostrar\u00eda una alerta con dos opciones</p> <p></p> <pre><code>//El alert en s\u00ed. Vemos que el preferredStyle es .alert\nlet alert = UIAlertController(title: \"\u00a1Elige!\", \n            message: \"Tienes que elegir uno de estos dos\", \n            preferredStyle: .alert)\n//cada opci\u00f3n es un UIAlertAction\nlet susto = UIAlertAction(title: \"Susto\", style: .cancel) {\n    action in\n      print(\"BU!!! haber elegido muerte!\")\n}\nlet muerte = UIAlertAction(title: \"Muerte\", style: .default) {\n    action in\n      print(\"Aqu\u00ed se acaba todo\")\n}\n//A\u00f1adimos las opciones al cuadro de di\u00e1logo\nalert.addAction(susto)\nalert.addAction(muerte)\n//Mostramos el alert con present, como se hace con cualquier controller\nself.present(alert, animated: true) {\n    print(\"Ha acabado la animaci\u00f3n del alert\")\n}\n</code></pre> <p>Podemos tener el n\u00famero de botones que queramos. No obstante, las \u201ciOS Human Interface Guidelines\u201d recomiendan como m\u00e1ximo dos, y en caso que necesitemos m\u00e1s usar un \u201cAction Sheet\u201d.</p> <p>Por otro lado un action sheet es un cuadro de di\u00e1logo que se usa para dar alternativas al usuario cuando ha realizado una acci\u00f3n. Por ejemplo supongamos un gestor de email en el que el usuario ha hecho tap sobre un mensaje. Podr\u00eda aparecer la siguiente action sheet</p> <p></p> <p>El API es exactamente el mismo, solo que en el inicializador de <code>UIAlertController</code> se pasa como par\u00e1metro <code>preferredStyle</code> el valor <code>actionSheet</code>.</p> <pre><code>let actionSheet = UIAlertController(title: \"Opciones\", \n    message: \"Seleccione la opci\u00f3n\", \n    preferredStyle: .actionSheet)\nlet archivar = UIAlertAction(title: \"Archivar\", style: .default){\n            action in\n            print(\"Aqu\u00ed se archivar\u00eda el mensaje\")\n}\nlet eliminar = UIAlertAction(title: \"Eliminar\", style: .destructive) {\n            action in\n            print(\"Aqu\u00ed se eliminar\u00eda el mensaje\")\n        }\nlet cancelar = UIAlertAction(title: \"Cancelar\", style: .cancel) {\n            action in\n            print(\"Aqu\u00ed no se har\u00eda nada\")\n}\nactionSheet.addAction(archivar)\nactionSheet.addAction(eliminar)\nactionSheet.addAction(cancelar)\nself.present(actionSheet, animated: true) {\n   print(\"Ha acabado la animaci\u00f3n del action sheet\")\n}\n</code></pre>"},{"location":"2_vistas/apuntes/#pickers","title":"Pickers","text":"<p>Nos permiten elegir uno de entre una lista de valores, usando la met\u00e1fora visual de la t\u00edpica rueda que se gira para seleccionar el valor deseado. En el API se corresponden con la clase <code>UIPickerView</code>. En Xcode, el componente a arrastrar al storyboard es el \"Picker View\"</p> <p></p> <p>Comparados con la mayor\u00eda de los otros controles son bastante m\u00e1s complejos, ya que un picker necesita de la ayuda de dos delegates (dos objetos que sean conformes a ciertos protocolos): </p> <ul> <li>Un delegate (protocolo <code>UIPickerViewDelegate</code>): gestiona el comportamiento general del picker</li> <li>Un datasource (protocolo <code>UIPickerViewDataSource</code>): gestiona el \"modelo de datos\": cu\u00e1ntas filas y columnas tiene</li> </ul> <p>Estos dos protocolos heredan de <code>NSObjectProtocol</code>, con lo que los objetos conformes a ellos deben ser conformes tambi\u00e9n a este \u00faltimo (esto se puede conseguir de modo sencillo haciendo que la clase herede de <code>NSObject</code>, ya que esta clase es conforme a este protocolo).</p> <p>Por ejemplo supongamos una clase <code>GestorPicker</code> que para hacer el c\u00f3digo m\u00e1s compacto va a hacer tanto de delegate como de datasource:</p> <pre><code>import UIKit\nclass GestorPicker : NSObject, UIPickerViewDelegate, UIPickerViewDataSource {\n    var lista = [\"Pepe\", \"Eva\", \"Juan\", \"Mar\u00eda\"]\n\n    //METODOS DE UIPickerViewDatasource\n    //n\u00famero de \"columnas\" del Picker\n    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {\n        return 1\n    }\n    //n\u00famero de \"filas\"\n    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {\n        return lista.count\n    }\n\n    //METODOS DE UIPickerViewDelegate\n    func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {\n        return lista[row]\n    }   \n}\n</code></pre> <p>En el view controller de la pantalla con el picker definir\u00edamos una instancia de <code>GestorPicker</code></p> <p><pre><code>let gestorPicker = GestorPicker()\n</code></pre> Crear\u00edamos un outlet que represente al picker con Ctrl+Arrastrar, que generar\u00eda algo as\u00ed en el c\u00f3digo</p> <p><pre><code>@IBOutlet weak var miPicker: UIPickerView! \n</code></pre> Y finalmente dentro del <code>viewDidLoad</code> \"enlazar\u00edamos\" el picker con su datasource y su delegate asign\u00e1ndolos a sus propiedades del mismo nombre. Recordemos que datasource y delegate en este caso son el mismo objeto.</p> <pre><code>self.miPicker.delegate = self.gestorPicker\nself.miPicker.dataSource = self.gestorPicker\n</code></pre> <p>Los m\u00e9todos anteriores nos permiten pintar el picker, pero adem\u00e1s nos interesar\u00e1 saber qu\u00e9 opci\u00f3n est\u00e1 seleccionada. En cualquier momento podemos obtener el n\u00famero de fila seleccionado en el picker con</p> <pre><code>//Cambiar el 0 por la \"columna\" que queramos\nself.miPicker.selectedRow(inComponent: 0)\n</code></pre> <p>Adem\u00e1s si nos interesa podemos ser avisados en el momento en que el usuario seleccione una opci\u00f3n. Cuando se produzca ese evento, el objeto que act\u00fae de delegate del picker recibir\u00e1 una llamada a su m\u00e9todo <code>pickerView(_:,didSelectRow:,inComponent:)</code>:</p> <pre><code>class GestorPicker : NSObject, UIPickerViewDelegate, UIPickerViewDataSource {\n    var lista = [\"Pepe\", \"Eva\", \"Juan\", \"Mar\u00eda\"]\n    ...\n    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {\n        print(\"Seleccionada fila: \\(row), dato: \\(lista[row])\")\n    }\n    ...\n}\n</code></pre>"},{"location":"2_vistas/apuntes/#otros-controles-sliders-switches-date-pickers","title":"Otros controles (sliders, switches, date pickers)","text":"<p>Estos controles son muy heterog\u00e9neos, pero todos tienen en com\u00fan que tienen un valor asociado y que este valor puede cambiar debido a las acciones del usuario. El tipo del valor y la(s) propiedade(s) para acceder a \u00e9l ser\u00e1n muy distintas seg\u00fan el tipo de control, por ejemplo:</p> <ul> <li>Un <code>UISwitch</code> es booleano y se sabe si est\u00e1 a \"on\" con <code>isOn</code></li> <li>Un <code>UISlider</code> tiene un valor <code>Float</code> y se accede a \u00e9l con la propiedad <code>value</code></li> <li>Un <code>UIDatePicker</code> tiene una fecha y se accede a ella con la propiedad <code>date</code></li> </ul> <p>Pero en todos se usa la misma idea, implementar un action vinculado al evento de cambio del valor de modo que en su c\u00f3digo podamos acceder al valor actual. Por ejemplo para un slider tendr\u00edamos algo como</p> <pre><code>//Este m\u00e9todo se ha creado con el \"assistant editor\" y Ctrl+Arrastrar\n//de la ventana del storyboard al editor con el c\u00f3digo del view controller\n//Elegimos Connection \"action\" y type \"UISlider\"\n@IBAction func cambiaSlider(_ sender: UISlider) {\n    print(\"El valor es: \\(sender.value)\")\n}\n</code></pre> <p>Es importante que al crear el action, si lo hacemos gr\u00e1ficamente con Ctrl+Arrastrar, en el popup de opciones elijamos como tipo <code>UISlider</code> (o en general, el tipo del control en cuesti\u00f3n). As\u00ed el par\u00e1metro sender que representa el objeto que ha generado el evento tendr\u00e1 el tipo adecuado y no necesitaremos hacer un cast para acceder a la propiedad deseada, como pasar\u00eda si lo dejamos con tipo <code>Any</code>.</p>"},{"location":"2_vistas/apuntes/#vistas-en-swift","title":"Vistas en Swift","text":"<p>En la asignatura de Tecnolog\u00edas de Desarrollo hemos creado componentes de interfaz de usuario (vistas) arrastr\u00e1ndolos al storyboard. Vamos a ver aqu\u00ed c\u00f3mo crearlos desde Swift y cambiar sus propiedades, que son las mismas que tenemos en Xcode.</p>"},{"location":"2_vistas/apuntes/#las-vistas-y-el-controller","title":"Las vistas y el controller","text":"<p>Cada vista est\u00e1 \u00edntimamente ligadas a un determinado controller. Podemos decir que un controller \"posee\" directamente una determinada vista, que es su vista principal, y esta a su vez puede contener subvistas. Toda esta jerarqu\u00eda de vistas forman lo que el usuario percibe como una \"pantalla\" de nuestra app. </p> <p>La vista \"principal\" de un controller es su propiedad <code>view</code>. El sitio indicado para manipular esta <code>view</code> es el m\u00e9todo <code>viewDidLoad</code> del controller en cuesti\u00f3n. Este m\u00e9todo se ejecuta una vez se ha cargado la vista y por tanto ya se han inicializado todos los componentes que hemos creado visualmente desde Xcode. En la plantilla creada por Xcode veremos que este m\u00e9todo llama al de la clase base, al final del m\u00e9todo podemos a\u00f1adir nuestro c\u00f3digo, por ejemplo para cambiar el color de fondo:</p> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view.\n    //aqu\u00ed \"view\" ya estar\u00e1 inicializada, podemos cambiar sus propiedades\n    self.view.backgroundColor = UIColor.green\n}\n</code></pre> <p>Otra opci\u00f3n es sobreescribir el m\u00e9todo <code>loadView()</code> del controller, a diferencia del anterior, si existe este m\u00e9todo se convierte en el responsable de cargar la vista principal, y se ignorar\u00e1 por tanto todo lo que se haya definido visualmente en el storyboard.</p> <pre><code>override func loadView() {\n    //Somos responsables de crear \"view\". \n    //Aqu\u00ed le damos el tama\u00f1o de la pantalla del dispositivo\n    //En un momento detallaremos el uso de la propiedad \"frame\"\n    self.view = UIView(frame: UIScreen.main.bounds)\n    self.view.backgroundColor = UIColor.green\n}\n</code></pre>"},{"location":"2_vistas/apuntes/#jerarquia-de-vistas","title":"Jerarqu\u00eda de vistas","text":"<p>Las vistas  nos proporcionan una serie de m\u00e9todos para consultar y modificar la jerarqu\u00eda. El m\u00e9todo b\u00e1sico que necesitaremos es <code>addSubview</code>, que nos permitir\u00e1 a\u00f1adir una subvista a una vista determinada, que se convertir\u00e1 en su vista \"madre\" o supervista:</p> <pre><code>var label = UILabel()\nlabel.text = \"Soy una etiqueta\"\n//suponiendo que \"vista\" ya est\u00e9 definida, ahora ser\u00e1 la supervista de \"label\"\nvista.addSubView(label)\n</code></pre> <p>Podemos eliminar una vista llamando a su m\u00e9todo <code>removeFromSuperview()</code>. Podemos tambi\u00e9n consultar la jerarqu\u00eda con los siguientes m\u00e9todos:</p> <ul> <li><code>superview</code>: Nos da la vista padre de la vista destinataria del mensaje.</li> <li><code>subviews</code>: Nos da la lista de subvistas de una vista dada.</li> <li><code>isDescendantOfView:</code> Comprueba si una vista es descendiente de otra.</li> </ul> <p>Como vemos, una vista tiene una lista de vistas hijas. Cada vista hija tiene un \u00edndice, que determinar\u00e1 el orden en el que se dibujan. El \u00edndice 0 es el m\u00e1s cercano al observador, y por lo tanto tapar\u00e1 a los \u00edndices superiores. Podemos insertar una vista en un \u00edndice determinado de la lista de subvistas con <code>insertSubview(_:,at:)</code>.</p> <p>Puede que tengamos una jerarqu\u00eda compleja y necesitemos acceder desde el c\u00f3digo a una determinada vista por ejemplo para inicializar su valor. Una opci\u00f3n es hacer un outlet para cada vista que queramos modificar, pero esto podr\u00eda sobrecargar nuestro objeto de outlets. Tambi\u00e9n puede ser complejo y poco fiable el buscar la vista en la jerarqu\u00eda. En estos casos, lo m\u00e1s sencillo es darle a las vistas que buscamos una etiqueta (tag) mediante la propiedad <code>Tag</code> del inspector de atributos (debe ser un valor entero), o asignando la propiedad <code>tag</code> de forma program\u00e1tica. Podremos localizar en nuestro c\u00f3digo una vista a partir de su etiqueta mediante <code>viewWithTag</code>. Llamando a este m\u00e9todo sobre una vista, buscar\u00e1 entre todas las subvistas aquella con la etiqueta indicada:</p> <pre><code> texto = self.window.viewWithTag(tag:1)\n</code></pre> <p>La jerarqu\u00eda de vistas de una pantalla determinada de nuestra aplicaci\u00f3n puede llegar a ser muy compleja. Es por eso que en Xcode hay una opci\u00f3n que nos permite mostrar un \u201cdespiece\u201d visual en 3D de las vistas que componen la pantalla actual. Dicha opci\u00f3n est\u00e1 disponible en <code>Debug &gt; View Debugging</code>.En modo texto podemos usar la propiedad <code>recursiveDescription</code> para imprimir la descripci\u00f3n textual de las vistas que contiene una vista dada.</p>"},{"location":"2_vistas/apuntes/#propiedades-de-una-vista","title":"Propiedades de una vista","text":"<p>A continuaci\u00f3n vamos a repasar las propiedades b\u00e1sicas de las vistas, que podremos modificar tanto desde Xcode como de forma program\u00e1tica.</p>"},{"location":"2_vistas/apuntes/#disposicion","title":"Disposici\u00f3n","text":"<p>Entre las propiedades m\u00e1s importantes en las vistas encontramos aquellas referentes a su disposici\u00f3n en pantalla. Hemos visto que tanto cuando creamos la vista con Xcode como cuando la inicializamos de forma program\u00e1tica hay que especificar el marco (<code>frame</code>) que ocupar\u00e1 la vista en la pantalla. </p> <p>Cuando se crea de forma visual, el marco se puede definir pulsando con el rat\u00f3n sobre los m\u00e1rgenes de la vista y arrastrando para as\u00ed mover sus l\u00edmites. En el c\u00f3digo estos l\u00edmites se especifican mediante el tipo <code>CGRect</code>, en el que se especifica posici\u00f3n <code>(x,y)</code> de inicio, y el ancho y el alto que ocupa la vista. Estos datos se especifican en el sistema de coordenadas de la supervista.</p> <pre><code>var vista = UIView(frame: CGRect(x:0,y:0,width:100,height:100))\n</code></pre> <p>El sistema de coordenadas tiene su origen en la esquina superior izquierda. Las coordenadas no se dan en pixels, sino en puntos, una medida que nos permite independizarnos de la resoluci\u00f3n en pixels de la pantalla. Las coordenadas en puntos son reales, no enteras. Pod\u00e9is consultar una tabla muy completa con muchos m\u00e1s datos. </p> <p>Otros frameworks de iOS definen sistemas de coordenadas distintos. Los de gr\u00e1ficos (Core Graphics y OpenGL ES) ponen el origen en la esquina inferior izquierda con el eje Y apuntando hacia arriba.</p> <p>Algunos ejemplos de c\u00f3mo obtener la posici\u00f3n y dimensiones de una vista:</p> <pre><code>// Limites en coordenadas locales\n// Su origen siempre es (0,0)\nCGRect areaLocal = vista.bounds\n// Posici\u00f3n del centro de la vista en coordenadas de su supervista\nCGPoint centro = vista.center\n// Marco en coordenadas de la supervista\nCGRect marco = vista.frame\n</code></pre> <p>N\u00f3tese que a partir de <code>bounds</code> y <code>center</code> podemos calcular <code>frame</code>, aunque nos lo da directamente el sistema</p> <p>Aqu\u00ed estamos usando tama\u00f1os fijos para las coordenadas de <code>CGRect</code>. Sin embargo, en la mayor\u00eda de ocasiones nos interesa que el tama\u00f1o de las vistas no sea fijo sino que se adapte al \u00e1rea disponible. De esta forma nuestra interfaz podr\u00eda adaptarse de forma sencilla a distintas orientaciones del dispositivo (horizontal o vertical) o a distintas resoluciones de la pantalla. Esto lo podemos conseguir mediante el uso del autolayout, que calcula de manera autom\u00e1tica el frame de cada vista bas\u00e1ndose en un conjunto de restricciones. Veremos esta tecnolog\u00eda en sesiones posteriores.</p>"},{"location":"2_vistas/apuntes/#transformaciones","title":"Transformaciones","text":"<p>Podemos tambi\u00e9n aplicar una transformaci\u00f3n a las vistas, mediante su propiedad <code>transform</code>. Por defecto las vistas tienen aplicada la transformaci\u00f3n identidad <code>CGAffineTransform.identity</code>.</p> <p>La transformaci\u00f3n se define mediante una matriz de transformaci\u00f3n 2D de dimensi\u00f3n 3x3. Podemos crear transformaciones sencillas (rotaciones, traslaciones o escalados \u201cpuros\u201d con las funciones <code>CGAffineTransform(rotationAngle:)</code>, <code>CGAffineTransform(translationX:,y:)</code> y  <code>CGAffineTransform(scaleX:,y:)</code>.</p> <p>Si nuestra vista tiene aplicada una transformaci\u00f3n diferente a la identidad, su propiedad <code>frame</code> no ser\u00e1 significativa. En este caso s\u00f3lo deberemos utilizar <code>center</code> y <code>bounds</code>.</p>"},{"location":"2_vistas/apuntes/#otras-propiedades","title":"Otras propiedades","text":"<p>En las vistas encontramos otras propiedades que nos permiten determinar su color o su opacidad. En primer lugar tenemos <code>backgroundColor</code>, con la que podemos fijar el color de fondo de una vista. En el inspector de atributos (secci\u00f3n <code>View</code>) podemos verlo como propiedad <code>Background</code>. El color de fondo puede ser transparente, o puede utilizarse como fondo un determinado patr\u00f3n basado en una imagen.</p> <p>De forma program\u00e1tica, el color se especifica mediante un objeto de clase <code>UIColor</code>. En esta clase podemos crear un color personalizado a partir de sus componentes (rojo, verde, azul, alpha), como en <code>UIColor(red:,green:,blue:,alpha:)</code> o con una constante predefinida (por ejemplo, <code>UIColor.green</code>)</p> <p>Por otro lado, tambi\u00e9n podemos hacer que una vista tenga un cierto grado de transparencia, o est\u00e9 oculta. A diferencia de <code>backgroundColor</code>, que s\u00f3lo afecta al fondo de la vista, con la propiedad <code>alpha</code>, de tipo <code>CGFloat</code>, podemos controlar el nivel de transparencia de la vista completa con todo su contenido y sus subvistas. Si una vista no tiene transparencia, podemos poner su propiedad <code>opaque</code> a <code>true</code> para as\u00ed optimizar la forma de dibujarla. Esta propiedad s\u00f3lo debe establecerse a <code>true</code> si la vista llena todo su contendo y no deja ver nada del fondo. De no ser as\u00ed, el resultado es impredecible. Debemos llevar cuidado con esto, ya que por defecto dicha propiedad es <code>true</code>.</p> <p>Por \u00faltimo, tambi\u00e9n podemos ocultar una vista con la propiedad <code>isHidden</code>. Cuando hagamos que una vista se oculte, aunque seguir\u00e1 ocupando su correspondiente espacio en pantalla, no ser\u00e1 visible ni recibir\u00e1 eventos.</p>"},{"location":"2_vistas/ejercicios/","title":"Ejercicio de vistas en iOS: controles b\u00e1sicos (1,5 puntos)","text":"<p>El objetivo es practicar con los controles b\u00e1sicos de la interfaz de usuario en iOS creando un \"panel de control\" ficticio para una supuesta nave espacial al estilo del que aparece en la figura.</p> <p></p> <p>Puedes ayudarte de la documentaci\u00f3n de referencia de UIKit para ver los m\u00e9todos y propiedades de los componentes:</p> <ul> <li>(0,25 puntos) Campo de texto: Al escribir en \u00e9l y pulsar intro en el teclado onscreen ,debe concatenarse lo escrito al campo de texto de varias l\u00edneas (un text view)</li> </ul> <p>Si quieres que aparezca el teclado onscreen en el simulador debes desactivar la opci\u00f3n de men\u00fa de <code>I/O &gt; Keyboard &gt; Connect Hardware Keyboard</code> (que por defecto aparece activada) ya que si lo est\u00e1 se usar\u00e1 el teclado f\u00edsico del Mac pero no aparecer\u00e1 el teclado en pantalla.</p> <ul> <li>(0,5 puntos) Slider: <ul> <li>Debes fijar el valor inicial en 0 y el final en 100 (son propiedades del objeto). F\u00edjalas por c\u00f3digo en el <code>viewDidLoad</code> del controller, consulta la documentaci\u00f3n para ver el nombre. Necesitar\u00e1s un outlet para acceder al slider y poder cambiar sus propiedades por c\u00f3digo.</li> <li>Al cambiar su valor debe aparecer en un label al lado cu\u00e1l es el valor actual. Al igual que los botones, para procesar un cambio en un slider puedes crear un action con Ctrl+Arrastrar</li> </ul> </li> <li>(0,25 puntos) Al pulsar el bot\u00f3n \u00a1Emergencia! debe aparecer un action sheet con tres opciones: \"nave salvavidas\", \"hiperespacio\" o \"autodestrucci\u00f3n\" (como ves, una opci\u00f3n a la que deber\u00edas ponerle <code>style: .destructive</code>). Las opciones simplemente imprimir\u00e1n un mensaje en la consola con <code>print</code> (por ejemplo \"\u00a1\u00a1Lanzada nave salvavidas!!).</li> <li>(0,5 puntos) A\u00f1ade un picker para elegir el destino del viaje de entre una serie de destinos prefijados (por ejemplo \"Saturno\", \"M13\", \"Nebulosa de Ori\u00f3n\",...). Cada vez que cambie el valor seleccionado en el picker debe aparecer un mensaje en la consola indic\u00e1ndolo y mostrando el valor actual.</li> </ul>"},{"location":"3_autolayout/apuntes/","title":"Autolayout","text":""},{"location":"3_autolayout/apuntes/#el-por-que-de-autolayout","title":"El por qu\u00e9 de autolayout","text":"<p>Hasta ahora en todas las apps que hemos desarrollado hemos colocado los componentes de interfaz en coordenadas fijas, arrastr\u00e1ndolas hasta su posici\u00f3n visualmente con Xcode o bien especificando directamente las coordenadas en Swift. El problema de esto es que si cambiamos de dispositivo o se rota la pantalla la interfaz no se va adaptar adecuadamente, ya que las dimensiones han cambiado y las coordenadas antes especificadas ahora pueden no tener sentido.</p> <p>Por ejemplo, supongamos que queremos centrar un bot\u00f3n en la pantalla, tanto vertical como horizontalmente. En principio parece que basta con moverlo con el rat\u00f3n hacia el centro. En el momento que el bot\u00f3n est\u00e1 centrado, aparecen unas gu\u00edas punteadas que nos lo indican.</p> <p></p> <p>Sin embargo estas gu\u00edas solo nos est\u00e1n indicando que el componente est\u00e1 centrado con la resoluci\u00f3n actual, pero no va a seguir centrado si esta cambia.</p> <p>Si ejecutamos la aplicaci\u00f3n en el simulador usando el mismo dispositivo que hemos usado en el proceso de dise\u00f1o veremos que efectivamente est\u00e1 centrado. Pero no es as\u00ed si cambiamos el dispositivo, o si por ejemplo rotamos la pantalla en el simulador (tecla Cmd-Flecha izquierda)</p> <p></p> <p>Necesitamos alg\u00fan sistema que adapte autom\u00e1ticamente las dimensiones de los componentes de la interfaz a la resoluci\u00f3n actual. En iOS ese sistema es Autolayout. Es un sistema declarativo y basado en restricciones. El sistema usa las restricciones especificadas para calcular autom\u00e1ticamente el frame de cada vista de la interfaz, y adaptarlo a las dimensiones actuales de la ventana.</p>"},{"location":"3_autolayout/apuntes/#manejo-de-restricciones-desde-xcode","title":"Manejo de restricciones desde Xcode","text":"<p>Para especificar qu\u00e9 aspecto queremos que tenga la interfaz independientemente de la resoluci\u00f3n hay que a\u00f1adir restricciones. B\u00e1sicamente las hay de dos tipos:</p> <ul> <li>De alineaci\u00f3n (align): por ejemplo queremos que un bot\u00f3n est\u00e9 centrado horizontalmente o verticalmente en su contenedor. O que varios componentes est\u00e9n alineados entre s\u00ed.</li> <li>De espaciado (pin): por ejemplo queremos que entre un componente y otro, o entre un componente y el borde izquierdo de la pantalla haya un espacio vac\u00edo. Aqu\u00ed tambi\u00e9n se incluir\u00edan las restricciones de tama\u00f1o de un componente individual. (fijar el ancho, el alto,\u2026)</li> </ul> <p>Hay dos formas de a\u00f1adir restricciones en Xcode: \"haciendo clic y arrastrando\" con el rat\u00f3n o bien a trav\u00e9s de la barra de herramientas de AutoLayout.</p>"},{"location":"3_autolayout/apuntes/#anadiendo-restricciones-con-botonesmenus","title":"A\u00f1adiendo restricciones con botones/men\u00fas","text":"<p>En la parte inferior derecha del storyboard hay una barra de botones espec\u00edficos para autolayout:</p> <p></p> <p>Los que nos sirven para a\u00f1adir restricciones son el segundo y el tercero. Luego veremos el uso de los restantes.</p> <p>Vamos a arreglar el ejemplo anterior en el que quer\u00edamos centrar horizontal y verticalmente el bot\u00f3n. Tenemos que a\u00f1adir dos restricciones: una de centrado horizontal y otra de centrado vertical. En terminolog\u00eda de autolayout esto son restricciones de alineado (align).</p> <ol> <li>Seleccionamos este con el rat\u00f3n y pulsamos sobre el icono de <code>Align</code> (el segundo).</li> <li>En el popup que aparece marcamos las casillas de <code>Horizontally in container</code> y <code>Vertically in container</code></li> <li>Pulsamos sobre el bot\u00f3n que ahora pondr\u00e1 <code>Add 2 constraints</code> para hacer efectivas las restricciones.</li> </ol> <p></p> <p>Las l\u00edneas de gu\u00eda, que antes aparec\u00edan punteadas, ahora ser\u00e1n continuas indicando que ahora son restricciones de autolayout. Aunque cambiemos de dispositivo o de orientaci\u00f3n veremos que el bot\u00f3n sigue centrado.</p> <p>Las restricciones a\u00f1adidas las podemos ver en varios sitios de Xcode:</p> <ul> <li>En el \u00e1rea de <code>Document outline</code>, que es accesible pulsando sobre el icono  que aparece en la parte inferior izquierda del storyboard. Aqu\u00ed podemos ver un \u201c\u00e1rbol\u201d desplegable con las restricciones.     </li> <li>En el <code>Size inspector</code> (icono  del panel de la derecha de Xcode) aparece una lista de restricciones aplicadas al componente actual. Cada una tiene un bot\u00f3n <code>Edit</code> para cambiar sus propiedades, aunque aqu\u00ed se muestran en su forma \"matem\u00e1tica\" que no es la m\u00e1s intuitiva (luego veremos que las restricciones son en realidad ecuaciones).</li> </ul> <p>Para editar las restricciones:</p> <ul> <li>Si hacemos clic sobre una restricci\u00f3n, ya hemos visto que podemos editar sus propiedades en el  <code>Size inspector</code>  del panel derecho de Xcode).</li> <li>Si seleccionamos una restricci\u00f3n y pulsamos la tecla <code>Backspace</code> se eliminar\u00e1 esta.</li> </ul>"},{"location":"3_autolayout/apuntes/#anadiendo-restricciones-con-el-raton","title":"A\u00f1adiendo restricciones con el rat\u00f3n","text":"<p>Esta forma es algo m\u00e1s \u00e1gil que la anterior pero requiere de cierta pr\u00e1ctica.  Cuando queremos establecer una restricci\u00f3n entre dos elementos arrastramos de uno a otro manteniendo pulsada la tecla <code>Ctrl</code> (igual que para crear un outlet o un action). Cuando soltamos el bot\u00f3n del rat\u00f3n, aparece un men\u00fa contextual donde elegir la restricci\u00f3n.  Las opciones disponibles en el men\u00fa dependen de la direcci\u00f3n y sentido en que se haya arrastrado:  - Si arrastramos en sentido horizontal, podemos (entre otros) centrar verticalmente. Y al contrario si arrastramos en vertical. - Las restricciones de espaciado ser\u00e1n hacia el borde que hayamos arrastrado.</p> <p>Cuando se a\u00f1aden restricciones de espaciado con respecto al borde superior e inferior de la pantalla, puede verse que en realidad no se est\u00e1n referenciando los bordes de la pantalla en s\u00ed sino los de un \u00e1rea que Xcode llama <code>safe area</code></p> <p>Estas \u00e1reas \u201ccrecen autom\u00e1ticamente\u201d para dejar espacio a las barras de navegaci\u00f3n y de botones que veremos cuando usemos navigation controllers y tab bar controllers, asegur\u00e1ndonos as\u00ed de que dichas barras no tapan a nuestras vistas. </p>"},{"location":"3_autolayout/apuntes/#restricciones-insuficientes-o-contradictorias","title":"Restricciones insuficientes o contradictorias","text":"<p>Generalmente cuando comenzamos a a\u00f1adir restricciones, las l\u00edneas que las representan aparecen en color naranja en lugar de azul. Esto sucede porque todav\u00eda las restricciones son insuficientes para determinar un\u00edvocamente las coordenadas del frame del componente. Por ejemplo si acabamos de crear un bot\u00f3n y lo centramos verticalmente, lo hemos \u201cfijado\u201d en el eje de las <code>x</code> pero no as\u00ed en el de las <code>y</code>. Adem\u00e1s se muestra un contorno dibujado en l\u00ednea punteada que indica d\u00f3nde calcula Xcode que acabar\u00e1 posicion\u00e1ndose el componente con las restricciones actuales (y que a lo mejor no es donde nosotros queremos).</p> <p>Como regla general nos van a hacer falta dos restricciones por cada dimensi\u00f3n (X e Y) para eliminar la ambig\u00fcedad, aunque hay elementos que solo necesitan una restricci\u00f3n por dimensi\u00f3n, como los botones. Veamos por qu\u00e9.</p> <p>Los botones tienen lo que se denomina un tama\u00f1o intr\u00ednseco. Es decir, aunque no lo digamos expl\u00edcitamente, iOS le asigna el ancho y el alto justo para que quepa el texto mostrado. O sea, es como si ya tuvieran una restricci\u00f3n impl\u00edcita en la X y en la Y. As\u00ed que cuando decimos que el bot\u00f3n est\u00e9 centrado en la X (verticalmente), a autolayout le basta esta restricci\u00f3n para determinar el comportamiento del bot\u00f3n en esta dimensi\u00f3n, ya que la combina con el tama\u00f1o impl\u00edcito. </p> <p>Otros componentes que tienen como tama\u00f1o intr\u00ednseco su contenido son los <code>UILabel</code>, los <code>UIImage</code>, los <code>UITextField</code>. Los <code>UISwitch</code> tienen tambi\u00e9n un ancho y alto fijos, as\u00ed como los <code>UIStepper</code>. Los <code>UISlider</code> son un caso especial porque tienen un alto fijo pero no pasa as\u00ed con el ancho (M\u00e1s informaci\u00f3n)</p> <p>Sin embargo no ocurre lo mismo con otros componentes. Por ejemplo los text view con barra de scroll no tienen un tama\u00f1o intr\u00ednseco. De este modo, a\u00f1adir la restricci\u00f3n de centrar un <code>Text View</code> en la dimensi\u00f3n X no resuelve la ambig\u00fcedad de qu\u00e9 ancho deber\u00eda tener, o visto de otro modo, en qu\u00e9 valor de x deber\u00eda empezar su borde izquierdo. Para este tipo de elementos nos har\u00e1n falta dos restricciones por cada dimensi\u00f3n, o dicho de otro modo 4 en total para posicionar el elemento sin ambig\u00fcedades. Otros componentes tienen un tama\u00f1o intr\u00ednseco solo en una dimensi\u00f3n, por ejemplo los slider lo tienen en la Y pero no en la X, por lo que nos har\u00e1 falta una \u00fanica restricci\u00f3n en la Y pero dos en la X.</p> <p>Otro problema t\u00edpico es cuando movemos con el rat\u00f3n el elemento una vez se ha establecido la restricci\u00f3n, de modo que no ocupa la posici\u00f3n que esta restricci\u00f3n est\u00e1 induciendo. Las l\u00edneas de restricci\u00f3n tambi\u00e9n aparecer\u00e1n en naranja, y el n\u00famero que indica su tama\u00f1o tendr\u00e1 un s\u00edmbolo <code>+</code> o <code>-</code> para indicar el desplazamiento. Podemos hacer que el elemento vuelva a la posici\u00f3n que indican las restricciones pulsando sobre el primero de los botones de autolayout, <code>Update Frames</code>.</p> <p>Cuando las restricciones son contradictorias, las l\u00edneas que las representan aparecen en color rojo. Por ejemplo en la siguiente figura hemos intentado especificar un espaciado de 20 puntos con el margen derecho, un ancho de 46 y adem\u00e1s que est\u00e9 centrado en horizontal. Con un tama\u00f1o de pantalla convencional esto es imposible, y as\u00ed lo indica Xcode.</p> <p></p> <p>Cuando hay problemas con las restricciones estos se muestran tambi\u00e9n en el <code>Document outline</code> del storyboard. En el \u00e1ngulo superior derecho del <code>Document outline</code> aparece una peque\u00f1a flecha roja indicando que hay problemas, y si la pulsamos aparecer\u00e1 la lista de restricciones contradictorias e insuficientes.</p> <p>Podemos intentar resolver estos problemas de forma autom\u00e1tica. Para eso est\u00e1 el bot\u00f3n <code>Resolve autolayout issues</code> de la barra de botones de autolayout (recordar que est\u00e1 en la esquina inferior derecha del storyboard). Hay varias posibilidades:</p> <ul> <li><code>Update frames</code>: queremos recalcular las posiciones y dimensiones de los frames usando las restricciones actuales. Si hemos movido los elementos con el rat\u00f3n, volver\u00e1n a \u201csu posici\u00f3n\u201d.</li> <li><code>Update restrictions</code>: si hemos movido los elementos, Xcode intentar\u00e1 recalcular las restricciones para que se correspondan con la posici\u00f3n actual.</li> <li><code>Add missing constraints</code>: bas\u00e1ndose en la posici\u00f3n actual de los elementos, Xcode intentar\u00e1 inferir y a\u00f1adir las restricciones adecuadas para que el layout deje de ser ambiguo.</li> <li><code>Reset to suggested constraints</code>: el equivalente a eliminar todas las restricciones (<code>Clear constraints</code>) y luego seleccionar <code>Add missing constraints</code>.</li> </ul>"},{"location":"3_autolayout/apuntes/#previsualizar-el-efecto-de-las-restricciones","title":"Previsualizar el efecto de las restricciones","text":"<p>Podemos previsualizar el efecto de las restricciones desde el propio Xcode. En la parte inferior del storyboard editor se ve el dispositivo que estamos usando actualmente, aparece algo como \"View as: iPhone XR\". Si clicamos con el rat\u00f3n en ese nombre aparecer\u00e1 una barra de herramientas para cambiar el dispositivo y/o la orientaci\u00f3n</p>"},{"location":"3_autolayout/apuntes/#restricciones-sobre-el-tamano","title":"Restricciones sobre el tama\u00f1o","text":"<p>Aunque hemos dicho que autolayout calcula el frame de cada componente, hasta ahora hemos ignorado el tama\u00f1o de los mismos. Centrar en horizontal y vertical elimina la ambig\u00fcedad en cuanto a en qu\u00e9 coordenadas \u201canclar\u201d el frame pero \u00bfqu\u00e9 hay de su ancho y alto?. </p> <p>Para muchos componentes (<code>UILabel</code>, <code>UIButton</code>, <code>UIImage</code>) no es necesario especificar un tama\u00f1o ya que lo tienen por defecto (el llamado \u201ctama\u00f1o intr\u00ednseco\u201d en el argot de autolayout). En el API la propiedad correspondiente es <code>intrinsicContentSize</code>. Lo m\u00e1s habitual es que sea el tama\u00f1o del texto que contienen. </p> <p>No obstante, tambi\u00e9n podemos poner restricciones sobre el tama\u00f1o. Podemos fijar el ancho y/o el alto o el aspect ratio. Estas son restricciones del tipo <code>pin</code> y por tanto las podemos encontrar donde encontramos las de espaciado entre componentes (en el men\u00fa principal o en la barra de botones de autolayout). Si usamos <code>ctrl-arrastrar</code> con el rat\u00f3n bastar\u00e1 con que arrastremos sin salirnos del componente (al arrastrar en horizontal se nos dar\u00e1 la posibilidad de finar el ancho y lo mismo con el alto si arrastramos en vertical). </p> <p>Si especificamos el tama\u00f1o mediante una restricci\u00f3n podemos forzar a que el contenido del bot\u00f3n tenga que \u201ccortarse\u201d porque no cabe, o bien que tenga que a\u00f1adirse un padding al sobrar espacio. </p>"},{"location":"3_autolayout/apuntes/#prioridades","title":"Prioridades","text":"<p>En autolayout a veces puede haber reglas contradictorias o ambiguas. Una forma de resolver estas ambig\u00fcedades o contradicciones es mediante el uso de  prioridades*.</p>"},{"location":"3_autolayout/apuntes/#prioridades-de-las-restricciones","title":"Prioridades de las restricciones","text":"<p>Cada restricci\u00f3n tiene asignada una prioridad, que es un valor num\u00e9rico que especifica su \u201cimportancia\u201d (a mayor valor, mayor prioridad):</p> <ul> <li>El valor por defecto es 1000, que significa que el sistema entiende que la restricci\u00f3n debe cumplirse. </li> <li>Valores menores que 1000 indican que el sistema intentar\u00e1 cumplir la restricci\u00f3n pero que es posible que no lo haga, si hay restricciones contradictorias de mayor prioridad.</li> </ul> <p>Podemos cambiar/ver la prioridad actual de la misma forma que podemos cambiar/ver el resto de propiedades de la restricci\u00f3n (ver apartado anterior).</p>"},{"location":"3_autolayout/apuntes/#prioridades-de-los-componentes","title":"Prioridades de los componentes","text":"<p>Hay casos en los que puede ser necesario \"comprimir\" o \"ensanchar\" los componentes para cumplir las restricciones. En el siguiente ejemplo, estamos fijando el espacio horizontal entre componentes y de componentes a m\u00e1rgenes muy peque\u00f1o, en 8 puntos, pero para que los espacios se cumplan, alguno de los componentes, o los dos, se tendr\u00eda que ensanchar con respecto a su tama\u00f1o intr\u00ednseco:</p> <p> </p> <p>Como vemos Xcode indica que hay un problema con las restricciones, ya que el layout es ambiguo. Para cumplir las restricciones se podr\u00eda ensanchar la imagen o el label con respecto a su tama\u00f1o intr\u00ednseco. \u00bfCu\u00e1l elegir?</p> <p></p> <p>Adem\u00e1s de las restricciones, tambi\u00e9n los componentes GUI tienen dos valores de prioridad, relativos al tama\u00f1o. El Content hugging indica la prioridad que para el componente tiene evitar el padding (o \"relleno\" o \"ensanchado\"). Por defecto tiene un valor de 251. </p> <p>Fijaos en que es un valor relativamente bajo, indicando que si hay reglas que lleven a aumentar el padding se tomar\u00e1n en cuenta salvo que tengan prioridad muy baja.</p> <p>El problema anterior se podr\u00eda resolver modificando el hugging de alguno de los dos componentes, el label o la imagen. Si subimos la prioridad de un componente haremos que se \"expanda\" el otro, y a la inversa, si la bajamos, lo haremos \"expandirse\" a \u00e9l.</p> <p>En el problema inverso al anterior, podr\u00edamos haber exigido que los espacios entre componentes fueran muy grandes, forzando entonces a que uno de los dos componentes se \"comprima\" (y por ejemplo en el caso del label deje de mostrar parte de su contenido). Para poder decidir cu\u00e1l de ellos tenemos la Compression resistance, que es la prioridad que para el componente tiene mostrar completo su contenido, resisti\u00e9ndose por tanto a ser comprimido. Por defecto los componentes tienen este valor a 750. De nuevo jugando con este valor podemos decidir qu\u00e9 componente se deber\u00eda comprimir.</p> <p>Si una regla con prioridad por defecto lleva a que el contenido de un elemento se comprima ganar\u00e1 la regla, pero no ser\u00e1 as\u00ed si su prioridad es menor que 750. N\u00f3tese que se ha escogido un valor por defecto relativamente alto para evitar que reglas \"no demasiado importantes\" lleven a que se compriman los componentes y dejen de mostrarse \"completos\" como t\u00edtulos de botones, textos de labels, etc.</p>"},{"location":"3_autolayout/apuntes/#stack-views","title":"Stack views","text":"<p>Son agrupaciones de componentes en forma de fila o columna, y se usan para crear f\u00e1cilmente layouts de elementos en disposici\u00f3n horizontal o vertical. As\u00ed solo hay que especificar las restricciones del stack view como un bloque, y no de cada componente por separado.</p> <p></p> <p>Para crear un stack view, seleccionar varios elementos (manteniendo pulsado <code>Command</code> + clic del rat\u00f3n en cada uno) y luego pulsar sobre el \u00faltimo bot\u00f3n de la barra de autolayout, llamado <code>Embed In</code> (recordad, parte inferior derecha de la ventana del storyboard). En el men\u00fa desplegable del bot\u00f3n, elegir <code>Stack View</code>. Si los componentes seleccionados estaban m\u00e1s o menos en vertical se crear\u00e1 un stack view de este tipo y lo mismo si est\u00e1n en horizontal, aunque el tipo se puede cambiar en las propiedades.</p> <p>Las propiedades del stack view son accesibles seleccion\u00e1ndolo con el rat\u00f3n y como siempre en el Inspector de propiedades (el icono con una escuadra, panel derecho de Xcode). Podemos indicar c\u00f3mo se reparten los componentes el espacio disponible, dejar un espacio adicional entre ellos, especificar la alineaci\u00f3n,...</p> <p></p> <ul> <li>El <code>Axis</code> indica si el stack view es vertical u horizontal</li> <li><code>Alignment</code> es la alineaci\u00f3n en la perpendicular al eje del stack view, es decir, es la alineaci\u00f3n vertical para los stack views horizontales y viceversa. </li> <li><code>Distribution</code> se refiere c\u00f3mo se distribuyen los elementos en la direcci\u00f3n del eje del stack view</li> </ul>"},{"location":"3_autolayout/apuntes/#alignment-y-distribution","title":"<code>Alignment</code> y <code>Distribution</code>","text":"<p>Como hemos dicho, se refiere c\u00f3mo se alinean los componentes en la perpendicular al eje del stack view. Para uno horizontal, se referir\u00e1 entonces a la alineaci\u00f3n en vertical: <code>Fill</code>, <code>Top</code>, <code>Center</code> o <code>Bottom</code>. Los valores son distintos para los stack view verticales, en este caso pueden ser <code>Fill</code>, <code>Leading</code>, <code>Center</code> o <code>Trailing</code>.</p> <p>En un stack view horizontal, b\u00e1sicamente la altura la determina el elemento m\u00e1s alto. Con <code>Fill</code> indicamos que queremos que todos los componentes tengan el mismo tama\u00f1o en Y (el del componente m\u00e1s alto). El resto de opciones son diferentes alineaciones verticales. El mismo razonamiento se puede hacer con un stack view vertical, el elemento m\u00e1s anchho y <code>Fill</code>.</p> <p>En cuanto a <code>distribution</code>:</p> <ul> <li><code>Fill</code>: se llena el espacio del stack view pero cada componente puede tener un tama\u00f1o distinto</li> <li><code>Fill Equally</code>: se llena el espacio del stack view y todos los componentes tienen el mismo tama\u00f1o (ancho para stacks horizontales y alto para verticales).</li> <li><code>Fill Proportionally</code>: se llena el espacio del stack view, cada componente de manera proporcional a su tama\u00f1o intr\u00ednseco.</li> <li><code>Equal Spacing</code>: el espacio entre componentes debe ser igual y como m\u00ednimo el valor de la propiedad <code>spacing</code> del stack view.</li> </ul> <p>Tambi\u00e9n podemos anidar stack views, tener unos dentro de otros, por ejemplo aqu\u00ed tenemos uno horizontal anidado dentro de una fila de uno vertical</p> <p></p>"},{"location":"3_autolayout/apuntes/#restricciones-avanzadas","title":"Restricciones \"avanzadas\"","text":"<p>Nota</p> <p>Esta parte es complementaria, y aunque interesante, no es necesaria para realizar los ejercicios de la sesi\u00f3n.</p>"},{"location":"3_autolayout/apuntes/#formulacion-matematica-de-una-restriccion","title":"Formulaci\u00f3n matem\u00e1tica de una restricci\u00f3n","text":"<p>Internamente, cada restricci\u00f3n se formula como una ecuaci\u00f3n lineal en la que:</p> <pre><code>item1.atributo1 = multiplicador * item2.atributo2 + cte\n</code></pre> <p>Algunas restricciones no son ecuaciones sino inecuaciones, sustituyendo el s\u00edmbolo <code>=</code> por <code>&lt;=</code> o <code>&gt;=</code>.</p> <p>Es decir, desde el punto de vista formal, lo que hace autolayout es resolver un sistema de ecuaciones lineales.</p> <p>Estas propiedades podemos verlas en el <code>Size inspector</code> (parte derecha de la pantalla, icono de la regla ). Si seleccionamos un componente de UI aparecer\u00e1n aqu\u00ed todas sus restricciones, que podemos editar pulsando en Edit. Por ejemplo, aqu\u00ed vemos las restricciones de un bot\u00f3n centrado en el eje de las X y con un espaciado est\u00e1ndar (8 puntos) con respecto a la gu\u00eda inferior.</p> <p></p> <p>Podemos observar en la figura las propiedades de la restricci\u00f3n, que se corresponden directamente con los coeficientes del lado derecho de la ecuaci\u00f3n lineal (el multiplicador y la constante). Adem\u00e1s aparece una prioridad, que explicaremos en el siguiente apartado. Haciendo clic en el desplegable con el s\u00edmbolo <code>=</code> podemos cambiar la ecuaci\u00f3n por una inecuaci\u00f3n.</p> <p>En nuestro ejemplo la constante es 0 y el multiplicador 1 porque queremos centrar el componente en el contenedor, es decir</p> <pre><code>contenedor.centerX = componente.centerX\n</code></pre> <p>Podemos por ejemplo cambiar la constante por 50, con lo que conseguiremos que el componente est\u00e9 desplazado 50 puntos a la izquierda de la posici\u00f3n de \u201ccentrado en X\u201d.</p> <p>Si en lugar de seleccionar el componente GUI seleccionamos directamente una restricci\u00f3n y nos vamos al <code>Size inspector</code> podremos editar directamente las propiedades de la restricci\u00f3n, incluyendo tambi\u00e9n los propios atributos.</p>"},{"location":"3_autolayout/apuntes/#expresar-restricciones-usando-codigo-swift","title":"Expresar restricciones usando c\u00f3digo Swift","text":"<p>En lugar de usar el editor visual de Xcode podemos especificar las restricciones por c\u00f3digo. Esto puede resultar interesante en diversas situaciones: </p> <ul> <li>A veces los elementos de la interfaz se crean din\u00e1micamente y por tanto no se puede especificar el layout por adelantado en Xcode. </li> <li>Otras veces, aunque los elementos de la interfaz no cambien en s\u00ed puede que queramos cambiar din\u00e1micamente las restricciones para conseguir efectos din\u00e1micos de layout.</li> </ul> <p>Hay dos formas de hacerlo: directamente con el API de autolayout o con un mayor nivel de abstracci\u00f3n usando el llamado \u201cVisual Format Language\u201d. Si podemos elegir, la mejor forma es la segunda, ya que es mucho m\u00e1s intuitivo especificar las restricciones y entenderlas leyendo luego el c\u00f3digo.</p>"},{"location":"3_autolayout/apuntes/#el-api-basico-de-autolayout","title":"El API b\u00e1sico de autolayout","text":"<p>Cada restricci\u00f3n es un objeto de la clase <code>NSLayoutConstraint</code>. En el inicializador de esta clase se especifica directamente par\u00e1metro por par\u00e1metro cada una de las propiedades de la restricci\u00f3n. Por ejemplo, supongamos que estamos en un view controller y queremos centrar un bot\u00f3n en su contenedor en el eje de las X. El bot\u00f3n lo tenemos en un outlet llamado <code>boton</code>, y ya sabemos que a la vista podemos acceder desde el controller con <code>self.view</code> . La restricci\u00f3n en forma de expresi\u00f3n matem\u00e1tica ser\u00eda algo como</p> <pre><code>self.view.centerX = 1*boton.centerX+0\n</code></pre> <p>Donde se ha puesto de forma expl\u00edcita la constante y el multiplicador para ver m\u00e1s clara la correspondencia directa con el c\u00f3digo Swift, donde se har\u00eda como:</p> <pre><code>let centradoX = NSLayoutConstraint(item: self.boton,\n                   attribute: .centerY,\n                   relatedBy: .equal,\n                   toItem: self.view,\n                   attribute: .centerY,\n                   multiplier: 1.0,\n                   constant: 0.0)\n</code></pre> <p>Como vemos hay una correspondencia bastante directa entre la expresi\u00f3n matem\u00e1tica y el c\u00f3digo. Una vez creada la constante hay que activarla. Esto se puede hacer fijando <code>isActive</code> a <code>true</code></p> <pre><code>centradoX.isActive = true\n</code></pre> <p>Una alternativa es a\u00f1adir la restricci\u00f3n a la vista con <code>addConstraint()</code></p> <pre><code>self.view.addConstraint(centradoX)\n</code></pre> <p>Como vemos, hemos a\u00f1adido la restricci\u00f3n al contenedor del bot\u00f3n. Como norma general, si son vistas \u201cmadre/hija\u201d la a\u00f1adiremos a la \u201cmadre\u201d, y en otro caso al ancestro com\u00fan m\u00e1s cercano de ambas vistas. Por ejemplo si fuera una relaci\u00f3n entre dos botones dentro del mismo contenedor la a\u00f1adir\u00edamos al contenedor.</p> <p>MUY IMPORTANTE: Xcode a\u00f1ade impl\u00edcitamente algunas restricciones a los componentes, adem\u00e1s de las puestas expl\u00edcitamente por nosotros en c\u00f3digo, y es bastante probable que entren en conflicto con las nuestras y para resolver el problema el sistema las acabe ignorando. Por ello para usar autolayout por c\u00f3digo lo primero es indicar que para un determinado componente no queremos esas restricciones \u201cautom\u00e1ticas\u201d. En nuestro caso para el bot\u00f3n:</p> <pre><code>self.boton.translatesAutoresizingMaskIntoConstraints = false\n</code></pre> <p>Esto habr\u00eda que hacerlo antes de activar las restricciones.</p>"},{"location":"3_autolayout/apuntes/#visual-format-language","title":"Visual Format Language","text":"<p>La conversi\u00f3n de ecuaci\u00f3n matem\u00e1tica a llamada del API es bastante directa, pero tiene el problema de que no es f\u00e1cil y r\u00e1pido deducir intuitivamente la restricci\u00f3n leyendo el c\u00f3digo. Es mucho m\u00e1s intuitivo leer \u201cel componente debe estar centrado en el eje X pero desplazado 10 pixels a la izquierda\u201d que leer <code>superview.centroX = componente.centroX + 10</code>.</p> <p>La descripci\u00f3n formal pero a la vez intuitiva de un conjunto de restricciones se puede hacer con una ingeniosa \u201crepresentaci\u00f3n en modo texto\u201d de la representaci\u00f3n gr\u00e1fica de las restricciones llamada Visual Format Language. Dicho formato permite representar un conjunto de restricciones con una cadena de caracteres. La representaci\u00f3n usa s\u00edmbolos \u201csemi-gr\u00e1ficos\u201d, un poco al estilo del ASCII-ART (salvando las distancias). As\u00ed, por ejemplo si queremos especificar que entre dos componentes debe haber una separaci\u00f3n est\u00e1ndar (8 pixels) usar\u00edamos la cadena:</p> <pre><code>[boton1]-[boton2]\n</code></pre> <p>Donde los corchetes indican un componente, y el ``-``` indica la separaci\u00f3n est\u00e1ndar. La cadena se parece razonablemente a la representaci\u00f3n gr\u00e1fica que podr\u00edamos ver en Xcode de la misma restricci\u00f3n.</p> <p>Hay que indicar que <code>boton1</code> y <code>boton2</code> no son exactamente nombres de variables sino etiquetas arbitrarias. </p> <p>La llamada al API para crear esta restricci\u00f3n usando el visual format language ser\u00eda algo como:</p> <pre><code>let constraint = NSLayoutConstraint.constraints(\n                   withVisualFormat:\"[boton1]-[boton2]\"\n                   options: .alignAllCenterY, \n                   metrics: nil,   \n                   views:viewsDict];\n</code></pre> <p>donde:  - El primer par\u00e1metro es la cadena de formato - <code>options</code> es una m\u00e1scara de bits formada a partir de enumerados describiendo la direcci\u00f3n y la alineaci\u00f3n de los componentes - <code>metrics</code> se usa si hay constantes en la restricci\u00f3n (no es el caso del ejemplo). Es un diccionario en el que las claves son los nombres de las constantes y los valores son los de las constantes. - El \u00faltimo es un diccionario donde las claves son los nombres de componentes en la cadena y los valores son las variables correspondientes a las vistas. Lo habr\u00edamos creado con un c\u00f3digo como:</p> <pre><code>let b1 = UIButton()  \nlet b2 = UIButton()\nlet viewsDict = [\"boton1\":b1, \"boton2\":b2]\n</code></pre> <p>Algunos ejemplos adicionales de cadenas de formato:</p> <ul> <li><code>[boton1]-20-[boton2]</code> separaci\u00f3n de 20 puntos</li> <li><code>[boton1(50)]-20-[boton2(&gt;=50)]</code> entre par\u00e9ntesis especificamos el ancho del bot\u00f3n, n\u00f3tese que se pueden poner desigualdades</li> <li><code>[boton1]-20@800-[boton2]</code> las prioridades se ponen con la <code>@</code></li> <li><code>[boton1]-20-[boton2(==boton1)]</code> el bot\u00f3n 2 debe ser del mismo tama\u00f1o que el 1.</li> <li><code>V:[topField]-10-[bottomField]</code> con la <code>V</code> especificamos que es un layout en vertical, los dos campos estar\u00e1n uno encima del otro separados por una distancia de 10 puntos.</li> <li><code>|-[find]-[findNext]-[findField(&gt;=20)]-|</code>una l\u00ednea completa de layout, donde las barras verticales representan los bordes del contenedor.</li> </ul> <p>Se recomienda consultar la documentaci\u00f3n de Apple para m\u00e1s informaci\u00f3n sobre la sintaxis y ejemplos adicionales.</p> <p>En el dise\u00f1o del formato, se ha preferido la claridad y el paralelismo con la representaci\u00f3n gr\u00e1fica a la expresividad. Como resultado, ciertas restricciones no son expresables. Por ejemplo no se puede especificar que el ancho de un bot\u00f3n sea el doble que el de otro.</p>"},{"location":"3_autolayout/ejercicios/","title":"Ejercicios de Autolayout (1,5 puntos)","text":"<p>El objetivo es a\u00f1adir autolayout a la aplicaci\u00f3n de \u201cpioneras\u201d que hicimos en sesiones anteriores para que la interfaz se vea correctamente en todos los modelos de iPhone.</p>"},{"location":"3_autolayout/ejercicios/#pantalla-inicial-05-puntos","title":"Pantalla inicial (0,5 puntos)","text":"<p>Incluye los tres botones de la pantalla principal en un stack view vertical para que estos aparezcan con el mismo tama\u00f1o (consulta la secci\u00f3n de stack view de los apuntes)</p> <p>Una vez hecho esto, haz que ocupen toda la pantalla sea cual sea la resoluci\u00f3n. Lo m\u00e1s sencillo es poner distancia 0 del stack view a los 4 bordes.</p>"},{"location":"3_autolayout/ejercicios/#pantalla-secundaria-05-puntos","title":"Pantalla secundaria (0,5 puntos)","text":"<p>A\u00f1adid restricciones a la pantalla secundaria (la que muestra informaci\u00f3n sobre cada pionera). Se deben cumplir las siguientes condiciones aproximadamente: </p> <ul> <li>El text view debe aparecer centrado horizontal y verticalmente. Debes fijar adem\u00e1s o bien su tama\u00f1o o bien la separaci\u00f3n con los bordes, queda a tu elecci\u00f3n.</li> <li>El bot\u00f3n debe aparecer en la parte inferior de la pantalla, a una distancia fija del borde (la que quieras), y centrado horizontalmente.</li> </ul>"},{"location":"3_autolayout/ejercicios/#launch-screen-05-puntos","title":"Launch Screen (0,5 puntos)","text":"<p>Haz un <code>LaunchScreen.storyboard</code> que quede como el de la siguiente imagen (mis disculpas a todos los dise\u00f1adores de interfaces :)):</p> <p></p> <ul> <li>La imagen la puedes descargar de aqui. Crea un nuevo \"image set\" en el assets llamado \"logo\" y arr\u00e1strala all\u00ed</li> <li>La <code>Image View</code>tiene como image al \"logo\" y como content mode \"aspect fit\", para que no se deformen las proporciones</li> <li>Tanto la imagen como el label \"MM.UA\" est\u00e1n centrados en vertical</li> <li>La imagen debe tener un aspect ratio de 1:2</li> <li>La imagen y el label \"MM.UA\" deben tener el mismo ancho (selecciona las dos clicando en cada una y manteniendo la tecla <code>Cmd</code>, y luego en el tercer bot\u00f3n de autolayout - \"Add new constraints\" tienes la restricci\u00f3n de \"equal widths\")</li> <li>La imagen est\u00e1 a 24 puntos del borde izquierdo, el label \"MM.UA\" a 24 del derecho y entre la imagen y el label tambi\u00e9n hay 24 puntos</li> <li>El label \"Universidad de Alicante\" est\u00e1 centrado en horizontal y a una distancia de 32 puntos del borde inferior de la imagen </li> </ul>"},{"location":"4_tablas/apuntes/","title":"Tablas","text":""},{"location":"4_tablas/apuntes/#introduccion","title":"Introducci\u00f3n","text":"<p>Las vistas de tabla (<code>UITableView</code>) se encargan de mostrar, gestionar y hacer scrolling de una tabla de elementos de una sola columna. Cada una de las filas se modela con un <code>UITableViewCell</code>.</p> <p>Si necesitamos m\u00e1s de una columna podemos usar <code>UICollectionView</code>, que ver\u00e9is  en la parte \u201cavanzada\u201d de la asignatura. En las \u00faltimas versiones de iOS las funcionalidades de <code>UICollectionView</code> se han ampliado para permitir mostrar solo una columna. </p> <p>Descritas as\u00ed, puede parecer que las tablas deben desempe\u00f1ar un papel muy limitado en las aplicaciones iOS, pero nada m\u00e1s lejos de la realidad. Son la forma m\u00e1s habitual en aplicaciones m\u00f3viles de mostrar listas de elementos, no solo en iOS sino en todas las plataformas. Adem\u00e1s su aspecto visual es enormemente configurable, con lo que que muchas \"pantallas\" de apps que a primera vista no lo parecen, en realidad son tablas, por ejemplo en las aplicaciones de Mail, Ajustes, Reloj\u2026</p> <p></p> <p>Las tablas pueden ser simples (<code>UITableViewStylePlain</code>)  o agrupadas (<code>UITableViewStyleGrouped</code>)</p> <p>Hay varios estilos predefinidos para las filas, que nos permiten mostrar diversos elementos: t\u00edtulo, subt\u00edtulo, icono a la izquierda, \u2026 Tambi\u00e9n podemos crear nuestros propios estilos de celda bien por c\u00f3digo o bien gr\u00e1ficamente en el interface builder.</p>"},{"location":"4_tablas/apuntes/#creacion-de-vistas-de-tabla","title":"Creaci\u00f3n de vistas de tabla","text":"<p>Una vista de tabla interact\u00faa b\u00e1sicamente con tres objetos. Pueden ser distintos o puede ser el mismo objeto que desempe\u00f1e m\u00e1s de un papel:</p> <ul> <li> <p>En primer lugar, el view controller. Ya hemos visto el papel que hace en las aplicaciones.</p> </li> <li> <p>En segundo lugar, el data source: las vistas de tabla solo almacenan directamente los datos de las filas actualmente visibles en pantalla. El resto se los piden a un objeto que debe ser conforme al protocolo <code>UITableViewDataSource</code>. Este es obligatorio, no podemos crear una tabla sin \u00e9l.</p> </li> <li> <p>Y finalmente el delegate: para gestionar algunos eventos de manipulaci\u00f3n de la tabla (como la edici\u00f3n, el borrado, o el mover una fila) y controlar algunos aspectos de la apariencia de las celdas, se usa el <code>UITableViewDelegate</code> </p> </li> </ul> <p>Es muy habitual, al menos en los casos m\u00e1s simples, que el controller, el delegate y el data source sean el mismo objeto.</p> <p>Si usamos una vista de tabla dibujada en el storyboard podemos conectarla con los dos \u201ccolaboradores\u201d gr\u00e1ficamente mediante el \u201cConnections Inspector\u201d del panel \u201cUtilities\u201d. La otra opci\u00f3n es establecer la conexi\u00f3n por c\u00f3digo, fijando ciertas propiedades de la tabla, que luego veremos.  </p>"},{"location":"4_tablas/apuntes/#tablas-estaticas","title":"Tablas est\u00e1ticas","text":"<p>En algunos casos conocemos de partida los elementos que queremos dibujar en la tabla. Ejemplo t\u00edpico de esto es la aplicaci\u00f3n de Ajustes, en la que las opciones est\u00e1n colocadas en una tabla simplemente para que est\u00e9n m\u00e1s organizadas y tengan un formato atractivo. Esto lo podemos conseguir con una tabla est\u00e1tica.</p> <p>Para crear una pantalla con una tabla est\u00e1tica arrastramos un <code>Table View Controller</code> al storyboard. Es un controller asociado a una vista de tabla que ocupa toda la pantalla del dispositivo. Por defecto usa una tabla din\u00e1mica, pero podemos cambiarlo seleccionando la tabla en el <code>Attributes inspector</code> y seleccionando <code>Static Cells</code> en la primera propiedad, <code>Content</code>.</p> <p>Podemos a\u00f1adir secciones a la tabla y cambiar el n\u00famero de celdas en cada secci\u00f3n. Para poder cambiar el n\u00famero de celdas hay que tener seleccionada la secci\u00f3n deseada, lo que a veces es dif\u00edcil con el rat\u00f3n, por lo que podemos usar los nodos del <code>Document outline</code>:</p> <p></p> <p>Podemos aumentar el n\u00famero de celdas de modo que no quepan en la pantalla. Para desplazarnos por la tabla podemos seleccionarla y hacer scroll con la rueda del rat\u00f3n</p>"},{"location":"4_tablas/apuntes/#tablas-dinamicas","title":"Tablas din\u00e1micas","text":"<p>En este tipo de tablas los datos son din\u00e1micos: no se conocen por adelantado cuando se est\u00e1 dise\u00f1ando la aplicaci\u00f3n y suelen proceder de alguna fuente externa como una base de datos o un servidor.</p> <p>Vamos a ver primero c\u00f3mo crear la tabla en s\u00ed y luego el objeto que va a ocuparse de los datos que queremos mostrar en la tabla</p>"},{"location":"4_tablas/apuntes/#el-objeto-tabla","title":"El objeto Tabla","text":"<p>La tabla en s\u00ed es una componente m\u00e1s de interfaz de usuario, como un bot\u00f3n, un slider,\u2026 Para crear una tabla, arrastramos un table view desde la librer\u00eda de componentes de la parte inferior derecha de Xcode</p> <p></p> <p>Cuidado: no us\u00e9is para este caso un table view controller sino un table view. El primero incluye no solo la tabla en s\u00ed sino tambi\u00e9n un controller, y la tabla ocupa todo el tama\u00f1o de la pantalla y no se puede cambiar de tama\u00f1o.</p> <p>Una vez creada la tabla, nos vamos al attributes inspector (icono , en la parte superior derecha de Xcode) y hacemos que el  <code>Content</code> sea <code>Dynamic prototypes</code> y el n\u00famero de <code>Prototype cells</code> al menos 1.</p> <p></p> <p>Veremos que en la tabla aparece una \u201csecci\u00f3n\u201d titulada <code>Prototype cells</code>. En esta aparecen los prototypes o plantillas en las que se basar\u00e1n las celdas de nuestra tabla. En   muchas tablas todas las celdas son iguales y por eso nos basta con un prototipo, pero podemos crear los necesarios.</p> <p>Para editar gr\u00e1ficamente el prototipo basta con seleccionarlo con el rat\u00f3n y editarlo cambiando sus atributos con el attributes inspector. El m\u00e1s importante es el <code>Style</code>. Podemos usar uno propio (<code>Custom</code>) o uno de los predefinidos </p> <p></p> <p>Para cada estilo tenemos una serie de elementos con los que podemos \u201cjugar\u201d: un t\u00edtulo, una imagen, en algunos casos un texto adicional\u2026. En general, como queremos que el contenido concreto de la celda sea distinto para cada una, lo que haremos ser\u00e1 fijarlos por c\u00f3digo. Aqu\u00ed solo elegimos el aspecto general y si ciertos elementos estar\u00e1n o no presentes. Por ejemplo en el estilo <code>basic</code> la celda solo contiene un texto, mientras que en el <code>detail</code> contiene uno m\u00e1s grande y otro m\u00e1s peque\u00f1o.</p> <p>Otro atributo importante es el <code>reuse identifier</code>, donde escribiremos un identificador inventado por nosotros para este prototipo. Cuando hablemos del datasource veremos d\u00f3nde referenciar este identificador en nuestro c\u00f3digo.</p>"},{"location":"4_tablas/apuntes/#la-fuente-de-datos-o-datasource","title":"La fuente de datos o datasource","text":"<p>En iOS se usa el patr\u00f3n delegaci\u00f3n para delegar en otro objeto distinto a la propia tabla la responsabilidad de devolver los datos cuando es necesario pintarlos en pantalla. Este delegado se denomina en iOS datasource. Cuando iOS necesite pintar una celda le pedir\u00e1 al datasource que se la devuelva rellenada con  sus contenidos.</p> <p>El datasource puede ser cualquier objeto con tal de que implemente el protocol <code>UITableViewDataSource</code>. En los ejemplos m\u00e1s sencillos habitualmente es el controller de la pantalla en la que est\u00e1 la tabla, aunque este enfoque suele llevar a que acabe habiendo demasiado c\u00f3digo en el controller. Por ello nosotros vamos a usar otra clase adicional</p>"},{"location":"4_tablas/apuntes/#implementar-el-datasource","title":"Implementar el datasource","text":"<p>Como hemos dicho, nuestro objeto debe implementar el protocolo <code>UITableViewDataSource</code>. Este protocolo tiene dos m\u00e9todos obligatorios:</p> <ul> <li>Un m\u00e9todo que dado un n\u00famero de secci\u00f3n nos devuelva cu\u00e1ntas filas hay en esa secci\u00f3n.</li> <li>Un m\u00e9todo que dado un n\u00famero de fila nos devuelva una <code>UITableViewCell</code>, que es un objeto de interfaz de usuario que representa una celda. Dicho objeto contiene b\u00e1sicamente el texto a mostrar en la celda, m\u00e1s alguna informaci\u00f3n adicional.</li> </ul> <p>Como vemos, son dos tareas que puede y debe hacer el objeto que controle los datos a mostrar, otro objeto no tendr\u00eda esta informaci\u00f3n.</p> <p>Antes de empezar a implementar los m\u00e9todos tendremos que indicar que nuestra clase implementa el protocolo <code>UITableViewDataSource</code>. Un requisito adicional, \u201cfruto\u201d de la \u201cera\u201d de Objective-C  es que el datasource debe heredar de la clase Obj-C <code>NSObject</code>, definida en el framework <code>Foundation</code>, as\u00ed que el esqueleto inicial de nuestra clase ser\u00eda algo como:</p> <pre><code>class MiDataSource : NSObject, UITableViewDataSource {\n  //Definici\u00f3n de la clase\n}\n</code></pre> <p>Si usamos un view controller como datasource, como es habitual en la mayor\u00eda de ejemplos que ver\u00e1s en libros y en tutoriales en la web, no ser\u00e1 necesario especificar la herencia de <code>NSObject</code> porque los controller ya heredan por defecto de esta clase.</p> <p>Vamos a hacer un ejemplo sencillo en el que cada celda simplemente muestra el n\u00famero de fila en que est\u00e1, y tenemos 1000 celdas. En un ejemplo algo m\u00e1s realista, los datos estar\u00edan almacenados en una BD, o bien en un array en memoria.</p> <p>El m\u00e9todo que devuelve el n\u00famero de celdas para una secci\u00f3n debe tener la signatura <code>tableView(_:, numberOfRowsInSection:)</code>. Aqu\u00ed tenemos la implementaci\u00f3n para nuestro ejemplo sencillo, que devolver\u00e1 simplemente 1000. En una BD tendr\u00edamos que devolver el n\u00famero de registros, o en un array su propiedad <code>count</code></p> <pre><code>func tableView(_ tableView: UITableView,\n               numberOfRowsInSection section: Int) -&gt; Int {\n     return 1000\n}\n</code></pre> <p>El m\u00e9todo que devuelve una celda dada una fila debe tener la signatura <code>tableView(_:, cellForRowAt:)</code>, y es algo m\u00e1s complicado que el anterior. Vamos a ver primero una implementaci\u00f3n \u201cingenua\u201d, que simplemente crea la <code>UITableViewCell</code>, la rellena de contenido y la devuelve. En un momento veremos que este c\u00f3digo es muy ineficiente y no deber\u00edamos usarlo tal cual en una aplicaci\u00f3n real. Pero por el momento nos sirve para discutir qu\u00e9 significan los par\u00e1metros y c\u00f3mo construir un objeto celda.</p> <pre><code>func tableView(_ tableView: UITableView, \n              cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n    //instanciamos una nueva celda\n    let celda = UITableViewCell(style: .default, reuseIdentifier: \"\")\n    //la rellenamos de contenido\n    celda.textLabel?.text = \"Celda n\u00famero \\(indexPath.row)\"\n    return celda\n}\n</code></pre> <p>Algunas consideraciones sobre el c\u00f3digo anterior: - Un <code>IndexPath</code> es un struct que almacena informaci\u00f3n sobre la posici\u00f3n de una celda. Contiene b\u00e1sicamente el n\u00famero de fila (propiedad <code>row</code>) y el n\u00famero de secci\u00f3n (propiedad <code>section</code>. Ignoramos este \u00faltimo ya que nuestro ejemplo tiene una \u00fanica secci\u00f3n. - Al inicializador de <code>UITableViewCell</code> le pasamos el estilo de la celda (en principio de entre los predefinidos) y luego el <code>reuseIdentifier</code>, que luego veremos qu\u00e9 es. De momento pasamos la cadena vac\u00eda.</p> <p>Lo que acabamos de hacer, crear un nuevo <code>UITableViewCell</code>  por cada fila es muy ineficiente dado que una tabla puede tener cientos o miles de ellas. Por eso se suele usar un truco ingenioso: se crea un peque\u00f1o n\u00famero de celdas (las que se ven simult\u00e1neamente en pantalla) y luego se reutilizan conforme se va haciendo scroll por la tabla, rellen\u00e1ndolas con los nuevos datos. iOS ofrece soporte para esta reutilizaci\u00f3n manteniendo un pool de celdas que podemos reutilizar para rellenar con nuevos datos.</p> <p>Podemos sacar una celda del pool con el m\u00e9todo de la vista de tabla <code>dequeueReusableCell(withIdentifier:)</code>. El identificador sirve para etiquetar el \u201ctipo\u201d de celda. En casos m\u00e1s complicados podr\u00edamos tener varios pool con distintos tipos de celda para reutilizar. En el ejemplo usaremos un \u00fanico identificador (es arbitrario y lo elige el desarrollador).</p> <p>MUY IMPORTANTE: el identificador del <code>reuseIdentifier</code> debe ser el mismo que elegimos gr\u00e1ficamente al editar el prototipo de la celda. Si no fallar\u00e1 nuestro c\u00f3digo</p> <p></p> <p>La nueva versi\u00f3n del c\u00f3digo queda as\u00ed:</p> <pre><code>func tableView(_ tableView: UITableView, \n               cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n    let nuevaCelda = tableView.dequeueReusableCell(withIdentifier: \"unaCelda\", \n                          for: indexPath)\n    nuevaCelda.textLabel?.text = datos[indexPath.row]\n    return nuevaCelda\n }\n</code></pre> <p>Un detalle m\u00e1s: Xcode te avisar\u00e1 de que la propiedad <code>textLabel</code> est\u00e1 deprecated y que se dejar\u00e1 de usar en futuras versiones de iOS. Aunque no est\u00e1 claro a partir de qu\u00e9 versi\u00f3n de iOS dejar\u00e1 de ser compatible, debido al amplio uso de esta forma de trabajar con celdas de tabla, en la actualidad \u00e9sta no es la forma \"sancionada\" por Apple, que en su lugar promueve el uso de Content Configurations. La idea es, en lugar de modificar directamente las propiedades de la celda, crear y modificar una configuraci\u00f3n que pudi\u00e9ramos aplicar a muchas celdas, algo como lo que sigue (aunque en nuestro caso al ser un ejemplo modificamos la configuraci\u00f3n para cada celda, deber\u00edamos guardarla aparte).</p> <pre><code>var content = cell.defaultContentConfiguration()\ncontent?.text = datos[indexPath.row]\ncontent?.textProperties.color = .blue\ncelda.contentConfiguration = content\n</code></pre>"},{"location":"4_tablas/apuntes/#conectar-la-tabla-y-el-datasource","title":"Conectar la tabla y el datasource","text":"<p>Podemos hacer la conexi\u00f3n usando dos m\u00e9todos alternativos: gr\u00e1ficamente o por c\u00f3digo. Cuando el datasource es una clase adicional es algo m\u00e1s sencillo por c\u00f3digo. Cuando es el controller la forma m\u00e1s directa es la gr\u00e1fica.</p> <p>Como en el ejemplo de la secci\u00f3n anterior hemos hecho que el datasource sea una clase adicional, vamos a ver en primer lugar c\u00f3mo se har\u00eda la conexi\u00f3n por c\u00f3digo. Basta con asignar la propiedad <code>dataSource</code> del objeto tabla a una instancia de nuestro objeto datasource. Por ejemplo podr\u00edamos hacer la asignaci\u00f3n en el <code>viewDidLoad()</code> del controller de la pantalla donde est\u00e1 la tabla:</p> <pre><code>//Este outlet lo habr\u00edamos creado gr\u00e1ficamente con Xcode\n@IBOutlet weak var miTabla: UITableView!\n//guardamos el datasource como una propiedad del controller\nvar miDS: MiDataSource!\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    self.miDS = MiDataSource()\n    //asignamos el datasource como el delegado de la tabla\n    self.miTabla.dataSource = miDS\n}\n</code></pre> <p>En el c\u00f3digo anterior puede parecer que podr\u00edamos ahorrarnos la variable <code>miDS</code> y asignar directamente el dataSource a una nueva instancia, es decir <code>self.miTabla.dataSource = MiDataSource()</code>. Pero esto no funcionar\u00e1 y la tabla aparecer\u00e1 vac\u00eda. Si consultamos la documentaci\u00f3n del API de iOS veremos que la propiedad <code>dataSource</code> es weak, lo que significa que si el objeto referenciado por ella no est\u00e1 referenciado por ninguna variable m\u00e1s, iOS considerar\u00e1 que puede liberar la memoria ocupada por \u00e9l. En consecuencia el <code>dataSource</code> se quedar\u00eda vac\u00edo y no aparecer\u00edan los datos.</p> <p>En el c\u00f3digo anterior accedemos al objeto tabla con un outlet creado previamente en Xcode de modo gr\u00e1fico, pero esto no parece tener mucho sentido si hemos dicho que \u00edbamos a establecer la conexi\u00f3n por c\u00f3digo. Si no estamos usando el outlet para alguna tarea adicional, una alternativa ser\u00eda asignar un tag fijo a la tabla (por ejemplo 100) y acceder a ella con <code>self.view.viewWithTag(tag:100)</code></p> <p>Otra alternativa a lo anterior es hacer la conexi\u00f3n con Xcode. Para conectar gr\u00e1ficamente la tabla con el datasource primero necesitamos tener una \u201crepresentaci\u00f3n gr\u00e1fica\u201d en pantalla del objeto <code>MiDataSource</code> con el que queremos conectar. Podemos arrastrar a la pantalla un <code>Object</code> de la librer\u00eda de objetos de la parte inferior derecha de Xcode. Este es como si fuera un componente m\u00e1s de la interfaz gr\u00e1fica pero no tiene representaci\u00f3n en pantalla. En lugar de arrastrarlo a la pantalla en s\u00ed como ocurre con los componentes gr\u00e1ficos convencionales, debemos arrastrarlo al \u00e1rbol de componentes que aparece a su izquierda</p> <p></p> <p>Una vez colocado aqu\u00ed, vamos a indicar que este objeto es de la clase <code>MiDataSource</code>. Para ello usamos el <code>Identity inspector</code>, y en la propiedad <code>Custom class</code> escribimos el nombre de la clase</p> <p></p> <p>Ya podemos conectar la propiedad <code>dataSource</code> de la tabla con este objeto. La propiedad la podemos ver si seleccionamos la tabla con el rat\u00f3n y vamos al <code>Connections inspector</code> (el icono  del \u00e1rea de <code>Utilities</code>). Arrastramos con el rat\u00f3n (no hace falta <code>Ctrl</code>) desde el c\u00edrculo que representa al <code>datasource</code> hasta el icono del objeto que representa a la clase <code>MiDataSource</code> </p> <p></p>"},{"location":"4_tablas/apuntes/#gestion-de-tablas","title":"Gesti\u00f3n de tablas","text":"<p>En las tablas din\u00e1micas podemos por supuesto insertar y eliminar celdas. Tambi\u00e9n podemos seleccionarlas haciendo tap sobre ellas. </p> <p>Para evitar que la propia tabla se tenga que hacer cargo de estas tareas se usa de nuevo el patr\u00f3n delegaci\u00f3n: designamos una instancia de una clase determinada que se encargar\u00e1 de procesar la inserci\u00f3n y el borrado. Esta instancia se le debe asignar a la propiedad <code>delegate</code> de la tabla, bien por c\u00f3digo o bien gr\u00e1ficamente, como hac\u00edamos en el caso del <code>dataSource</code>.</p> <p>Aunque la tarea primaria es cosa del delegate, el dataSource ser\u00e1 avisado si se va a insertar o eliminar alguna celda, para que procese los datos</p> <p>El <code>delegate</code> tendr\u00e1 que ser de una clase que implemente el protocolo <code>UITableViewDelegate</code>. Este protocolo proporciona m\u00e9todos para manejar secciones de la tabla, configurar las cabeceras y pies de cada secci\u00f3n, gestionar qu\u00e9 hacer cuando se selecciona una celda, insertar, eliminar y reordenar celdas, y algunas otras tareas.</p> <p>En casi todos los ejemplos que ver\u00e9is en libros y en la web se suele hacer que el controller act\u00fae de delegate para simplificar el c\u00f3digo y reducir el n\u00famero de clases del ejemplo, pero a cambio complicamos el c\u00f3digo del controller.</p> <p>El c\u00f3digo de una clase que act\u00fae de <code>delegate</code> de tabla debe tener el siguiente esqueleto b\u00e1sico. Al igual que en el caso del <code>dataSource</code>, la herencia de <code>NSObject</code> es a su vez \u201cherencia\u201d de la \u00e9poca de Objective-C</p> <pre><code>import Foundation\nimport UIKit\n\nclass MiDelegate: NSObject, UITableViewDelegate {\n    //definici\u00f3n de la clase\n}\n</code></pre> <p>En los siguientes apartados solo vamos a discutir c\u00f3mo implementar los m\u00e9todos del protocolo <code>UITableViewDelegate</code>, no c\u00f3mo hacer la conexi\u00f3n entre la tabla y el <code>delegate</code>, ya que la conexi\u00f3n se hace pr\u00e1cticamente igual que cuando habl\u00e1bamos del datasource, sea por c\u00f3digo o gr\u00e1ficamente.</p>"},{"location":"4_tablas/apuntes/#seleccionar-celdas","title":"Seleccionar celdas","text":"<p>Cuando el usuario selecciona una celda haciendo tap sobre ella se llama al m\u00e9todo <code>tableView(_: didSelectRowAt:) del</code> delegate. Como ejemplo vamos a ver c\u00f3mo implementar\u00edamos este m\u00e9todo de forma que cuando se seleccione una celda se ponga en ella una marca de verificaci\u00f3n, y que si ya est\u00e1 se quite. En las celdas predefinidas, esta marca (y otras similares) se controla con la propiedad <code>accessoryType</code> de la celda.</p> <pre><code>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n  if let celda = tableView.cellForRow(at: indexPath) {\n    //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos      \n    if celda.accessoryType==UITableViewCell.AccessoryType.none {\n       celda.accessoryType = .checkmark\n    }\n    else {\n       celda.accessoryType = .none\n    }\n    //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris\n    tableView.deselectRow(at: indexPath, animated: true)\n  }\n}\n</code></pre>"},{"location":"4_tablas/apuntes/#insertar-y-eliminar-filas","title":"Insertar y eliminar filas","text":"<p>iOS nos ofrece de forma autom\u00e1tica el \u201cmodo edici\u00f3n\u201d, en el que en la parte izquierda de cada celda aparece un icono indicador de las operaciones que se pueden hacer con ella. Hay dos indicadores: </p> <ul> <li> Una se\u00f1al de \"prohibido\" para poder borrar la celda (pulsando sobre la se\u00f1al y luego sobre el bot\u00f3n \u201cBorrar\u201d que aparece).</li> <li> Un s\u00edmbolo de \u2018+\u2019 que sirve para insertar una nueva celda</li> </ul> <p>Podemos activar el modo edici\u00f3n con el m\u00e9todo <code>setEditing</code> del objeto tabla:</p> <pre><code>//suponemos que \"miTabla\" es un outlet a la tabla\nself.miTabla.setEditing(true, animated:true);\n</code></pre> <p>Por defecto al activar el modo edici\u00f3n en todas las celdas aparecer\u00e1 la se\u00f1al de \u201cprohibido\u201d. Implementando en el delegate el m\u00e9todo <code>tableView(_:,editingStyleForRowAt:)</code> podemos especificar qu\u00e9 tipo de estilo de edici\u00f3n queremos para una celda determinada. El sistema nos \u201cpreguntar\u00e1\u201d el estilo de edici\u00f3n para un n\u00famero de celda y debemos devolver <code>UITableViewCellEditingStyle.delete</code>o bien <code>UITableViewCellEditingStyle.insert</code>.</p> <p>Aunque el modo edici\u00f3n es autom\u00e1tico, los iconos de \"prohibido\" o \"m\u00e1s\" no har\u00e1n nada por s\u00ed solos. El borrado efectivo de las celdas y de su contenido lo tenemos que hacer nosotros, al igual que la inserci\u00f3n. iOS avisar\u00e1 al datasource de que se est\u00e1 intentando insertar o eliminar una celda, NO al delegate . Esto es l\u00f3gico ya que los datos los gestiona el datasource.</p> <p>As\u00ed, cuando se pulse sobre el  y luego sobre \u201cdelete\u201d o sobre el , se llamar\u00e1 al m\u00e9todo del datasource llamado <code>tableView(_:, commit:, forRowAt:)</code>. En este m\u00e9todo tenemos que hacer dos cosas:</p> <ul> <li>Actualizar los datos (borrar el dato o insertar uno nuevo)</li> <li>Llamar a un m\u00e9todo del API de la tabla para que esta inserci\u00f3n o borrado se represente de manera visual (que gr\u00e1ficamente aparezca o desaparezca la celda)</li> </ul> <p>Es muy importante destacar que primero hay que actualizar los datos y luego ocuparse de la parte gr\u00e1fica. Si lo hacemos al rev\u00e9s no funcionar\u00e1 bien, ya que iOS intentar\u00e1 redibujar la tabla usando los datos \u201cantiguos\u201d.</p> <p>Simplemente implementando el siguiente m\u00e9todo (aunque estuviera vac\u00edo) activaremos el swipe to delete, lo que quiere decir que por ejemplo al pulsar sobre el \"prohibido\" aparecer\u00e1 desliz\u00e1ndose desde la derecha de la celda un b\u00f3t\u00f3n \"delete\". No obstante este bot\u00f3n no va a hacer nada salvo que implementemos el borrado como aqu\u00ed se muestra:</p> <pre><code>func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {\n        if editingStyle==UITableViewCell.EditingStyle.delete {\n            self.datos.remove(at: indexPath.row)\n            tableView.deleteRows(at: [indexPath], with: UITableView.RowAnimation.fade)\n        }\n        else if editingStyle==UITableViewCell.EditingStyle.insert {\n            self.datos.insert(\"Nueva celda\", at: indexPath.row)\n            tableView.insertRows(at: [indexPath], with: UITableView.RowAnimation.bottom)\n        }\n    }\n</code></pre> <p>N\u00f3tese que los m\u00e9todos <code>insertRows</code> y <code>deleteRows</code> permiten insertar o borrar varias celdas a la vez y por ello como primer par\u00e1metro requieren un array de <code>indexPath</code>, y no un <code>indexPath</code> directamente. Si insertamos/borramos una \u00fanica celda ser\u00e1 un array de un \u00fanico componente.</p> <p>Esto que hemos visto se aplica a cuando la inserci\u00f3n o eliminaci\u00f3n las dispara el propio iOS pulsando en los botones del sistema. Pero tambi\u00e9n podemos disparar nosotros manualmente la inserci\u00f3n o eliminaci\u00f3n. Por ejemplo veamos c\u00f3mo se insertar\u00eda una nueva celda \u201cmanualmente\u201d al principio de la tabla. </p> <pre><code>//primero hay que actualizar los datos\nself.datos.insert(\"Nueva celda\", at:0)\n//y ahora visualmente insertar la celda\nlet indexPath = IndexPath(row:0,section:0)\n//suponemos que tenemos accesible la tabla, la necesitamos\ntabla.insertRows(at: [indexPath], \n                     with: UITableViewRowAnimation.fade)\n</code></pre>"},{"location":"4_tablas/apuntes/#diffable-data-sources","title":"Diffable Data Sources","text":"<p>Como hemos visto, el encargado de gestionar los datos mostrados en la tabla y sincronizar el estado de la propia interfaz es el propio programador. Pero esto da lugar a c\u00f3digo tedioso y propenso a errores. Ser\u00eda mucho mejor que iOS se encargara de seguir autom\u00e1ticamente la pista de los datos si estos cambian y actualizara visualmente la tabla de manera autom\u00e1tica. Esto lo podemos conseguir con los Diffable Data Sources, que se introdujeron en iOS13.</p> <p>Para crear un Diffable Data Source necesitamos especificar:</p> <ul> <li>El tipo de los items de la tabla. Adem\u00e1s este debe ser conforme al protocolo hashable (lo son autom\u00e1ticamente tipos b\u00e1sicos como String o Int, luego veremos qu\u00e9 implicaciones tiene esto)</li> <li>El tipo de las secciones de la tabla. En iOS por defecto son simplemente enteros, pero aqu\u00ed podemos especificar el tipo que queramos (siempre que como antes, sea hashable)</li> <li>La <code>UITableView</code> asociada al data source</li> <li>El c\u00f3digo que crea cada celda (lo que hac\u00edamos en el m\u00e9todo <code>tableView(_:, cellForRowAt:)</code>)</li> </ul> <p>Por ejemplo, supongamos para simplificar que los identificadores de secci\u00f3n van a ser enteros y los datos de la tabla <code>String</code>s. Podr\u00edamos crear nuestro diffable data source como sigue:</p> <pre><code>class MiDiffableDS : UITableViewDiffableDataSource&lt;Int, String&gt; {\n    init(tabla : UITableView) {\n        super.init(\n            tableView: tabla,\n            cellProvider: {  tableView, indexPath, item in\n                let cell = tableView.dequeueReusableCell(\n                    withIdentifier: \"miCelda\",\n                    for: indexPath\n                )\n\n                cell.textLabel?.text = item\n                return cell\n            })\n    }\n}\n</code></pre> <p>cosas interesantes:</p> <ul> <li>Nuestra clase hereda de  <code>UITableViewDiffableDataSource</code>, que es la clase base de los diffable data sources en iOS. </li> <li>Esta clase es gen\u00e9rica y est\u00e1 parametrizada por <code>&lt;TipoDeSeccion, TipoDeItem&gt;</code>, en nuestro caso <code>Int</code> y <code>String</code> como ya hemos dicho</li> <li>En el constructor de la clase base hay que pasar como par\u00e1metros:<ul> <li>La <code>UITableView</code> asociada. Aqu\u00ed es donde se hace la conexi\u00f3n entre datasource y tabla. En nuestro ejemplo este par\u00e1metro se lo pasamos al inicializador de la clase derivada, as\u00ed se lo podemos pasar desde el controller que es el \"due\u00f1o\" de la tabla.</li> <li>en <code>cellProvider</code> pasamos una clausura que b\u00e1sicamente es la implementaci\u00f3n que hac\u00edamos antes del <code>tableView(_:, cellForRowAt:)</code> (obtener la celda reutilizada, rellenarla de datos y devolverla)</li> </ul> </li> </ul> <p>Si no queremos \"molestarnos\" en definir una clase propia tambi\u00e9n podemos crear directamente una instancia de la clase base y luego asign\u00e1rsela a la tabla como su datasouce:</p> <pre><code>//suponiendo que el UITableView se llame \"tabla\"\n//Este c\u00f3digo podr\u00eda estar en el viewDidLoad del controller\nlet miDataSource = UITableViewDiffableDataSource&lt;Int, String&gt;(\n  tableview: miTabla,\n  //cellProvider igual que antes\n  ...\n)\nmiTabla.dataSource = miDataSource\n</code></pre> <p>De momento no hemos sacado ning\u00fan beneficio apreciable de usar un diffable data source. Los beneficios empiezan cuando queremos modificar los datos asociados a la tabla. La idea es que el conjunto de datos se representa con lo que se llama un snapshot, que podemos modificar (crear de nuevo, a\u00f1adir datos, borrar datos,...). Una vez modificado el snapshot llamamos al m\u00e9todo <code>apply</code> sobre el datasource para que visualmente se apliquen los cambios correspondientes.</p> <p>Por ejemplo podr\u00edamos inicializar los datos como sigue:</p> <pre><code>var snapshot = NSDiffableDataSourceSnapshot&lt;Int, String&gt;()\nsnapshot.appendSections([0])\nsnapshot.appendItems([\"uno\", \"dos\", \"tres\"], toSection: 0)\nds.apply(snapshot, animatingDifferences: false)\n</code></pre> <p>Como vemos en este ejemplo, podemos a\u00f1adir secciones a la tabla e items dentro de cada secci\u00f3n. Al llamar a <code>apply</code> se actualizar\u00e1 la tabla, con una animaci\u00f3n si el par\u00e1metro <code>animatingDifferences</code> es <code>true</code>.</p> <p>En el snapshot tenemos m\u00e9todos para insertar, modificar o eliminar items, por ejemplo:</p> <pre><code>//aqu\u00ed ds ser\u00eda el diffable data source que hemos creado\nvar snapshot = ds.snapshot()\nsnapshot.deleteItems([\"uno\"])\nds.apply(snapshot)\n</code></pre> <p>Los items se borran especificando un <code>id</code>, que en el caso de un tipo simple como <code>String</code> se corresponde con el propio contenido. La tabla se actualizar\u00e1 autom\u00e1ticamente tras el <code>apply</code>.</p> <p>Para implementar el borrado de celdas haciendo tap sobre ellas en el modo edici\u00f3n tendremos que sobreescribir el m\u00e9todo <code>tableView(_,commit:,atIndexPath:)</code> en nuestro diffable data source:</p> <pre><code>override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {\n        var snapshot = self.snapshot()\n        if let item = itemIdentifier(for: indexPath) {\n            snapshot.deleteItems([item])\n            apply(snapshot)\n        }\n    }\n</code></pre> <p>La diferencia es que ahora no tenemos que actualizar visualmente la tabla, solo modificar el snapshot y aplicarlo al datasource. Para saber qu\u00e9 item est\u00e1 en la posici\u00f3n <code>indexPath</code> usamos el m\u00e9todo <code>itemIdentifier</code>.</p>"},{"location":"4_tablas/ejercicios/","title":"Ejercicios de tablas (2,5 puntos)","text":"<p>Vamos a crear una peque\u00f1a aplicaci\u00f3n en la que se muestre una tabla con una lista de datos y se puedan insertar y eliminar filas</p>"},{"location":"4_tablas/ejercicios/#crear-la-interfaz-05-puntos","title":"Crear la interfaz (0,5 puntos)","text":"<p>Crea otra pantalla, al estilo de la que aparece en la figura. Tiene que tener los siguientes componentes:</p> <ul> <li>Un text field</li> <li>Un button con el texto \"Insertar\"</li> <li>Un table view</li> </ul> <p>En el panel derecho de Xcode, selecciona lad propiedades adecuadas para que la tabla sea din\u00e1mica con un solo prototipo.</p> <p>Importante: no te olvides de darle un identificador al prototipo, o <code>cell identifier</code>.</p> <p>.</p> <p>En cuanto al layout:</p> <ul> <li>El campo de texto debe aparecer junto al bot\u00f3n en un stack view horizontal. El stack view debe aparecer a una distancia de 20 puntos de la parte superior de la pantalla y tambi\u00e9n de 20 puntos de los bordes izquierdo y derecho</li> <li>La parte superior de la tabla debe estar a una distancia de 20 puntos de la parte inferior del stack view y los otros tres bordes deben estar a 20 puntos de los bordes de la safe area.</li> </ul>"},{"location":"4_tablas/ejercicios/#mostrar-datos-en-la-tabla-1-punto","title":"Mostrar datos en la tabla (1 punto)","text":"<ul> <li>Crea una clase Swift llamada <code>DSTabla</code> que va a hacer de datasource de la tabla seleccion\u00e1ndola. Recuerda que el <code>DSTabla</code> debe heredar de <code>NSObject</code>e implementar el protocolo <code>UITableViewDataSource</code></li> <li>Conecta el <code>DSTabla</code> con la propiedad <code>dataSource</code> de la tabla</li> <li>El <code>DSTabla</code> va a almacenar los datos en una propiedad <code>lista</code> de tipo array de <code>String</code> (puedes usar los nombres que aparecen en el ejemplo u otros datos cualesquiera, es indiferente) </li> </ul> <pre><code>//en la clase DSTabla, definimos e inicializamos la propiedad\nvar lista = [\"Daenerys Targaryen\", \"Jon Nieve\", \"Cersei Lannister\", \"Eddard Stark\"]\n</code></pre> <ul> <li>Ahora tendr\u00e1s que implementar t\u00fa de manera adecuada los m\u00e9todos:<ul> <li><code>tableView(_:, numberOfRowsInSection:)</code> recuerda que debe devolver el n\u00famero de filas de la tabla</li> <li><code>tableView(_:, cellForRowAt:)</code>: recuerda que debe devolver la celda para una fila determinada</li> </ul> </li> </ul> <p>De nuevo importante: en el m\u00e9todo <code>dequeReusableCell</code> que necesitas llamar dentro del <code>cellForRowAt</code>, no te olvides de usar el mismo <code>cell identifier</code> que le has puesto antes al prototipo. </p>"},{"location":"4_tablas/ejercicios/#insertar-filas-05-puntos","title":"Insertar filas (0,5 puntos)","text":"<p>Haz que al pulsar sobre el bot\u00f3n insertar se a\u00f1ada el texto a la lista de datos en la \u00faltima posici\u00f3n (m\u00e9todo <code>append</code> del array) y luego a\u00f1ada visualmente la fila en la tabla (recuerda que es <code>insertRows</code> del <code>UITableView</code>).</p> <p>Un par\u00e1metro del <code>insertRows</code> es el <code>IndexPath</code> de la celda. Puedes crear uno con el constructor <code>IndexPath(row:, section:)</code>, pas\u00e1ndole el n\u00famero de fila y secci\u00f3n. En nuestra tabla solo hay una secci\u00f3n, as\u00ed que ser\u00eda la 0.</p> <p>Ten en cuenta que no necesitas el m\u00e9todo <code>tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath)</code> ya que este lo llama iOS cuando pulsas en los iconos de eliminar o a\u00f1adir celda, pero ahora lo est\u00e1s haciendo con un bot\u00f3n propio. Solo necesitas insertar el dato en el array y la celda con <code>insertRows</code>.</p>"},{"location":"4_tablas/ejercicios/#delegate-05-puntos","title":"Delegate (0,5 puntos)","text":"<p>Vamos a hacer que se puedan \"marcar\" filas de la tabla. Para ello necesitas alg\u00fan objeto que act\u00fae de delegate. Crea para ello una clase <code>DelegateTabla</code> </p> <ul> <li>Haz que esta clase herede de <code>NSObject</code> e implemente el protocolo <code>UITableViewDelegate</code></li> <li>Implementa en esta clase un m\u00e9todo similar al que hemos visto en clase que marca o desmarca una fila poni\u00e9ndole un \"checkmark\", pero aqu\u00ed cambiando el texto a color rojo (propiedad <code>textColor</code> a <code>UIColor.red</code>) y si est\u00e1 en rojo pasando a negro.</li> </ul> <p>Ahora vamos a conectar el delegate con la tabla gr\u00e1ficamente, en vez de por c\u00f3digo, as\u00ed practicamos esta manera de hacerlo. Para ello:</p> <ol> <li>Arrastrar un componente <code>Object</code> al \u00e1rbol de componentes de la vista del storyboard con la pantalla del dispositivo (al \u00e1rbol que aparece a la izquierda, no a la pantalla en s\u00ed).</li> <li>Seleccionar el componente <code>Object</code>, y en el <code>Identity inspector</code> (cuarto icono del panel derecho de Xcode), escribir el nombre de la clase <code>DelegateTabla</code> en <code>Custom Class</code>.</li> <li>Conectar tabla y delegate: seleccionamos la tabla con el rat\u00f3n y vamos al <code>Connections inspector</code> (el \u00faltimo icono del panel derecho de Xcode). Arrastramos con el rat\u00f3n (no hace falta <code>Ctrl</code>) desde el c\u00edrculo que representa al <code>delegate</code> hasta el icono del objeto que representa a la clase <code>TablaDelegate</code></li> </ol> <p>Una vez hecho esto, comprueba que funciona correctamente.</p>"},{"location":"5_contenedores/apuntes/","title":"Controladores contenedores","text":"<p>A diferencia de los otros tipos de controllers que hemos visto, los controladores contenedores no muestran directamente el contenido \u201cprincipal\u201d de la aplicaci\u00f3n. El papel de estos controladores es, como su propio nombre indica,  el de servir de contenedores a los controladores que muestran el contenido y permitir la nanegaci\u00f3n sencilla entre ellos.</p> <p>En esta parte b\u00e1sica de la asignatura vamos a ver los dos controladores contenedores m\u00e1s t\u00edpicos: el tab bar y el navigation. Los dos nos sirven para organizar la app en diferentes pantallas, con la diferencia de que el navigation controller se usa cuando la navegaci\u00f3n es jer\u00e1rquica/secuencial (por ejemplo, un par de vistas maestro/detalle, o un asistente con varios pasos) y el tab bar cuando queremos dividir nuestra app en distintos \"apartados\" pero no hay una relaci\u00f3n jer\u00e1rquica entre ellos.</p>"},{"location":"5_contenedores/apuntes/#tab-bar-controllers","title":"Tab bar controllers","text":"<p>Permiten dise\u00f1ar la t\u00edpica aplicaci\u00f3n dividida por \u201capartados\u201d o \u201ctabs\u201d. Por ejemplo lo podemos ver en la aplicaci\u00f3n de \u201csalud\u201d de iOS (entre much\u00edsimas otras)</p> <p></p> <p>Lo que tenemos es un controlador de tipo \u201ctab bar\u201d que gestiona la barra inferior y la navegaci\u00f3n entre pantallas cuando pulsamos cada uno de sus iconos, pero el contenido de las pantallas lo gestionan los otros controladores. </p>"},{"location":"5_contenedores/apuntes/#formas-de-crear-un-tab-bar-controller","title":"Formas de crear un tab bar controller","text":"<p>Podemos arrastrar un tab bar controller al storyboard desde la object library.</p> <p></p> <p>Vemos que el nuevo tab bar controller aparece conectado a dos controladores convencionales (de la clase <code>UIViewController</code>). Autom\u00e1ticamente cuando pulsemos en cada icono, se saltar\u00e1 al controller asociado.</p> <p>Podemos a\u00f1adir pantallas a este tab bar controller sin m\u00e1s que crearlas en el storyboard y luego conectarlas. Hacemos <code>Ctrl+arrastrar</code> desde el tab bar controller hasta la pantalla a conectar y en el men\u00fa contextual elegimos el tipo de segue llamado <code>view controllers</code> (en el apartado <code>relationship segue</code>).</p> <p>Otra forma de crear un tab bar controller relacionado con una pantalla que ya tengamos creada es seleccionar la misma y en el men\u00fa de <code>Editor</code> elegir <code>Embed in &gt; Tab bar controller</code>. Aparecer\u00e1 un tab bar controller con un \u00fanico icono en la barra inferior, y ya conectado a la pantalla actual. </p>"},{"location":"5_contenedores/apuntes/#personalizar-la-barra-inferior","title":"Personalizar la barra inferior","text":"<p>Desde Xcode podemos cambiar algunas propiedades b\u00e1sicas de los iconos de la barra inferior en el <code>attribute inspector</code>, como el icono, el t\u00edtulo, la posici\u00f3n del t\u00edtulo con respecto al icono, si queremos que aparezca un badge, etc.</p> <p>El interfaz nos permite especificar las propiedades del <code>UITabBarItem</code> y <code>UIBarItem</code>como si fueran objetos separados. En realidad es el mismo pero las propiedades aparecen separadas ya que la segunda clase es la superclase de la primera</p> <p>En el apartado <code>Tab bar item</code>, si elegimos uno de los iconos del sistema no podremos cambiar el t\u00edtulo ya que Apple considera que lo contrario podr\u00eda inducir a confusi\u00f3n al usuario.</p> <p>En el \u00faltimo apartado de los apuntes se habla algo m\u00e1s sobre el formato de los iconos que podemos a\u00f1adir a una tab bar</p>"},{"location":"5_contenedores/apuntes/#navigation-controllers","title":"Navigation controllers","text":"<p>Los navigation controller sirven para crear estructuras de navegaci\u00f3n jer\u00e1rquica en las que tenemos pantallas y \u201csubpantallas\u201d. Estando en una de ellas podemos volver atr\u00e1s una a una. El navigation controller se encargar\u00e1 de que se vaya cambiando autom\u00e1ticamente al controlador apropiado (el de la pantalla actual).</p> <p>N\u00f3tese que cuando estamos navegando de este modo estamos usando una pila de controladores, en el sentido que tiene este t\u00e9rmino en estructuras de datos, ya que conforme vamos profundizando en la jerarqu\u00eda se van apilando los controladores, y cuando volvemos atr\u00e1s quitamos el de la parte de arriba de la pila.</p>"},{"location":"5_contenedores/apuntes/#crear-un-controlador-de-navegacion","title":"Crear un controlador de navegaci\u00f3n","text":"<p>Hay dos formas de crear gr\u00e1ficamente un controlador de navegaci\u00f3n:</p> <p>1) Seleccionamos un controller en el storyboard y elegimos la opci\u00f3n de men\u00fa de <code>Editor &gt; Embed in &gt; Navigation controller</code>. Se crear\u00e1 un controlador de navegaci\u00f3n que tiene como controlador de contenido asociado al que hab\u00edamos seleccionado.</p> <p>N\u00f3tese que como en el caso de los tab bar controller en el de navegaci\u00f3n la pantalla est\u00e1 en gris indicando que el contenido no es responsabilidad de este controlador. En el controlador de contenido asociado podemos ver que la parte superior aparece en gris, indicando que esta es la barra de navegaci\u00f3n que gestionar\u00e1 el controlador de navegaci\u00f3n.</p> <p>2) Podemos arrastrar un <code>Navigation controller</code> desde la librer\u00eda de objectos hasta el storyboard. Por defecto nos crear\u00e1 el controlador de navegaci\u00f3n junto con un controlador de tabla, estructura apropiada para comenzar con una vista maestro/detalle. No obstante si no queremos este segundo controlador podemos borrarlo y conectar el de navegaci\u00f3n con uno nuevo con <code>Ctrl+Arrastrar</code> entre ambos y seleccionando en el men\u00fa contextual la opci\u00f3n de <code>root view controller</code> bajo <code>relationship segue</code>. </p> <p>Las pantallas que est\u00e1n en la jerarqu\u00eda de un navigation controller tienen en la parte superior una barra de navegaci\u00f3n, que en el \u00e1rbol de la jerarqu\u00eda de vistas (Document outline) aparece como <code>Navigation item</code>. Podemos cambiar varias de sus propiedades en el inspector de propiedades, como el t\u00edtulo, una l\u00ednea adicional de t\u00edtulo (<code>prompt</code>), el t\u00edtulo del bot\u00f3n para ir atr\u00e1s (que iOS muestra autom\u00e1ticamente), y si queremos que el t\u00edtulo sea grande.</p>"},{"location":"5_contenedores/apuntes/#anadir-pantallas-a-la-jerarquia","title":"A\u00f1adir pantallas a la jerarqu\u00eda","text":"<p>Para a\u00f1adir un controlador a la jerarqu\u00eda de navegaci\u00f3n basta con <code>Ctrl+Arrastrar</code> entre el componente que disparar\u00eda el salto y el controlador de destino. En el men\u00fa contextual hay que elegir el segue adecuado (sea <code>push</code> o <code>show)</code>. Evidentemente el controlador de origen tiene que estar ya en la jerarqu\u00eda de navegaci\u00f3n para que esta operaci\u00f3n funcione.</p>"},{"location":"5_contenedores/apuntes/#personalizar-la-barra-de-navegacion","title":"Personalizar la barra de navegaci\u00f3n","text":"<p>Autom\u00e1ticamente el controlador de navegaci\u00f3n gestionar\u00e1 una barra de navegaci\u00f3n en la parte superior de la pantalla. Esta barra muestra por defecto en su parte izquierda un bot\u00f3n <code>&lt; Back</code> para ir al controlador anterior. </p> <p>La barra de navegaci\u00f3n es totalmente personalizable. Lo m\u00e1s inmediato es mostrar un t\u00edtulo para la pantalla actual cambiando la propiedad <code>title</code> del controlador. Esta propiedad en general es una simple descripci\u00f3n de la pantalla, pero en el caso de controladores de contenido que est\u00e9n incluidos en un contenedor, representa el t\u00edtulo de la barra de navegaci\u00f3n.</p> <p>El cambio de <code>title</code> podemos hacerlo bien en el interface builder de Xcode o bien por c\u00f3digo, por ejemplo en el m\u00e9todo <code>viewWillAppear</code> del controller, ya que se ejecutar\u00e1 antes de mostrar la vista. Al cambiar el t\u00edtulo del controlador tambi\u00e9n cambiar\u00e1 autom\u00e1ticamente el bot\u00f3n ``&lt; Back``` del siguiente \u201cnivel\u201d para reflejar el nuevo t\u00edtulo.</p> <p>Si el t\u00edtulo del controller es demasiado largo y no cabe en el bot\u00f3n este seguir\u00e1 con el t\u00edtulo por defecto (<code>Back</code>)</p> <p>Podemos cambiar completamente la barra de navegaci\u00f3n. Es accesible mediante la propiedad <code>navigationItem</code> del controlador, y podemos cambiar por ejemplo:</p> <ul> <li><code>backBarButtonItem</code>: el bot\u00f3n, de tipo <code>UIBarButtonItem</code>, que se utilizar\u00e1 para volver atr\u00e1s a este controlador</li> <li><code>titleView</code>: el componente con el t\u00edtulo para el controlador, cuyo texto como hemos visto podemos cambiar con la propiedad <code>title</code> del controlador.</li> <li><code>rightBarButtonItem</code>: por defecto <code>nil</code>. T\u00edpicamente se usa para a\u00f1adir un bot\u00f3n para editar el contenido de la pantalla actual, pero podemos colocar lo que queramos.</li> </ul>"},{"location":"5_contenedores/apuntes/#iconos","title":"Iconos","text":"<p>Como hemos visto le podemos poner un icono a cada secci\u00f3n de una tab bar. Como veremos, pasa lo mismo con las navigation bar. Los iconos \"cl\u00e1sicos\" para usar en estos casos en iOS son en formato png y debemos a\u00f1adirlos al proyecto, pero desde iOS13 hay un nuevo conjunto de unos 2400 iconos ya inclu\u00eddos en el sistema llamados \"SF Symbols\" y especialmente dise\u00f1ados para encajar con la fuente por defecto.</p>"},{"location":"5_contenedores/apuntes/#iconos-png","title":"Iconos PNG","text":"<p>Los iconos de este tipo son monocrom\u00e1ticos. El formato a usar es .png, del que el sistema examinar\u00e1 el canal alfa o de transparencia, tomando como forma del icono los pixels que sean opacos, pero ignorando su color.</p> <p>El tama\u00f1o recomendado para los iconos var\u00eda seg\u00fan la interfaz se muestre en modo compact (que en un iPhone corresponder\u00eda a portrait/vertical) o regular (en un iPhone ser\u00eda landscape/horizontal, y en un iPad ser\u00eda cualquier modo, ya que un iPad en vertical es mucho m\u00e1s ancho que un iPhone). Pod\u00e9is consultar m\u00e1s detalles sobre el formato y el tama\u00f1o recomendado en el apartado \"Tab bar icon size\"  de las iOS Human Interface Guidelines\u00a0 de Apple.</p>"},{"location":"5_contenedores/apuntes/#sf-symbols","title":"SF Symbols","text":"<p>Est\u00e1n disponibles desde iOS13. Presentan varias ventajas, entre ellas la de integrarse perfectamente con la fuente del sistema, ser vectoriales y por tanto escalables sin perder resoluci\u00f3n, estar ya inclu\u00eddos en iOS (no hay que a\u00f1adirlos al assets) y hpoder renderizarse en distintos modos (monocromo, niveles de color, multicolor). Para m\u00e1s informaci\u00f3n sobre estos iconos, se recomienda consultar el apartado correspondiente de las Human Interface Guidelines.</p> <p>Apple ofrece una aplicaci\u00f3n para Mac con la que se puede visualizar el cat\u00e1logo completo de s\u00edmbolos, aunque no est\u00e1n disponibles directamente en la web. Hay varios sitios de terceros que muestran la informaci\u00f3n (pod\u00e9is buscar \"sf symbols online\") pero en teor\u00eda por motivos de licencia estos sitios no pueden mostrar los iconos en s\u00ed.</p>"},{"location":"5_contenedores/ejercicios/","title":"Ejercicios","text":""},{"location":"5_contenedores/ejercicios/#ejercicio-de-contenedores-y-tablas","title":"Ejercicio de contenedores y tablas","text":"<ol> <li>Insertar tabla en view controller</li> <li>Poner 4 restricciones a los bordes de 0</li> <li>Cambiar ViewController por ListaViewController</li> <li>En el identity inspector cambiar la clase por ListaViewController</li> <li>Editor &gt; Embed in &gt; Navigation Controller</li> </ol>"},{"location":"complementario/concurrencia/","title":"Concurrencia en iOS","text":""},{"location":"complementario/concurrencia/#concurrencia-en-ios","title":"Concurrencia en iOS","text":"<p>Una app iOS por defecto se ejecuta en un \u00fanico thread, el principal, en el que corre nuestro c\u00f3digo y el que actualiza la interfaz de usuario, recibe los eventos generados por \u00e9ste, etc. En caso de realizar una operaci\u00f3n costosa en tiempo en este hilo, como por ejemplo cargar gran cantidad de datos de un servidor, se paralizar\u00eda la interfaz de usuario hasta que terminara la operaci\u00f3n.</p>"},{"location":"complementario/concurrencia/#apis-de-concurrencia-en-ios-y-swift","title":"APIs de concurrencia en iOS y Swift","text":"<p>Tanto iOS como OSX tienen varios APIs con distinto nivel de abstracci\u00f3n para trabajar con operaciones concurrentes:</p> <ul> <li>En el nivel m\u00e1s bajo estar\u00eda trabajar directamente con threads, representados por la clase del sistema <code>NSThread</code>. La mayor\u00eda de aplicaciones no necesitan la flexibilidad que nos proporciona trabajar a este nivel, o no merece la pena teniendo en cuenta lo complicado del c\u00f3digo con respecto a las otras alternativas.</li> <li>En un nivel intermedio tenemos un framework de Apple llamado grand central dispatch o GCD. Tiene un nivel de abstracci\u00f3n razonable para la mayor\u00eda de aplicaciones, de hecho en Internet pod\u00e9is encontrar multitud de tutoriales y ejemplos que lo usan (pod\u00e9is verlo por la llamada a una funci\u00f3n llamada <code>dispatch_async</code>, que pone en marcha c\u00f3digo concurrente).</li> <li>En el nivel m\u00e1s alto de abstracci\u00f3n est\u00e1n las colas de operaciones (aunque no es mucho mayor que GCD). Es el API que vamos a explicar aqu\u00ed ya que es el m\u00e1s sencillo de usar.</li> </ul> <p>Cada API usa internamente los otros de m\u00e1s bajo nivel. Es decir, GCD usa internamente threads y las colas de operaciones usan internamente GCD.</p> <p>En el 2021 se introdujo el soporte para concurrencia de forma nativa en el propio lenguaje de desarrollo usado en iOS, en Swift. Se gestiona con construcciones como <code>async/await</code> y <code>Task</code>, similares a las de otros lenguajes como C# y Javascript. Al final del tema veremos brevemente estos mecanismos y las ventajas que aportan.</p>"},{"location":"complementario/concurrencia/#colas-de-operaciones","title":"Colas de operaciones","text":"<p>En una cola de operaciones podemos a\u00f1adir trabajos concurrentes. Manejarlas a nivel b\u00e1sico es muy sencillo. Son instancias de <code>OperationQueue</code> y para a\u00f1adir un trabajo a una solo hay que llamar a <code>addOperation()</code>. Hay diversas formas de pasar el c\u00f3digo a ejecutar. La m\u00e1s c\u00f3moda es en forma de clausura. Por ejemplo:</p> <pre><code>let cola = OperationQueue();\ncola.addOperation() {\n    print(\"comienza operaci\u00f3n 1...\");\n    sleep(5)\n    print(\"...hecho 1\");\n}\ncola.addOperation() {\n    print(\"comienza operacion 2...\")\n    sleep(3)\n    print(\"...hecho 2\");\n};\n</code></pre> <p>NOTA: podemos ver el resultado del c\u00f3digo anterior a\u00f1adi\u00e9ndolo por ejemplo a una aplicaci\u00f3n iOS. Si usamos una aplicaci\u00f3n de l\u00ednea de comandos tendremos que a\u00f1adir algo al c\u00f3digo ya que si no el programa principal terminar\u00eda inmediatamente despu\u00e9s del segundo <code>addOperation</code> y no se ver\u00edan los mensajes en pantalla. Por ejemplo podemos llamar a <code>cola.waitUntilAllOperationsAreFinished()</code>  que como su propio nombre indica se espera hasta que todas las operaciones a\u00f1adidas a la cola han terminado.</p> <p>Si ejecutamos el c\u00f3digo anterior veremos que aunque el c\u00f3digo de la primera clausura comienza a ejecutarse primero, aun as\u00ed termina despu\u00e9s, es decir, ambas \"tareas\" se est\u00e1n ejecutando en paralelo y no secuencialmente. Por defecto este es el comportamiento de las colas de operaciones, aunque podemos definir dependencias entre tareas, de modo que se ejecute una solo cuando ha acabado otra determinada. Incluso podemos limitar el n\u00famero de operaciones concurrentes que se pueden ejecutar en una cola.</p>"},{"location":"complementario/concurrencia/#la-cola-de-operaciones-principal-de-una-app","title":"La cola de operaciones principal de una app","text":"<p>En aplicaciones iOS est\u00e1 predefinida lo que se llama la \"cola de operaciones principal\", que es la que ejecuta el c\u00f3digo que actualiza la interfaz de usuario. Podemos acceder a ella con <code>OperationQueue.main</code>. Esta cola de operaciones no puede ejecutar operaciones concurrentes para evitar inconsistencias, que se podr\u00edan dar si dos tareas estuvieran modificando simult\u00e1neamente el mismo elemento de la interfaz. Podemos comprobar esto imprimiendo el valor de <code>OperationQueue.main.maxConcurrentOperationCount</code>, que veremos que vale 1, es decir, no hay operaciones concurrentes en esta cola.</p> <p>Cuando necesitamos ejecutar una operaci\u00f3n especialmente costosa en tiempo no es recomendable bloquear la interfaz de usuario, por lo que se suele crear una cola de operaciones aparte de la principal y ejecutar la operaci\u00f3n en esta.  </p> <p>Un problema adicional es que normalmente esta operaci\u00f3n costosa debe actualizar la interfaz de usuario al finalizar, pero ning\u00fan hilo de ejecuci\u00f3n que no sea el principal debe actualizar la interfaz de usuario, ya que lo contrario podr\u00eda producir resultados inconsistentes. Esto lo podemos resolver accediendo a la cola de operaciones principal con <code>OperationQueue.main</code>. Por ejemplo:</p> <pre><code>let background = OperationQueue();\nbackground.addOperation() {\n    print(\"Comienzo mi duro trabajo...\")\n    sleep(4)\n    print(\"...terminado!\")\n    print(\"pero yo NO DEBO tocar la interfaz\")\n    OperationQueue.main.addOperation() {\n        print(\"Soy main. Desde aqu\u00ed s\u00ed se puede actualizar la interfaz\")\n    }\n}\n</code></pre>"},{"location":"proyecto/lista_compra/","title":"Miniproyecto: Lista de la compra (3 puntos en total)","text":"<p>Vamos a realizar una miniaplicaci\u00f3n para llevar la lista de la compra, podremos introducir productos y marcarlos cuando ya los hayamos comprado. Adem\u00e1s tendremos una pantalla con un cuadro de texto para escribir nuestras notas, cosas que debemos recordar pero no nos caben en la lista.</p> <p>La aplicaci\u00f3n ser\u00e1 funcional pero no guardar\u00e1 los datos de manera persistente. Esto lo veremos en la asignatura de Persistencia en Dispositivos M\u00f3viles.</p>"},{"location":"proyecto/lista_compra/#organizacion-inicial","title":"Organizaci\u00f3n inicial","text":"<ul> <li>Crear un nuevo proyecto, llam\u00e1ndolo <code>ListaCompra</code></li> <li>Para organizar un poco mejor el c\u00f3digo, vamos a meter en una carpeta los view controllers y renombrar el controller inicial:<ul> <li>Bot\u00f3n derecho sobre el <code>ViewController</code>, en el men\u00fa popup \"New Group from Selection\".</li> <li>Llamar <code>Controllers</code> al nuevo grupo</li> <li>Cambiar el nombre de <code>ViewController</code>por <code>ListaViewController</code>, clicando con bot\u00f3n derecho en el c\u00f3digo fuente sobre el nombre de la clase y seleccionando la opci\u00f3n de <code>Refactor &gt; Rename...</code></li> </ul> </li> </ul>"},{"location":"proyecto/lista_compra/#funcionalidad-mostrar-lista-de-la-compra-1-punto","title":"Funcionalidad: Mostrar lista de la compra (1 punto)","text":""},{"location":"proyecto/lista_compra/#crear-la-tabla-en-el-storyboard","title":"Crear la tabla en el storyboard:","text":"<ul> <li>Insertar un componente de UI de tipo table view  en <code>ListaViewController</code></li> <li>Ponerle 4 restricciones de autolayout de distancia 0 a los bordes, para que ocupe toda la pantalla del dispositivo</li> <li>Configurar la tabla como din\u00e1mica, y crear la celda prototipo: en las propiedades de la tabla  (panel derecho, inspector de propiedades)<ul> <li>Asegurarse que el <code>Content</code>es <code>Dynamic prototypes</code> (que es una tabla din\u00e1mica)</li> <li>Incrementar el n\u00famero de <code>Prototype cells</code> a 1</li> <li>Elegir como <code>style</code> <code>Plain</code> que es un estilo preconfigurado solo con un t\u00edtulo de celda, nos basta para mostrar esta lista</li> <li>Poner como <code>identifier</code> el nombre \"miCelda\"</li> </ul> </li> <li>Crear un outlet de la tabla,  llamado <code>tabla</code> en <code>ListaViewController</code></li> </ul>"},{"location":"proyecto/lista_compra/#crear-la-fuente-de-datos-de-la-tabla","title":"Crear la fuente de datos de la tabla","text":"<ul> <li>Crear un nuevo grupo (carpeta para organizar c\u00f3digo): en el panel izquierdo de Xcode, vista \"navegador\", bot\u00f3n derecho sobre la carpeta <code>ListaCompra</code> y en el men\u00fa desplegable, <code>New Group</code>. Llamarlo  <code>Lista</code></li> <li>Crear dentro de este grupo un struct <code>Item</code>, para guardar los datos de un item de la lista</li> </ul> <pre><code>struct Item {\n    var nombre : String\n    var comprado : Bool\n}\n</code></pre> <ul> <li>Crear dentro del grupo <code>Lista</code> la clase <code>ListaHelper</code>: <code>File &gt; New ... &gt; File</code> y en el asistente, elegir <code>Swift File</code>. Crear un fichero llamado <code>ListaHelper</code>, que har\u00e1 de datasource de la tabla. Queremos que aparezca la lista de cosas a comprar y que si ya est\u00e1n compradas aparezca un \"checkmark\" al lado.</li> </ul> <p>Puedes copiar el siguiente c\u00f3digo, tienes que completar el segundo m\u00e9todo:</p> <pre><code>import UIKit\n\nclass ListaHelper : NSObject, UITableViewDataSource {\n    var lista : [Item] = [\n        Item(nombre: \"pan\", comprado: true),\n        Item(nombre: \"agua\", comprado: false),\n        Item(nombre: \"tomates\", comprado: true)\n    ]\n    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n        return lista.count\n    }\n\n    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n        //TO-DO: escribir c\u00f3digo que:\n        //1. obtenga una celda reutilizada llamando a tableView.dequeueReusableCell\n        // Acordarse de usar el identificador \"miCelda\" que hemos configurado antes\n        //2. rellenar el .text de la celda con el nombre del item en la pos correspondiente del array\n        //3. si la propiedad `comprado` del item es `true`, fijar `accesoryType`de la celda a `.checkmark`. Si no, a `none`\n        //4. devolver la celda\n    }\n}\n</code></pre> <p>En <code>ListaViewController</code>crear una instancia de <code>ListaHelper</code> y hacer que sea datasource de la tabla:</p> <pre><code>//En la clase ListaViewController\n\n//Este outlet ya lo deber\u00edamos tener\n@IBOutlet weak var tabla: UITableView!\n//Declaramos e inicializamos el datasource\nvar miHelper = ListaHelper()\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view.\n    //Lo conectamos con la tabla\n    self.tabla.dataSource = miHelper\n}\n</code></pre> <p>Ejecutar el proyecto y comprobar que en pantalla aparece la lista de items</p>"},{"location":"proyecto/lista_compra/#funcionalidad-de-marcardesmarcar-items-05-puntos","title":"Funcionalidad de marcar/desmarcar items (0,5 puntos)","text":"<p>El objeto que es \"avisado\" cuando hacemos tap en una celda es el delegate de la tabla, por tanto necesitamos uno, haremos que <code>ListaHelper</code> lo sea:</p> <p>A\u00f1adir el protocolo correspondiente a la cabecera de <code>ListaHelper</code></p> <pre><code>class ListaHelper : NSObject, UITableViewDataSource, UITableViewDelegate {\n   //...\n}\n</code></pre> <p>Implementar el m\u00e9todo <code>didSelectRowAt</code> del delegate, aqu\u00ed tienes el mismo c\u00f3digo que usamos en un ejemplo de la sesi\u00f3n de tablas</p> <pre><code>func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n  if let celda = tableView.cellForRow(at: indexPath) {\n    //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos      \n    if celda.accessoryType==UITableViewCell.AccessoryType.none {\n       celda.accessoryType = .checkmark\n    }\n    else {\n       celda.accessoryType = .none\n    }\n    //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris\n    tableView.deselectRow(at: indexPath, animated: true)\n  }\n}\n</code></pre> <p>En el <code>ListaViewController</code>, hay que vincular el delegate de la tabla con la instancia de <code>ListaHelper</code></p> <pre><code>@IBOutlet weak var tabla: UITableView!\nvar miHelper = ListaHelper()\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view.\n    self.tabla.dataSource = miHelper\n    **//A\u00d1ADE ESTA LINEA**\n    **self.tabla.delegate = miHelper**\n}\n</code></pre>"},{"location":"proyecto/lista_compra/#funcionalidad-de-nuevo-item-1-punto","title":"Funcionalidad de \"nuevo item\" (1 punto)","text":"<p>Crearemos una nueva pantalla en la app con un campo de texto donde se pueda escribir el nombre del nuevo item de la lista, y un bot\u00f3n de \"guardar\"</p> <p>Desde el punto de vista de la usabilidad seguramente ser\u00eda mejor que se pudieran editar los items de la lista \"in-place\" pero as\u00ed practicamos la navegaci\u00f3n entre pantallas con el Navigation controller.</p>"},{"location":"proyecto/lista_compra/#crear-la-pantalla","title":"Crear la pantalla","text":"<p>En el storyboard, hay que crear la nueva pantalla.</p> <ol> <li>Desde el panel de componentes de usuario, arrastrar un <code>view controller</code> nuevo, que ser\u00e1 la pantalla de a\u00f1adir item</li> <li>A\u00f1adirle a este nuevo view controller<ul> <li>un cuadro de texto</li> <li>un bot\u00f3n \"guardar\"</li> </ul> </li> <li>Fijar las restricciones de autolayout que consideres necesarias para estos componentes, el bot\u00f3n de guardar debe salir debajo del campo de texto</li> </ol> <p>Todav\u00eda nos falta que se pueda navegar entre la pantalla de lista y la pantalla de nuevo \u00edtem:</p> <ol> <li>Meter la pantalla de lista dentro de un navigation controller: Seleccionar el view controller (bot\u00f3n del c\u00edrculo amarillo con el cuadrado blanco dentro, en la parte superior de la pantalla simulada del dispositivo) , luego ir al men\u00fa <code>Editor &gt; Embed in...&gt; Navigation controller</code>. Aparecer\u00e1 el navigation controller conectado autom\u00e1ticamente a la primera pantalla.</li> <li>En la pantalla de lista habr\u00e1 aparecido una barra de navegaci\u00f3n en su parte superior, seleccionarla, ir a las propiedades y poner como t\u00edtulo \"Lista de la compra\".</li> <li>Vamos a a\u00f1adir el bot\u00f3n para saltar a la siguiente pantalla:<ul> <li>Desde el panel de componentes de UI, arrastrar un <code>Bar Button Item</code> a la barra de navegaci\u00f3n de la pantalla de lista, a la parte de la derecha. En las propiedades del nuevo bot\u00f3n elegir como <code>System Item</code> el valor <code>Add</code> para que sea el t\u00edpico bot\u00f3n de \"A\u00f1adir\" por defecto (en iOS suelen aparecer simplemente con un \"+\")</li> <li>Conectar la pantalla de lista con la de nuevo item con ctrl+arrastrar desde este bot\u00f3n \"+\" hasta la pantalla de nuevo item. En el men\u00fa popup elegir como tipo de segue \"show\"</li> <li>Si probamos la app se podr\u00e1 navegar entre las dos pantallas, y volver a la primera desde la segunda gracias al bot\u00f3n con el bot\u00f3n <code>&lt; Lista de la compra</code> que aparecer\u00e1 autom\u00e1ticamente en la barra de navegaci\u00f3n.</li> </ul> </li> </ol>"},{"location":"proyecto/lista_compra/#crear-el-controller-de-la-nueva-pantalla","title":"Crear el controller de la nueva pantalla","text":"<p>Una vez arreglada la navegaci\u00f3n, nos falta implementar la funcionalidad de la segunda pantalla. Primero tenemos que crear su controller:</p> <ul> <li>Crear una clase <code>NuevoItemViewController:</code><ul> <li>Bot\u00f3n derecho sobre la carpeta <code>Controllers</code>, seleccionar <code>New File...</code> y en el asistente elegir la plantilla <code>Cocoa Touch Class</code>, viene mejor para crear view controllers.</li> <li>En la segunda pantalla del asistente, poner el nombre de la nueva clase (<code>NuevoItemViewController</code>) y especificar que debe ser una subclase de <code>UIViewController</code></li> </ul> </li> <li>Vincular la clase con la pantalla en el storyboard<ul> <li>En el storyboard seleccionar la segunda pantalla y en el panel de la derecha ir al \"identity inspector\" (4\u00ba icono) y poner como <code>Class</code> la clase creada, <code>NuevoItemViewController</code></li> </ul> </li> </ul>"},{"location":"proyecto/lista_compra/#implementar-la-funcionalidad-del-boton-guardar","title":"Implementar la funcionalidad del bot\u00f3n \"guardar\"","text":"<p>En el <code>NuevoItemViewController</code> creamos:</p> <ul> <li>un outlet para el campo de texto</li> <li>una propiedad <code>nombre</code> de tipo String para guardar el mismo dato, ya que desde la pantalla inicial no podemos acceder al campo de texto de la segunda.</li> </ul> <p>Queremos que cuando se pulse \"guardar\" se vuelva atr\u00e1s a la primera pantalla y adem\u00e1s se haga una copia del contenido del campo de texto en la propiedad <code>nombre</code>.</p> <p>Para volver atr\u00e1s:</p> <ul> <li>Crea una unwind action en <code>ListaViewController</code> para volver atr\u00e1s a esta pantalla desde la de nuevo item:  recuerda que es un m\u00e9todo que est\u00e9 marcado con <code>@IBAction</code> y como par\u00e1metros tenga solo uno de tipo <code>UIStoryboardSegue</code>.</li> </ul> <p>si escribes \"unwind\" el autocompletar de Xcode te dar\u00e1 accesso a una plantilla de c\u00f3digo para un unwind action, para que no tengas que escribirlo t\u00fa de cero</p> <ul> <li>Conecta el bot\u00f3n de guardar de la pantalla de nuevo item con la unwind action (Ctrl+Arrastrar con el icono de \"Exit\" de la parte superior de la pantalla del dispositivo). Xcode buscar\u00e1 todas las \"unwind actions\" de todos los controllers y te mostrar\u00e1 una lista (en este caso solo habr\u00e1 una, la que creaste antes).</li> </ul> <p>NOTA: s\u00ed, esta forma de trabajar es \"rara\". Parece raro que el unwind action se cree en la pantalla destino y la conexi\u00f3n se haga desde el \"exit\" de otra pantalla, pero esto nos permite especificar que queremos saltar desde cualquier pantalla a cualquier pantalla, y tambi\u00e9n desde varias pantallas ejecutar la misma \"unwind action\" (volver a una misma pantalla).</p> <p>Para copiar el dato a la propiedad \"nombre\":</p> <ul> <li>En el <code>NuevoItemViewController</code> crea un m\u00e9todo <code>prepare(for:,sender:)</code> que se disparar\u00e1 cuando volvamos atr\u00e1s por el unwind segue</li> </ul> <pre><code>override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n    //TO-DO: coger el valor del campo de texto y asign\u00e1rselo a la propiedad \"nombre\"\n}\n</code></pre> <p>Para terminar, en el m\u00e9todo del unwind del <code>ListaViewController</code> debes crear el nuevo item con el nombre especificado, para ello, este m\u00e9todo debe:</p> <ul> <li>obtener el valor de la propiedad <code>nombre</code> del <code>NuevoItemViewController</code>. Ten en cuenta que el controller lo puedes obtener de la propiedad <code>source</code> del segue que se recibe como par\u00e1metro, pero debes hacer un cast (puedes hacerlo con <code>as!</code>) a <code>NuevoItemViewController</code> para que la propiedad <code>nombre</code> sea accesible</li> <li>crear un nuevo objeto de la clase <code>Item</code> con ese nombre y el valor de <code>comprado</code> a false (si lo acabamos de a\u00f1adir no puede estar ya comprado)</li> <li>en el datasource <code>miHelper</code> tienes que a\u00f1adirle a la lista el nuevo <code>Item</code> (m\u00e9todo <code>append</code>)</li> <li>puedes recargar la tabla para que se muestre el nuevo dato: <code>self.tabla.reloadData()</code></li> </ul>"},{"location":"proyecto/lista_compra/#crear-la-pantalla-de-notas-y-la-navegacion-hasta-ella-05-puntos","title":"Crear la pantalla de notas y la navegaci\u00f3n hasta ella (0,5 puntos)","text":"<p>Para completar la app queremos tener una pantalla con un text view en el que podamos escribir un texto para apuntar algo de lo que queramos acordarnos y que no podemos apuntar en la lista porque no nos cabe. </p> <p>Haremos que se pueda elegir entre la pantalla de lista y la que llamaremos de \"notas\" mediante un tab bar.</p> <p>Selecciona en el storyboard el controller de la primera pantalla (recuerda, cuadro blanco en c\u00edrculo amarillo) y elige la opci\u00f3n de men\u00fa de <code>Editor &gt; Embed in &gt; Tab bar controller</code>. Aparecer\u00e1 un tab bar controller con la primera opci\u00f3n ya asociada a la pantalla de lista. Nos falta crear la pantalla de notas y vincularla al tab bar controller</p> <p>Crea la nueva pantalla en el storyboard, a\u00f1adi\u00e9ndole un <code>Text view</code> que ocupe toda la pantalla (a\u00f1ade las restricciones de autolayout necesarias para esto). No nos va a hacer falta crear c\u00f3digo Swift para este controller ya que en esta pantalla no hay nada de l\u00f3gica propia, solo se puede escribir en el campo de texto.</p> <p>Finalmente conecta el tab bar controller a la pantalla de notas con Ctrl-Arrastrar del rat\u00f3n y entre las opciones de conexi\u00f3n elige <code>Relationship segue - View Controllers</code>. Cambia los iconos  y sus nombres en el tab bar para que reflejen  las dos secciones de la app: \"lista\" y \"notas\". Lo m\u00e1s sencillo es que uses SF Symbols en lugar de tener que importar iconos de alguna web.</p> <p>El storyboard final de la aplicaci\u00f3n deber\u00eda quedar como el siguiente:</p> <p></p>"},{"location":"proyecto/marvel/","title":"\"Miniproyecto\": app Marvel","text":"<p>Este \"miniproyecto\" trata de hacer una peque\u00f1a aplicaci\u00f3n bas\u00e1ndose en el API de la editorial Marvel, que nos permite consultar informaci\u00f3n sobre los personajes, los comics, las series,...</p> <p></p>"},{"location":"proyecto/marvel/#pasos-iniciales","title":"Pasos iniciales","text":""},{"location":"proyecto/marvel/#registro-en-la-api-de-marvel-opcional","title":"Registro en la API de Marvel (Opcional)","text":"<p>Para poder usar la API de Marvel hacen falta claves de desarrollador. La plantilla de proyecto disponible en la web ya tiene unas claves incorporadas, que puedes usar, con lo que en principio no es necesario que te registres.</p> <p>Con esas claves se pueden hacer 3000 peticiones diarias al API, seguramente suficientes para su uso en clase, no somos tanta gente. No obstante, tambi\u00e9n puedes registrarte desde el portal de desarrolladores de Marvel para poder obtener claves propias. </p>"},{"location":"proyecto/marvel/#acceso-a-la-api","title":"Acceso a la API","text":"<p>La API de Marvel es REST, por lo que acepta peticiones HTTP y devuelve los datos en JSON. No obstante hacerlas directamente con los APIs de iOS ser\u00eda un poco engorroso, por lo que vamos a usar un par de librer\u00edas que nos faciliten no solo hacer la petici\u00f3n en s\u00ed sino sobre todo parsear el JSON. Usaremos una librer\u00eda adicional llamada Marvelous, que encapsula las llamadas al API en una serie de clases de modo que no tenemos que hacer peticiones HTTP directamente. </p> <p>Marvelous se distribuye como un \"paquete\" de la herramienta CocoaPods, que es un repositorio/sistema de gesti\u00f3n de paquetes que surgi\u00f3 antes del que ahora es oficial en Swift, el Swift Package Manager. Al tardar tanto en aparecer una herramienta oficial, otras de terceros llenaron este vac\u00edo como Cocoapods o Carthage.</p> <p>Para acelerar el trabajo en el aula ten\u00e9is disponible en moodle la plantilla de workspace ya creada con CocoaPods. Si quieres ver c\u00f3mo se ha hecho o crear tus proyectos con otras librer\u00edas de CocoaPods puedes consultar el Ap\u00e9ndice.</p>"},{"location":"proyecto/marvel/#uso-de-la-plantilla-de-proyecto","title":"Uso de la plantilla de proyecto","text":"<p>En la plantilla de workspace descargada abre el fichero Marvel.xcworkspace, que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente (NO ABRAS DIRECTAMENTE el <code>Marvel.xcodeproj</code>). Si lo has abierto correctamente, deber\u00edas ver dos proyectos, uno llamado <code>Marvel</code>, y otro llamado <code>Pods</code>. El proyecto principal es el primero, el segundo son librer\u00edas auxiliares. </p> <p>Primero hay que hacer un <code>Product &gt; Clean Build Folder</code>, y <code>Product &gt; Build</code> para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Una vez hecho esto podemos ejecutar la app, en la consola aparecer\u00e1 una lista de personajes cuyo nombre empieza por \"Spider\". Puedes mirar el c\u00f3digo del View Controller para ver c\u00f3mo se ha hecho.</p> <p>Una vez hecho el build, puedes comprobar si la conexi\u00f3n con el API funciona bien ejecutando la aplicaci\u00f3n, no ver\u00e1s nada en la pantalla del simulador pero en la consola de Xcode deber\u00eda aparecer una lista de personajes que comienzan por \"spider\". Puedes examinar el c\u00f3digo del view controller para ver c\u00f3mo se ha hecho, usamos una librer\u00eda auxiliar llamada <code>Marvelous</code> que implementa el acceso al API de forma sencilla.</p>"},{"location":"proyecto/marvel/#estructura-que-debe-tener-la-aplicacion","title":"Estructura que debe tener la aplicaci\u00f3n","text":"<p>Para que te hagas una idea de la estructura, se muestra el storyboard de la aplicaci\u00f3n ya terminada</p> <p></p> <p>En la aplicaci\u00f3n se podr\u00e1 buscar, listar y mostrar los detalles de alguno de los recursos que ofrece el API. Elige t\u00fa lo que prefieras: personajes, comics, creadores... </p> <p>Puedes comenzar embebiendo la pantalla inicial que aparece en el storyboard en un tab bar: selecci\u00f3nala y en el men\u00fa <code>Editor</code> elige <code>Embed In &gt; Tab Bar Controller</code>.</p>"},{"location":"proyecto/marvel/#vista-de-lista-2-puntos","title":"Vista de lista (2 puntos)","text":"<p>Esta debe ser una pantalla con una barra de b\u00fasqueda y una vista de tabla en la que se puede buscar y listar el recurso elegido (por ejemplo personajes). El resultado final ser\u00e1 algo como:</p> <p></p> <p>Ve a la primera (y por el momento \u00fanica) pantalla de contenido del tab bar, selecciona la barra inferior y en las propiedades <code>bar item</code> ponle un t\u00edtulo apropiado (por ejemplo \"Personajes\") y un icono relevante.</p> <p>Si no te gusta ninguno de los SF Symbols que tiens disponibles en  iOS, hay unas cuantas webs de donde puedes coger iconos \"planos\", por ejemplo https://www.iconfinder.com/iconsets/ios-7-icons o https://www.flaticon.com/uicons/interface-icons</p>"},{"location":"proyecto/marvel/#crear-la-interfaz","title":"Crear la interfaz","text":"<p>La tabla:</p> <ul> <li>Arrastra una table view a la pantalla de \"personajes\" (o \"comics\", o lo que hayas elegido)</li> <li>Selecciona la tabla y en las propiedades crea un prototipo de celda incrementando el <code>Prototype cells</code> a 1.</li> <li>Selecciona el prototipo de celda reci\u00e9n creado (el <code>table view cell</code>) y en las propiedades elige como <code>style</code> el valor <code>Basic</code>, para poder usar uno de los tipos predefinidos de celda y no tener que hacerlo t\u00fa.</li> <li>Ya que est\u00e1s, ponle un <code>identifier</code> a la celda prototipo. Recuerda que era un identificador elegido por t\u00ed que luego tienes que usar en Swift para recuperar una celda \"reciclada\".  </li> </ul> <p>La barra de b\u00fasqueda no se inserta como componente visual sino por c\u00f3digo, as\u00ed que la dejamos de momento (cuidado, hay un search bar en la biblioteca de componentes pero es para versiones de iOS anteriores a la 13).</p> <p>Nos falta fijar el autolayout. Queremos que la tabla ocupe toda el \u00e1rea de la pantalla. Para ello lo m\u00e1s sencillo es ponerle 4 restricciones de distancia 0 a los bordes.</p>"},{"location":"proyecto/marvel/#crear-el-controller","title":"Crear el controller","text":"<p>Vamos a crear un view controller para esta primera pantalla</p> <ul> <li>Crea una nueva clase de Cocoa Touch llamada <code>ListaController</code> y haz que sea una subclase de <code>UIViewController</code></li> <li>As\u00edgnale ese controller en el storyboard a la pantalla con la tabla. Recuerda que esto se hace a trav\u00e9s del <code>identity inspector</code>.</li> </ul> <p>Como dec\u00edamos, la barra de b\u00fasqueda se crea por c\u00f3digo Swift. En iOS, desde la versi\u00f3n 13 esto se controla con la clase <code>UISearchController</code>. Este utiliza el patr\u00f3n delegaci\u00f3n para gestionar los eventos de escribir en la barra, pulsar \"buscar\" en el teclado, etc. El objeto que act\u00fae como delegate del <code>UISearchController</code> debe implementar el protocolo <code>UISearchResultsUpdating</code></p> <p>Siguiendo la filosof\u00eda MVC (Monster View Controller \ud83d\ude05) para simplificar haremos que la barra de b\u00fasqueda est\u00e9 en el view controller de la pantalla actual, y \u00e9ste sea el delegate.</p> <p>Crea en <code>ListaController</code> un outlet para la tabla, lo usaremos en un momento (aqu\u00ed supondremos que lo llamas \"tabla\").</p> <p>Declara un <code>UISearchController</code> en el <code>ListaController</code> , inicial\u00edzalo y establece sus propiedades en el <code>viewDidLoad</code> (al a\u00f1adir el c\u00f3digo Xcode se \u201cquejar\u00e1\u201d\" de que el controller no es conforme a <code>UISearchResultsUpdating</code>, lo arreglaremos a continuaci\u00f3n).</p> <pre><code>//esto deber\u00eda ser una propiedad de ListaController\nvar searchController : UISearchController!\n</code></pre> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n    //..aqu\u00ed podr\u00eda haber m\u00e1s c\u00f3digo\n    self.searchController = UISearchController(searchResultsController: nil)\n    //el delegate somos nosotros (ListaController)\n    self.searchController.searchResultsUpdater = self\n    //Configuramos el search controller\n    //esto ser\u00eda true si quisi\u00e9ramos mostrar los resultados de b\u00fasqueda en un sitio distinto a la tabla\n    self.searchController.obscuresBackgroundDuringPresentation = false\n    //lo que aparece en la barra de b\u00fasqueda antes de teclear nada\n    self.searchController.searchBar.placeholder = \"Buscar texto\"\n    //A\u00f1adimos la barra de b\u00fasqueda a la tabla\n    self.searchController.searchBar.sizeToFit()\n    self.tabla.tableHeaderView = searchController.searchBar\n}\n</code></pre> <p>A\u00f1ade <code>UISearchResultsUpdating</code> a la cabecera del controller para que sea el delegate de la barra de b\u00fasqueda:</p> <pre><code>class ListaController: UIViewController, UISearchResultsUpdating {\n    ...\n}\n</code></pre> <p>Xcode</p> <p>Al a\u00f1adir el <code>UISearchResultsUpdating</code> Xcode se \"quejar\u00e1\"\" de que falta implementar el m\u00e9todo <code>updateSearchResults</code>. Puedes darle al \"fix\" del mensaje de error o copiar el c\u00f3digo que viene a continuaci\u00f3n. </p> <p>En el <code>ListaController</code> implementa el m\u00e9todo <code>updateSearchResults</code>, que se llamar\u00e1 cuando se escriba algo en la barra. Con cada pulsaci\u00f3n de tecla se llamar\u00e1 una vez al m\u00e9todo. Para probar que funciona, de momento basta que imprimas en la consola el texto escrito en la barra.</p> <pre><code>func updateSearchResults(for searchController: UISearchController) {\n    let textoBuscado = searchController.searchBar.text!\n    //recortamos caracteres en blanco\n    let textoBuscadoTrim = textoBuscado.trimmingCharacters(in: .whitespacesAndNewlines)\n    print(textoBuscadoTrim)\n}\n</code></pre> <p>Ejecuta la app y comprueba que efectivamente funciona lo hecho hasta ahora.</p> <p>Throttling de las peticiones</p> <p>Si con cada pulsaci\u00f3n de tecla lanzas una b\u00fasqueda al API va a ser todo muy lento e ineficiente. Es mejor que la lances cuando el usuario deje de teclear, dicho de otro modo, cuando hayan pasado X segundos sin escribir m\u00e1s caracteres. A esto se lo conoce como throttling. </p> <p>Puedes usar esta implementaci\u00f3n para no tener que escribirlo t\u00fa. Puedes a\u00f1adirlo al proyecto con la opci\u00f3n de men\u00fa de <code>File &gt; Add Files to Marvel...</code> seleccionando el archivo y asegur\u00e1ndote de que est\u00e1 marcada la opci\u00f3n de <code>Copy items if needed</code> (si no, incluir\u00e1 solo una referencia al archivo pero no este en s\u00ed).</p> <p>Una vez a\u00f1adida la clase <code>Throttler</code>, puedes crear una instancia de la clase en <code>ListaController</code>:</p> <pre><code>let throttler = Throttler(minimumDelay: 0.5)  //el delay est\u00e1 en segundos\n</code></pre> <p>y luego le puedes pasar a su m\u00e9todo <code>throttle</code> en una clausura el c\u00f3digo que quieras usar con throttling:</p> <pre><code>func updateSearchResults(for searchController: UISearchController) {\n    throttler.throttle {\n        let textoBuscado = searchController.searchBar.text!\n        let textoBuscadoTrim = textoBuscado.trimmingCharacters(in: .whitespacesAndNewlines)\n        print(textoBuscadoTrim)\n    }  \n}\n</code></pre> <p>Tras todo esto a\u00f1ade tu propio c\u00f3digo Swift para que cuando cambie el texto de la barra se haga la llamada a la API de Marvel. Por el momento lo m\u00e1s simple es mostrar los resultados con <code>print</code>. Puedes asign\u00e1rselos tambi\u00e9n a un array que sea una propiedad del controller, para que luego sean sencillos de mostrar en la tabla.</p>"},{"location":"proyecto/marvel/#mostrar-los-resultados-en-la-tabla","title":"Mostrar los resultados en la tabla","text":"<p>Warning</p> <p>Aqu\u00ed los pasos ya no est\u00e1n tan detallados, ve poco a poco</p> <p>Una vez verificado que funcionan las llamadas al API desde la barra de b\u00fasqeda, puedes hacer que los resultados aparezcan en la tabla. Recuerda que necesitas un datasource para ella, y que para simplificar puedes hacer que sea el <code>ListaController</code>. A grandes rasgos esto implica:</p> <ul> <li>Que, como dec\u00edamos antes, el controller debe tener acceso a los datos, por ejemplo guard\u00e1ndolos en una propiedad que sea un array de <code>RCCharacter</code>, <code>RCComic</code> o lo que sea que est\u00e1s usando.</li> <li>Que tienes que asignar el valor de la propiedad <code>datasource</code> de la tabla en el <code>ListaViewController</code> a <code>self</code> (el view controller) (o conectar gr\u00e1ficamente en el <code>connections inspector</code> el outlet <code>datasource</code> con el controller) .</li> <li>Que el <code>ListaController</code> debe implementar el protocolo <code>UITableViewDataSource</code>. Hay que poner en la cabecera que esto es as\u00ed, y adem\u00e1s implementar los correspondientes m\u00e9todos en el c\u00f3digo del controller, uno para devolver el n\u00famero de filas en la tabla y otro para devolver una celda dado su <code>indexPath</code>  (te deber\u00eda ayudar Xcode con el stub de los m\u00e9todos pero si no lo hace consulta los apuntes del tema de tablas o el ejercicio que hiciste en esa sesi\u00f3n).</li> <li>Para hacerlo m\u00e1s eficiente, no llames al API si la longitud de lo escrito en el campo de texto es menor o igual que 2 (por ejemplo, puedes probar otro l\u00edmite).</li> </ul> <p>Cada vez que se haga una b\u00fasqueda y se guarden datos en el array tendr\u00e1s que decirle a iOS que vuelva a redibujar la tabla llamando al m\u00e9todo del table view llamado <code>reloadData()</code>. Cuidado, porque al ser una actualizaci\u00f3n de la interfaz debes asegurarte de que esto lo est\u00e1s haciendo desde el thread principal, algo como:</p> <pre><code>//sustituye self.tabla por el outlet que hayas definido\n//para acceder a la tabla desde el controlador\nOperationQueue.main.addOperation() {\n    self.tabla.reloadData();\n}\n</code></pre> <p>Una vez terminado todo esto, esta pantalla deber\u00eda ser casi totalmente funcional. Solo quedar\u00eda ver los detalles de cada item al hacer tap sobre \u00e9l.</p> <p>Opcionalmente (0,25 puntos extra), puedes hacer que aparezca un spinner mientras se est\u00e1 procesando la petici\u00f3n, para que el usuario sepa que el sistema est\u00e1 esperando datos. Los spinners en iOS se denominan Activity Indicators. Tendr\u00edas que:</p> <ol> <li>Definir el activity indicator como variable miembro del <code>ListaController</code> <pre><code>var miSpinner = UIActivityIndicatorView()\n</code></pre></li> <li>Fijar sus propiedades en el <code>viewDidLoad()</code> <pre><code>//que se oculte autom\u00e1ticamente al pararse\nmiSpinner.hidesWhenStopped = true\n//lo a\u00f1adimos a la vista principal del controller actual\nself.view.addSubview(miSpinner)\n//lo centramos en la pantalla\nmiSpinner.center.x = self.view.center.x\nmiSpinner.center.y = self.view.center.y\n//nos aseguramos que est\u00e1 al frente y no tapado por la tabla\nself.view.bringSubviewToFront(self.miSpinner)\n</code></pre></li> <li>Para poner en marcha el activity indicator, llama a su m\u00e9todo <code>startAnimating()</code>, y para pararlo a <code>stopAnimating()</code>. </li> </ol>"},{"location":"proyecto/marvel/#vista-de-detalle-15-puntos","title":"Vista de detalle (1,5 puntos)","text":"<p>La nueva pantalla mostrar\u00e1 los datos de un item al hacer tap. Como una vez en los detalles queremos poder volver atr\u00e1s al listado de forma sencilla, lo mejor es usar un navigation controller:</p>"},{"location":"proyecto/marvel/#el-navigation-controller","title":"El navigation controller","text":"<p>En este apartado todav\u00eda no estamos implementando la vista de detalle, solo creando la jerarqu\u00eda de navegaci\u00f3n.</p> <ul> <li>En el storyboard, selecciona la pantalla de lista y elige la opci\u00f3n de men\u00fa <code>Editor &gt; Embed In &gt; Navigation Controller</code>. Aparecer\u00e1 un nuevo navigation controller que tiene como primer nivel de navegaci\u00f3n a la pantalla de lista de items.</li> <li>Fijate que en la parte superior de la pantalla de items habr\u00e1 aparecido un espacio reservado para el t\u00edtulo y los botones de navegaci\u00f3n. Selecciona esta  barra de t\u00edtulo y en las propiedades pon como <code>title</code> el recurso que est\u00e1s mostrando (personajes, autores, comics,...).</li> </ul> <p>La barra de b\u00fasqueda en un navigation controller deber\u00eda estar en la barra de naavegaci\u00f3n de la parte superior. Nosotros la ten\u00edamos definida en la tabla. Quita estas l\u00edneas del <code>viewDidLoad()</code> de <code>ListaController</code>:</p> <pre><code>self.searchController.searchBar.sizeToFit()\nself.tabla.tableHeaderView = searchController.searchBar\n</code></pre> <p>y pon esta nueva:</p> <pre><code>self.navigationItem.searchController = searchController\n</code></pre>"},{"location":"proyecto/marvel/#creacion-de-la-interfaz-y-conexion-con-la-pantalla-de-lista","title":"Creaci\u00f3n de la interfaz y conexi\u00f3n con la pantalla de lista","text":"<p>Esta pantalla ser\u00eda la que muestra los datos de un personaje, comic, creador,... junto a su imagen si es que la tiene.</p> <ul> <li>Arrastra un \"view controller\" al storyboard</li> <li>En la pantalla anterior, haz <code>ctrl+arrastrar</code> entre la celda prototipo y la pantalla actual. Elige el tipo de segue <code>Show</code>.</li> <li>Usa los componentes de UI que consideres necesarios para mostrar los datos del objeto (no es necesario que sean todos, solo los que quieras, para probar que funciona). Por ejemplo los personajes tienen un nombre o <code>name</code> y una <code>bio</code> (biograf\u00eda), entre otros datos (ojo porque la bio en algunos casos est\u00e1 vac\u00eda, as\u00ed que si no aparece puede ser por eso). </li> <li>La disposici\u00f3n de los elementos en pantalla es libre, pero deber\u00edas usar restricciones de autolayout para que no se descuadren demasiado si cambia la resoluci\u00f3n de pantalla.</li> <li>Tendr\u00e1s que crear un outlet paraa cada componente de UI, para poder luego modificar su contenido</li> <li>Implementa una clase <code>DetalleViewController</code> que herede de <code>UIViewController</code> y as\u00f3ciala a esta pantalla.</li> </ul>"},{"location":"proyecto/marvel/#implementacion-de-la-funcionalidad","title":"Implementaci\u00f3n de la funcionalidad","text":"<ul> <li>Define en el <code>DetalleViewController</code> una propiedad del tipo de recurso que est\u00e9s mostrando (<code>RCCharacterObject</code>, <code>RCComicsObject</code>, <code>RCCreatorObject</code>,...)</li> <li> <p>Define en <code>ListaController</code> un m\u00e9todo  <code>prepare(for:sender:)</code>, que se disparar\u00e1 al pasar de la pantalla de lista a la de detalle a trav\u00e9s del segue de la celda:     <pre><code>override func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n\n}\n</code></pre></p> </li> <li> <p>En este m\u00e9todo tienes que pasarle el objeto a mostrar a <code>DetalleViewController</code>. Para saber qu\u00e9 fila de la tabla se ha seleccionado puedes usar la propiedad del objeto tabla llamada <code>indexPathForSelectedRow</code>, que almacena el <code>indexPath</code> de la fila seleccionada. La propiedad <code>row</code> de este index path es el n\u00famero de fila.</p> </li> <li>Tendr\u00e1s que rellenar los outlets de los componentes de esta pantalla en el <code>viewDidLoad</code> del controller.</li> <li>Entre otras cosas, en esta pantalla deber\u00edas mostrar la imagen del personaje, comic, creador o lo que sea que hayas elegido. La imagen est\u00e1 en la propiedad <code>thumbnail</code>, que es el \"nombre base\", y seg\u00fan el sufijo que le pongamos tendremos la imagen en distintos tama\u00f1os (En el apartado \"Image Variants\" tienes detallados los formatos). La carga de la imagen deber\u00edas hacerla en un hilo secundario, para no paralizar la interfaz de usuario si la imagen tarda en cargarse. Aqu\u00ed tienes el c\u00f3digo casi literal (tendr\u00e1s que cambiar alguna variable por las que t\u00fa uses)</li> </ul> <pre><code>let colaBackground = OperationQueue()\ncolaBackground.addOperation {\n    //SUPONIENDO que la variable con el personaje se llama \"personaje\"\n    if let thumb = personaje.thumbnail {\n      //portrait_uncanny es 300x450px. Puedes cambiarlo por otro tama\u00f1o si prefieres\n      let url = \"\\(thumb.basePath!)/portrait_uncanny.\\(thumb.extension!)\"\n      //cambiamos la URL por https://. Necesario en iOS\n      let urlHttps = url.replacingOccurrences(of: \"http\", with: \"https\")\n        if let urlFinal = URL(string:urlHttps) {\n            do {\n               let datos = try Data(contentsOf:urlFinal)\n                if let img = UIImage(data: datos) {\n                    OperationQueue.main.addOperation {\n                        //suponiendo que el outlet de la imagen se llama \"miImagen\"\n                        self.miImagen.image = img\n                    }\n                }\n            }\n            catch {             \n            }\n        }\n    }\n}\n</code></pre> <p>Puedes consultar esta p\u00e1gina para ver el formato de las URL de las im\u00e1genes. B\u00e1sicamente se construyen con una trayectoria base seguidas de un \"modificador\" de aspecto y tama\u00f1o (<code>portrait_small</code>, <code>landscape_medium</code>, ...) y la extensi\u00f3n del archivo.</p> <p>En el c\u00f3digo anterior se obtiene la URL de la imagen y luego se cambia el <code>http:</code> por <code>https:</code>. En iOS, una app no puede hacer una petici\u00f3n a una URL web si no es <code>https:</code>. Por desgracia la API de Marvel nos devuelve las URLs como <code>http:</code>. Podemos \"salir del paso\" con este peque\u00f1o parche.</p>"},{"location":"proyecto/marvel/#vista-acerca-de-05-puntos","title":"Vista \"Acerca de\" (0,5 puntos)","text":"<p>Esta es la segunda de las pantallas del tab bar. Simplemente debe consistir en una imagen est\u00e1tica y un text view o un label con informaci\u00f3n sobre la aplicaci\u00f3n.</p> <p>Pon la imagen y el texto en un stack view vertical y a\u00f1ade estricciones de autolayout para que est\u00e9n a 40 puntos de los m\u00e1rgenes </p>"},{"location":"proyecto/marvel/#apendice-creacion-de-la-plantilla-de-proyecto-desde-cero","title":"Ap\u00e9ndice: creaci\u00f3n de la plantilla de proyecto desde cero","text":"<p>Esta secci\u00f3n est\u00e1 solo para que veas c\u00f3mo se ha creado la plantilla de proyecto, no es necesario que lo hagas si has usado la plantilla que est\u00e1 en moodle.</p> <p>Hasta Xcode 11 no hab\u00eda ning\u00fan sistema de gesti\u00f3n de dependencias de librer\u00edas de terceros para iOS incluido en el IDE. Desde Xcode 11 tenemos el Swift Package Manager, pero durante todo el tiempo que no ha existido una herramienta propia de Apple, la comunidad ha tenido que \"cubrir ese hueco\" desarrollando gestores de paquetes para iOS. Probablemente el m\u00e1s conocido seaCocoaPods que es el que vamos a usar aqu\u00ed.</p> <p>Cocoapods es a la vez un repositorio de librer\u00edas y un gestor de dependencias para instalar autom\u00e1ticamente estas librer\u00edas en nuestros proyectos. Hay muchas librer\u00edas de terceros disponibles con este sistema, puedes buscarlas desde la p\u00e1gina de CocoaPods.</p> <p>Para instalar <code>cocoapods</code>, desde la terminal hacer</p> <pre><code>#Con --pre decimos que queremos instalar la \u00faltima versi\u00f3n, aunque sea RC\nsudo gem install -n /usr/local/bin cocoapods --pre\n</code></pre> <p>Esto instala la herramienta desde un repositorio de Internet, as\u00ed que  necesitar\u00e1s conectividad...y paciencia, seg\u00fan vaya la red.</p> <p>Si todo va bien se instalar\u00e1 un comando llamado <code>pod</code>. Ejec\u00fatalo desde la terminal para comprobar que existe y no da error. </p> <p>Ahora debes seguir estos pasos:</p> <ol> <li>Crear un proyecto Xcode para la aplicaci\u00f3n. Ll\u00e1malo por ejemplo <code>Marvel</code></li> <li>Con un editor de textos cualquiera, crear un fichero llamado <code>Podfile</code> en el directorio del proyecto (el que contiene el fichero <code>.xcodeproj</code>). Este archivo debe contener la configuraci\u00f3n y las dependencias (o pods) del proyecto</li> </ol> <pre><code>#SUSTITUYE la versi\u00f3n de ios por la que quieras usar como target de tu app\nplatform :ios, '16.0'\nuse_frameworks!\n#SUSTITUYE 'Marvel' por el nombre de tu proyecto, si no se llama as\u00ed!!!\ntarget 'Marvel' do\n   pod 'Marvelous'\nend\n</code></pre> <ol> <li>Abre una terminal. Mu\u00e9vete hasta el directorio donde est\u00e1 el <code>Podfile</code> y desde \u00e9l ejecuta el comando <code>pod install</code>. Las dependencias de nuestro proyecto se bajar\u00e1n autom\u00e1ticamente y se crear\u00e1 en el directorio actual un <code>Marvel.xcworkspace</code></li> <li>A partir de ahora para trabajar en el proyecto siempre abriremos el fichero Marvel.xcworkspace, que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente (NO ABRAS DIRECTAMENTE el <code>Marvel.xcodeproj</code>).</li> <li>Veremos que en Xcode se muestra nuestro proyecto y adem\u00e1s un proyecto adicional llamado <code>Pods</code>, que contiene las dependencias. Este \u00faltimo no lo tocaremos, pero es necesario que est\u00e9 ah\u00ed para que funcione el nuestro.</li> </ol>"},{"location":"proyecto/marvel/#uso-de-marvelous","title":"Uso de <code>Marvelous</code>","text":"<p>ANTES de empezar a escribir c\u00f3digo aseg\u00farate de hacer en Xcode un <code>Product &gt; Clean Build Folder</code>, y <code>Product &gt; Build</code> para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo.</p> <p>Para poder hacer llamadas al API de Marvel necesitas un par de claves. Las puedes ver, una vez dado de alta y autentificado en Marvel, en <code>https://developer.marvel.com/account</code></p> <p>El siguiente c\u00f3digo ya est\u00e1 metido en la plantilla, si te la has bajado. Solo es necesario poner en marcha el proyecto para probar si sale en la consola la lista de personajes.</p> <p>Para probar de manera sencilla la librer\u00eda <code>Marvelous</code> puedes poner este <code>import</code> en el <code>ViewController</code></p> <pre><code>import Marvelous\n</code></pre> <p>Y ahora copiar la siguiente funci\u00f3n en el view controller, quemuestran en la consola todos los personajes cuyo nombre comienza por una determinada cadena.</p> <pre><code>func mostrarPersonajes(comienzanPor cadena : String) {\n        let marvelAPI = RCMarvelAPI()\n        //PUEDES CAMBIAR ESTO PARA PONER TUS CLAVES\n        marvelAPI.publicKey = \"a6927e7e15930110aade56ef90244f6d\"\n        marvelAPI.privateKey = \"487b621fc3c0d6f128b468ba86c99c508f24d357\"\n        let filtro = RCCharacterFilter()\n        filtro.nameStartsWith = cadena\n        marvelAPI.characters(by: filtro) {\n            resultados, info, error in\n            if let personajes = resultados as! [RCCharacterObject]? {\n                for personaje in personajes {\n                    print(personaje.name)\n                }\n                print(\"Hay \\(personajes.count) personajes\")\n            }\n        }\n}\n</code></pre> <p>Puedes llamar a la funci\u00f3n anterior desde el <code>viewDidLoad</code> del view controller</p> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n    mostrarPersonajes(comienzanPor: \"Spider\")\n}\n</code></pre>"}]}