{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prefacio \u00b6 En esta asignatura vamos a ver una introducci\u00f3n al desarrollo de interfaces para aplicaciones iOS.","title":"Prefacio"},{"location":"#prefacio","text":"En esta asignatura vamos a ver una introducci\u00f3n al desarrollo de interfaces para aplicaciones iOS.","title":"Prefacio"},{"location":"SUMMARY/","text":"Contenidos \u00b6 View controllers Funciones de los view controllers Storyboards Segues NIBs Ejercicios Vistas. Componentes de la interfaz Interacci\u00f3n con la interfaz por c\u00f3digo Propiedades de una vista Algunos componentes de interfaz de usuario Ejercicios Autolayout El por qu\u00e9 de autolayout Manejo de restricciones con Xcode M\u00e1s sobre las restricciones Formular restricciones usando c\u00f3digo Ejercicios Tablas Introducci\u00f3n Tablas est\u00e1ticas Tablas din\u00e1micas Gesti\u00f3n de tablas Ejercicios Controladores contenedores Tab bar controllers Navigation controllers Proyecto","title":"Contenidos"},{"location":"SUMMARY/#contenidos","text":"View controllers Funciones de los view controllers Storyboards Segues NIBs Ejercicios Vistas. Componentes de la interfaz Interacci\u00f3n con la interfaz por c\u00f3digo Propiedades de una vista Algunos componentes de interfaz de usuario Ejercicios Autolayout El por qu\u00e9 de autolayout Manejo de restricciones con Xcode M\u00e1s sobre las restricciones Formular restricciones usando c\u00f3digo Ejercicios Tablas Introducci\u00f3n Tablas est\u00e1ticas Tablas din\u00e1micas Gesti\u00f3n de tablas Ejercicios Controladores contenedores Tab bar controllers Navigation controllers Proyecto","title":"Contenidos"},{"location":"1_controllers/apuntes/","text":"Sesi\u00f3n 1: View Controllers \u00b6 View controllers . Funciones b\u00e1sicas \u00b6 Los view controllers son la C del MVC. Su tarea m\u00e1s importante es gestionar una jerarqu\u00eda de vistas. Cada controller tiene una vista \u201cprincipal\u201d o \u201cra\u00edz\u201d (su propiedad view ), y esa a su vez tiene subvistas que por supuesto pueden contener otras subvistas y as\u00ed sucesivamente. Hay dos tipos b\u00e1sicos de controladores: los que muestran directamente contenido ( content controllers ) y los que contienen otros contenedores ( container controllers ). Estos \u00faltimos contienen a otros controladores. Lo que hace el contenedor es redimensionar y colocar la vista principal de sus hijos, pero cada uno de ellos es responsable de mostrar su propio contenido Otras tareas de los view controllers \u00b6 Adem\u00e1s de gestionar la jerarqu\u00eda de vistas, los controladores act\u00faan como el \u201cpegamento\u201d que relaciona la vista con el modelo. El controlador es el lugar t\u00edpico para poner el c\u00f3digo que reacciona a los eventos del usuario, como por ejemplo qu\u00e9 hacer cuando se pulsa un bot\u00f3n. Es nuestra responsabilidad como desarrolladores asegurarnos de que no colocamos demasiada l\u00f3gica en el c\u00f3digo del controller . La l\u00f3gica deber\u00eda ir en el modelo, no en el controller , que deber\u00eda contener el m\u00ednimo c\u00f3digo imprescindible para comunicar vista y modelo. Por otro lado, los controllers son los responsables de adaptar las dimensiones de los componentes de la interfaz a las dimensiones reales de la pantalla. Para ello se usan varios mecanismos: autolayout , size classes y traits , que veremos a nivel introductorio en las siguientes sesiones. Ciclo de vida de un controller \u00b6 Cada controlador va pasando por una serie de estados conforme se carga la aplicaci\u00f3n, se muestra la pantalla que este gestiona, se cambia de pantalla, etc. Hay tres m\u00e9todos principales en los que podemos colocar c\u00f3digo propio, seg\u00fan el momento en que queramos que se ejecute: viewDidLoad() : este m\u00e9todo ya lo hemos usado en nuestras aplicaciones. Se dispara cuando se carga la ra\u00edz de la jerarqu\u00eda de vistas del controlador. T\u00edpicamente se ejecutar\u00eda una sola vez en toda la aplicaci\u00f3n, y por ello se suele usar para inicializar propiedades del controlador. No obstante si el sistema anda bajo de memoria puede liberar la correspondiente al controlador y como resultado este m\u00e9todo podr\u00eda ejecutarse m\u00e1s de una vez. viewWillAppear() : se ejecuta inmediatamente antes de dibujar la vista. viewDidAppear() : se ejecuta cuando la vista ya se ha dibujado. \u00datil para colocar c\u00f3digo relativo por ejemplo a animaciones. Los m\u00e9todos anteriores y sus \u201ccomplementarios\u201d (con disappear en lugar de appear ) se recogen en el siguiente esquema Rotaciones \u00b6 https://developer.apple.com/reference/uikit/uiviewcontroller Instanciar controladores y vistas \u00b6 Podemos hacerlo de varias formas. De m\u00e1s sencilla a m\u00e1s compleja (pero tambi\u00e9n m\u00e1s flexible) Gr\u00e1ficamente, con *storyboards : tanto las vistas como el controlador est\u00e1n en el storyboard* Gr\u00e1ficamente, con .nib : en cada archivo nib guardamos una pantalla (con su jerarqu\u00eda de vistas), pero no el controlador, que se crea por c\u00f3digo Totalmente por c\u00f3digo : tenemos que instanciar el controlador y en su m\u00e9todo loadView crear la jerarqu\u00eda de vistas que queremos que contenga ( UIView , UIButton , lo que sea) y asignar la ra\u00edz de la jerarqu\u00eda de vistas a self.view . En los siguientes apartados vamos a ver las dos primeras opciones con algo m\u00e1s de detalle. Storyboards \u00b6 Desde Xcode 5 los storyboards son la forma recomendada por Apple de crear interfaces de usuario. Un storyboard contiene la representaci\u00f3n gr\u00e1fica de las \u201cpantallas\u201d (los controladores) que componen nuestra aplicaci\u00f3n y de las relaciones entre ellas. Adem\u00e1s el sistema se encarga autom\u00e1ticamente de moverse por las pantallas cuando sucedan determinados eventos, instanciando los controladores y las vistas autom\u00e1ticamente. El controller de cada pantalla \u00b6 Por defecto, los view controller que a\u00f1adimos visualmente al storyboard son clases propias de Cocoa, es decir, no tenemos que escribir c\u00f3digo pero tampoco podemos sobreescribir sus m\u00e9todos ya que no son clases nuestras. Podemos cambiar la clase de cualquier elemento en el Interface Builder seleccion\u00e1ndolo y yendo al icono del Identity inspector : en el \u00e1rea de Utilities . Seleccionaremos el controller y cambiaremos su Class por una escrita por nosotros y que herede de UIViewController . Seleccionar el view controller con el rat\u00f3n haciendo clic sobre \u00e9l a veces no es sencillo, ya que acabamos seleccionando los elementos de la vista contenidos en \u00e9l. Podemos hacerlo m\u00e1s f\u00e1cilmente pulsando el icono de view controller que aparece en su parte superior El controller inicial \u00b6 En cada momento habr\u00e1 un view controller inicial que es el que se muestra cuando se carga la aplicaci\u00f3n. Se distingue visualmente porque tiene una flecha apuntando a \u00e9l desde la izquierda: Para convertir un view controller en inicial , teni\u00e9ndolo seleccionado ir al icono de propiedades del \u00e1rea de Utilities y marcar sobre el checkbox Is initial view controller Tambi\u00e9n podemos arrastrar la flecha que indica que un controlador es el inicial desde el actual hasta el que queremos convertir en inicial. Segues \u00b6 Son las transiciones entre los controllers . Podemos crear un segue visualmente con Ctrl+Arrastrar entre un elemento cualquiera de un view controller (por ejemplo un bot\u00f3n), que ser\u00e1 el de controller de origen, y el controller destino. Se nos dar\u00e1 a elegir el tipo de *segue * en un men\u00fa contextual. Tipos b\u00e1sicos de segue \u00b6 Como vemos en el men\u00fa contextual hay cuatro tipos de segue . Dos de ellos son mostrar ( show ) y otros dos presentar ( present ). Adem\u00e1s podemos programar nuestro propio tipo de segue con custom . Show es la forma recomendada habitualmente, ya que permite que el controlador actual \u201cdecida\u201d c\u00f3mo mostrar f\u00edsicamente el nuevo. Por ejemplo si el controlador actual \u201cocupa\u201d toda la pantalla, el nuevo tambi\u00e9n lo har\u00e1, pero si por ejemplo es un tab bar controller solo cambiar\u00e1 la parte de la pantalla que muestra contenido, no la barra de herramientas Present quiere decir que el nuevo controller se mostrar\u00e1 de forma modal, de manera similar a cuando en un interfaz gr\u00e1fico se muestra por ejemplo un cuadro de di\u00e1logo modal. No obstante esto no quiere decir que el controller antiguo se siga viendo \u201cpor debajo\u201d, ya que en dispositivos con tama\u00f1o de pantalla limitado el nuevo ocupar\u00e1 toda la pantalla. Como vemos en el men\u00fa contextual, en el caso del show se distingue adem\u00e1s entre Show \u201ca secas\u201d y Show detail . El primero es el indicado cuando el nuevo controller va a sustituir completamente al anterior y el segundo cuando el nuevo es \u201csecundario\u201d con respecto al anterior (como en el ejemplo que pon\u00edamos del tab bar . En el caso del present , se distingue entre Present Modally y Present As Popover . El primero ser\u00eda lo que todo el mundo entiende por \u201cmodal\u201d: el nuevo controller se pone \u201cencima\u201d del anterior. El segundo es el t\u00edpico popover que aparece en el iPad. En realidad la forma concreta de mostrar exactamente el nuevo controlador la decide iOS dependiendo de las dimensiones actuales del dispositivo. Por ejemplo en un iPhone SE en vertical no aparecer\u00e1 un popover aunque lo especifiquemos, la que la pantalla es muy peque\u00f1a para ello. Podemos configurar las propiedades del *segue * haciendo clic sobre \u00e9l y yendo al icono de propiedades del \u00e1rea de Utilities . Aqu\u00ed podemos cambiar el tipo y tambi\u00e9n la transici\u00f3n usada para navegar de una pantalla a otra. Estilos de presentaci\u00f3n y de transici\u00f3n Podemos usar diversos estilos a la hora de presentar de forma modal un controller . Por ejemplo podemos indicar que el nuevo controlador debe ocupar toda la pantalla, o bien solo el alto dejando una zona a los lados, o bien un recuadro central como un cuadro de di\u00e1logo\u2026 Estos estilos se definen en una propiedad del controller a presentar, y no del *segue . En Xcode podemos cambiarlos con la propiedad Presentation en el attribute inspector del controller*: En Swift especificamos el estilo dando valores a la propiedad modalPresentationStyle del controller que vamos a presentar. Por otro lado, tambi\u00e9n podemos especificar una animaci\u00f3n para la transici\u00f3n entre el controller actual y el siguiente. De nuevo es una propiedad del controller destino, no del segue . En Xcode se controla gr\u00e1ficamente con la propiedad Transition style del inspector de atributos . En Swift con la propiedad modalTransitionStyle del controller a presentar. Pasar datos de un controller a otro en un segue Cuando se va a saltar de un controller a otro a trav\u00e9s de un segue , se llama al m\u00e9todo prepare(for:sender:) del controller origen. Podemos sobreescribir este m\u00e9todo para pasarle datos al controller destino. El primer par\u00e1metro va a instanciarse al segue y a partir de este podemos obtener una referencia al destino. Por ejemplo supongamos que tenemos dos controller conectados por un segue , y este se dispara con un bot\u00f3n en el primero. Supongamos que el primer controller es un objeto de la clase ViewController , mientras que el segundo es de la clase ViewController2 . En el c\u00f3digo de ViewController2 podr\u00eda haber algo como: 1 2 3 4 5 6 7 8 class ViewController2 : UIViewController { var mensaje = \"\" override func viewDidLoad () { super . viewDidLoad () print ( self . mensaje ) } } Es decir, imprimimos un mensaje cuando se carga la pantalla (lo normal ser\u00eda mostrarlo en un label o similar, pero para los prop\u00f3sitos de este ejemplo nos basta con que salga en la consola). Podemos acceder a esta propiedad texto desde el controller anterior sobreescribiendo el m\u00e9todo prepare(for:sender:) 1 2 3 4 5 6 7 override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if ( segue . identifier == \"siguiente\" ) { if let vc2 = segue . destination as ? ViewController2 { vc2 . mensaje = \"Bienvenidos a la pantalla 2\" } } } Volver atr\u00e1s en un segue \u00b6 Aunque podemos crear un segue de modo visual, no podemos configurar visualmente c\u00f3mo volver a la pantalla anterior cuando hemos seguido un segue . Esta \u201cvuelta atr\u00e1s\u201d se llama unwinding y para conseguirla tenemos que escribir algo de c\u00f3digo. En el controller al que se vuelve atr\u00e1s debemos implementar un m\u00e9todo que puede tener el nombre que deseemos pero debe tener una signatura espec\u00edfica: - Est\u00e1 \u201cmarcada\u201d con un @IBAction - Tiene como \u00fanico par\u00e1metro un UIStoryboardSegue , que es el segue que se est\u00e1 usando para volver atr\u00e1s. Por ejemplo 1 2 3 @IBAction func miUnwind ( segue : UIStoryboardSegue ) { print ( \"Volviendo atr\u00e1s por \\( segue . identifier ) ...\" ) } Ahora en la pantalla que dispara el unwind debemos conectar usando Ctrl+Arrastrar el elemento de interfaz que produce la vuelta atr\u00e1s con el icono de Exit que aparece en la parte de arriba. Si intentamos hacer esta operaci\u00f3n de Ctrl+Arrastrar sin haber implementado el m\u00e9todo anterior, veremos que no tiene efecto En el m\u00e9todo del unwinding , n\u00f3tese que podemos usar el par\u00e1metro, que es el segue , para obtener el destination , que ahora ser\u00e1 el controller al que volvemos. Finalmente, decir que cuando se produce un unwind , el controlador desde el que se vuelve tambi\u00e9n recibe una llamada a prepare(for:sender:) , m\u00e9todo que podemos sobreescribir si queremos aprovechar para realizar alguna operaci\u00f3n antes de volver. NIBs \u00b6 Un problema con los storyboards es que no funcionan bien para desarrollar en equipo. Aunque dos desarrolladores modifiquen distintas pantallas de la aplicaci\u00f3n, si ambas est\u00e1n en el mismo storyboard tendremos problemas, ya que no es tan f\u00e1cil resolver conflictos de versiones como cuando trabajamos con c\u00f3digo Swift. En algunas ocasiones puede interesarnos m\u00e1s que cada desarrollador trabaje con sus propias pantallas, o al menos que cada una pueda modificarse de forma individual. Esto lo conseguimos con los archivos NIB, que almacenan una \u00fanica jerarqu\u00eda de vistas: t\u00edpicamente una \u201cpantalla\u201d, aunque tambi\u00e9n puede ser una subvista compleja. Un archivo NIB (o .xib , en un momento veremos la diferencia) contiene la jerarqu\u00eda de vistas asociada a un determinado view controller , pero normalmente no se crea de manera manual, sino visualmente con el Interface Builder. De hecho, el nombre significa \u201cNeXT Interface Builder\u201d, referenciando la famosa plataforma NeXTSTEP de la que hereda y es deudora Cocoa. Hasta que apareci\u00f3 iOS 5 los NIB eran la forma habitual de crear interfaces de usuario, pero por defecto las versiones actuales de Xcode (desde la 5, correspondi\u00e9ndose con iOS7) usan storyboards . N\u00f3tese que un NIB contiene \u00fanicamente la parte gr\u00e1fica de \u201cuna pantalla\u201d de nuestra aplicaci\u00f3n y que por tanto es responsabilidad del desarrollador cambiar de un controlador a otro y cargar el NIB correspondiente conforme se va navegando. Un archivo .xib, que es lo que vemos en la lista de archivos de proyecto en Xcode, es b\u00e1sicamente un NIB serializado en forma de XML, lo que podemos comprobar haciendo clic sobre \u00e9l con el bot\u00f3n derecho en Xcode y seleccionando Open as > Source code . En Xcode podemos crear un NIB de dos formas: - Crear un controller y autom\u00e1ticamente un NIB asociado - Crear directamente el NIB y luego asociarle un controller por c\u00f3digo Crear y editar un NIB \u00b6 Podemos crear un view controller con un NIB asociado con File > New > File... , seleccionando la plantilla \u201cCocoa Touch Class\u201d dentro del apartado \u201cSource\u201d y en el paso siguiente, haciendo que nuestra clase sea subclase de un controller est\u00e1ndar (por ejemplo UIViewController ) y marcando la casilla create XIB file . Tambi\u00e9n podemos crear directamente un NIB, sin controller , yendo al men\u00fa File > New > File... y seleccionando la plantilla \u201cView\u201d dentro del apartado \u201cUser interface\u201d. El editor visual para NIB es el mismo que para storyboard , con la \u00fanica diferencia de que estamos editando una \u201c\u00fanica pantalla\u201d de nuestra aplicaci\u00f3n. El NIB tiene un concepto que no tienen los storyboard y es el del File\u2019s Owner . Este es el objeto que ha cargado en memoria el NIB. Normalmente el \u201cpropietario\u201d del NIB va a ser el controller asociado, pero puede ser cualquier otro objeto. El file s owner tiene su propio icono en el editor visual En el m\u00f3dulo de introducci\u00f3n a iOS cre\u00e1bamos visualmente el esqueleto de los outlets y actions haciendo Ctrl-Drag desde los elementos del interfaz hacia el c\u00f3digo fuente. Tambi\u00e9n se pueden crear outlets y actions arrastrando entre el icono del File\u2019s Owner y el elemento de interfaz, pero es un m\u00e9todo ligeramente distinto (primero se escribe manualmente el c\u00f3digo y luego se hace la conexi\u00f3n). Podemos especificar la clase concreta del File\u2019s owner haciendo clic sobre su icono y yendo al Identity inspector del \u00e1rea de Utilities . Aqu\u00ed normalmente seleccionaremos el controller que queremos que gestione esta \u201cpantalla\u201d de la aplicaci\u00f3n. Mostrar un controller con un NIB \u00b6 Si el NIB tiene un controller asociado, se cargar\u00e1 autom\u00e1ticamente al presentar el controller . Por ejemplo, supongamos que hemos creado una clase ViewControllerNIB . Una vez creada una instancia del controller especificamos, si es necesario, el estilo de la transici\u00f3n ( modalTransitionStyle ) y el estilo de presentaci\u00f3n ( modalPresentationStyle ). Y finalmente presentamos el controller con present(_,animated:,completion:) , donde: - animated es un booleano que indica si queremos o no animaci\u00f3n - completion es una clausura en la que ponemos el c\u00f3digo a ejecutar una vez se haya presentado el controller 1 2 3 4 5 6 7 8 //creamos el controller let vc = ViewControllerNIB () //Seleccionamos la transici\u00f3n. Por defecto es \"coverVertical\" vc . modalTransitionStyle = UIModalTransitionStyle . flipHorizontal ; //presentamos el controller. Usamos una \"trailing closure\" self . present ( vc , animated : true ) { print ( \"presentado!\" ) } Ahora, para volver atr\u00e1s y dejar de ver el controller presentado, usamos el m\u00e9todo dismiss(animated:completion) , cuyos par\u00e1metros son iguales que el present excepto el primero que se omite. Este m\u00e9todo lo podemos implementar en el controlador que se ha presentado, o bien en el presentador , ya que si el \u201cpresentado\u201d no lo implementa el sistema lo redirige al otro.","title":"View Controllers"},{"location":"1_controllers/apuntes/#sesion-1-view-controllers","text":"","title":"Sesi\u00f3n 1: View Controllers"},{"location":"1_controllers/apuntes/#view-controllers-funciones-basicas","text":"Los view controllers son la C del MVC. Su tarea m\u00e1s importante es gestionar una jerarqu\u00eda de vistas. Cada controller tiene una vista \u201cprincipal\u201d o \u201cra\u00edz\u201d (su propiedad view ), y esa a su vez tiene subvistas que por supuesto pueden contener otras subvistas y as\u00ed sucesivamente. Hay dos tipos b\u00e1sicos de controladores: los que muestran directamente contenido ( content controllers ) y los que contienen otros contenedores ( container controllers ). Estos \u00faltimos contienen a otros controladores. Lo que hace el contenedor es redimensionar y colocar la vista principal de sus hijos, pero cada uno de ellos es responsable de mostrar su propio contenido","title":"View controllers. Funciones b\u00e1sicas"},{"location":"1_controllers/apuntes/#otras-tareas-de-los-view-controllers","text":"Adem\u00e1s de gestionar la jerarqu\u00eda de vistas, los controladores act\u00faan como el \u201cpegamento\u201d que relaciona la vista con el modelo. El controlador es el lugar t\u00edpico para poner el c\u00f3digo que reacciona a los eventos del usuario, como por ejemplo qu\u00e9 hacer cuando se pulsa un bot\u00f3n. Es nuestra responsabilidad como desarrolladores asegurarnos de que no colocamos demasiada l\u00f3gica en el c\u00f3digo del controller . La l\u00f3gica deber\u00eda ir en el modelo, no en el controller , que deber\u00eda contener el m\u00ednimo c\u00f3digo imprescindible para comunicar vista y modelo. Por otro lado, los controllers son los responsables de adaptar las dimensiones de los componentes de la interfaz a las dimensiones reales de la pantalla. Para ello se usan varios mecanismos: autolayout , size classes y traits , que veremos a nivel introductorio en las siguientes sesiones.","title":"Otras tareas de los view controllers"},{"location":"1_controllers/apuntes/#ciclo-de-vida-de-un-controller","text":"Cada controlador va pasando por una serie de estados conforme se carga la aplicaci\u00f3n, se muestra la pantalla que este gestiona, se cambia de pantalla, etc. Hay tres m\u00e9todos principales en los que podemos colocar c\u00f3digo propio, seg\u00fan el momento en que queramos que se ejecute: viewDidLoad() : este m\u00e9todo ya lo hemos usado en nuestras aplicaciones. Se dispara cuando se carga la ra\u00edz de la jerarqu\u00eda de vistas del controlador. T\u00edpicamente se ejecutar\u00eda una sola vez en toda la aplicaci\u00f3n, y por ello se suele usar para inicializar propiedades del controlador. No obstante si el sistema anda bajo de memoria puede liberar la correspondiente al controlador y como resultado este m\u00e9todo podr\u00eda ejecutarse m\u00e1s de una vez. viewWillAppear() : se ejecuta inmediatamente antes de dibujar la vista. viewDidAppear() : se ejecuta cuando la vista ya se ha dibujado. \u00datil para colocar c\u00f3digo relativo por ejemplo a animaciones. Los m\u00e9todos anteriores y sus \u201ccomplementarios\u201d (con disappear en lugar de appear ) se recogen en el siguiente esquema","title":"Ciclo de vida de un controller"},{"location":"1_controllers/apuntes/#rotaciones","text":"https://developer.apple.com/reference/uikit/uiviewcontroller","title":"Rotaciones"},{"location":"1_controllers/apuntes/#instanciar-controladores-y-vistas","text":"Podemos hacerlo de varias formas. De m\u00e1s sencilla a m\u00e1s compleja (pero tambi\u00e9n m\u00e1s flexible) Gr\u00e1ficamente, con *storyboards : tanto las vistas como el controlador est\u00e1n en el storyboard* Gr\u00e1ficamente, con .nib : en cada archivo nib guardamos una pantalla (con su jerarqu\u00eda de vistas), pero no el controlador, que se crea por c\u00f3digo Totalmente por c\u00f3digo : tenemos que instanciar el controlador y en su m\u00e9todo loadView crear la jerarqu\u00eda de vistas que queremos que contenga ( UIView , UIButton , lo que sea) y asignar la ra\u00edz de la jerarqu\u00eda de vistas a self.view . En los siguientes apartados vamos a ver las dos primeras opciones con algo m\u00e1s de detalle.","title":"Instanciar controladores y vistas"},{"location":"1_controllers/apuntes/#storyboards","text":"Desde Xcode 5 los storyboards son la forma recomendada por Apple de crear interfaces de usuario. Un storyboard contiene la representaci\u00f3n gr\u00e1fica de las \u201cpantallas\u201d (los controladores) que componen nuestra aplicaci\u00f3n y de las relaciones entre ellas. Adem\u00e1s el sistema se encarga autom\u00e1ticamente de moverse por las pantallas cuando sucedan determinados eventos, instanciando los controladores y las vistas autom\u00e1ticamente.","title":"Storyboards"},{"location":"1_controllers/apuntes/#el-controller-de-cada-pantalla","text":"Por defecto, los view controller que a\u00f1adimos visualmente al storyboard son clases propias de Cocoa, es decir, no tenemos que escribir c\u00f3digo pero tampoco podemos sobreescribir sus m\u00e9todos ya que no son clases nuestras. Podemos cambiar la clase de cualquier elemento en el Interface Builder seleccion\u00e1ndolo y yendo al icono del Identity inspector : en el \u00e1rea de Utilities . Seleccionaremos el controller y cambiaremos su Class por una escrita por nosotros y que herede de UIViewController . Seleccionar el view controller con el rat\u00f3n haciendo clic sobre \u00e9l a veces no es sencillo, ya que acabamos seleccionando los elementos de la vista contenidos en \u00e9l. Podemos hacerlo m\u00e1s f\u00e1cilmente pulsando el icono de view controller que aparece en su parte superior","title":"El controller de cada pantalla"},{"location":"1_controllers/apuntes/#el-controller-inicial","text":"En cada momento habr\u00e1 un view controller inicial que es el que se muestra cuando se carga la aplicaci\u00f3n. Se distingue visualmente porque tiene una flecha apuntando a \u00e9l desde la izquierda: Para convertir un view controller en inicial , teni\u00e9ndolo seleccionado ir al icono de propiedades del \u00e1rea de Utilities y marcar sobre el checkbox Is initial view controller Tambi\u00e9n podemos arrastrar la flecha que indica que un controlador es el inicial desde el actual hasta el que queremos convertir en inicial.","title":"El controller inicial"},{"location":"1_controllers/apuntes/#segues","text":"Son las transiciones entre los controllers . Podemos crear un segue visualmente con Ctrl+Arrastrar entre un elemento cualquiera de un view controller (por ejemplo un bot\u00f3n), que ser\u00e1 el de controller de origen, y el controller destino. Se nos dar\u00e1 a elegir el tipo de *segue * en un men\u00fa contextual.","title":"Segues"},{"location":"1_controllers/apuntes/#tipos-basicos-de-segue","text":"Como vemos en el men\u00fa contextual hay cuatro tipos de segue . Dos de ellos son mostrar ( show ) y otros dos presentar ( present ). Adem\u00e1s podemos programar nuestro propio tipo de segue con custom . Show es la forma recomendada habitualmente, ya que permite que el controlador actual \u201cdecida\u201d c\u00f3mo mostrar f\u00edsicamente el nuevo. Por ejemplo si el controlador actual \u201cocupa\u201d toda la pantalla, el nuevo tambi\u00e9n lo har\u00e1, pero si por ejemplo es un tab bar controller solo cambiar\u00e1 la parte de la pantalla que muestra contenido, no la barra de herramientas Present quiere decir que el nuevo controller se mostrar\u00e1 de forma modal, de manera similar a cuando en un interfaz gr\u00e1fico se muestra por ejemplo un cuadro de di\u00e1logo modal. No obstante esto no quiere decir que el controller antiguo se siga viendo \u201cpor debajo\u201d, ya que en dispositivos con tama\u00f1o de pantalla limitado el nuevo ocupar\u00e1 toda la pantalla. Como vemos en el men\u00fa contextual, en el caso del show se distingue adem\u00e1s entre Show \u201ca secas\u201d y Show detail . El primero es el indicado cuando el nuevo controller va a sustituir completamente al anterior y el segundo cuando el nuevo es \u201csecundario\u201d con respecto al anterior (como en el ejemplo que pon\u00edamos del tab bar . En el caso del present , se distingue entre Present Modally y Present As Popover . El primero ser\u00eda lo que todo el mundo entiende por \u201cmodal\u201d: el nuevo controller se pone \u201cencima\u201d del anterior. El segundo es el t\u00edpico popover que aparece en el iPad. En realidad la forma concreta de mostrar exactamente el nuevo controlador la decide iOS dependiendo de las dimensiones actuales del dispositivo. Por ejemplo en un iPhone SE en vertical no aparecer\u00e1 un popover aunque lo especifiquemos, la que la pantalla es muy peque\u00f1a para ello. Podemos configurar las propiedades del *segue * haciendo clic sobre \u00e9l y yendo al icono de propiedades del \u00e1rea de Utilities . Aqu\u00ed podemos cambiar el tipo y tambi\u00e9n la transici\u00f3n usada para navegar de una pantalla a otra.","title":"Tipos b\u00e1sicos de segue"},{"location":"1_controllers/apuntes/#volver-atras-en-un-segue","text":"Aunque podemos crear un segue de modo visual, no podemos configurar visualmente c\u00f3mo volver a la pantalla anterior cuando hemos seguido un segue . Esta \u201cvuelta atr\u00e1s\u201d se llama unwinding y para conseguirla tenemos que escribir algo de c\u00f3digo. En el controller al que se vuelve atr\u00e1s debemos implementar un m\u00e9todo que puede tener el nombre que deseemos pero debe tener una signatura espec\u00edfica: - Est\u00e1 \u201cmarcada\u201d con un @IBAction - Tiene como \u00fanico par\u00e1metro un UIStoryboardSegue , que es el segue que se est\u00e1 usando para volver atr\u00e1s. Por ejemplo 1 2 3 @IBAction func miUnwind ( segue : UIStoryboardSegue ) { print ( \"Volviendo atr\u00e1s por \\( segue . identifier ) ...\" ) } Ahora en la pantalla que dispara el unwind debemos conectar usando Ctrl+Arrastrar el elemento de interfaz que produce la vuelta atr\u00e1s con el icono de Exit que aparece en la parte de arriba. Si intentamos hacer esta operaci\u00f3n de Ctrl+Arrastrar sin haber implementado el m\u00e9todo anterior, veremos que no tiene efecto En el m\u00e9todo del unwinding , n\u00f3tese que podemos usar el par\u00e1metro, que es el segue , para obtener el destination , que ahora ser\u00e1 el controller al que volvemos. Finalmente, decir que cuando se produce un unwind , el controlador desde el que se vuelve tambi\u00e9n recibe una llamada a prepare(for:sender:) , m\u00e9todo que podemos sobreescribir si queremos aprovechar para realizar alguna operaci\u00f3n antes de volver.","title":"Volver atr\u00e1s en un segue"},{"location":"1_controllers/apuntes/#nibs","text":"Un problema con los storyboards es que no funcionan bien para desarrollar en equipo. Aunque dos desarrolladores modifiquen distintas pantallas de la aplicaci\u00f3n, si ambas est\u00e1n en el mismo storyboard tendremos problemas, ya que no es tan f\u00e1cil resolver conflictos de versiones como cuando trabajamos con c\u00f3digo Swift. En algunas ocasiones puede interesarnos m\u00e1s que cada desarrollador trabaje con sus propias pantallas, o al menos que cada una pueda modificarse de forma individual. Esto lo conseguimos con los archivos NIB, que almacenan una \u00fanica jerarqu\u00eda de vistas: t\u00edpicamente una \u201cpantalla\u201d, aunque tambi\u00e9n puede ser una subvista compleja. Un archivo NIB (o .xib , en un momento veremos la diferencia) contiene la jerarqu\u00eda de vistas asociada a un determinado view controller , pero normalmente no se crea de manera manual, sino visualmente con el Interface Builder. De hecho, el nombre significa \u201cNeXT Interface Builder\u201d, referenciando la famosa plataforma NeXTSTEP de la que hereda y es deudora Cocoa. Hasta que apareci\u00f3 iOS 5 los NIB eran la forma habitual de crear interfaces de usuario, pero por defecto las versiones actuales de Xcode (desde la 5, correspondi\u00e9ndose con iOS7) usan storyboards . N\u00f3tese que un NIB contiene \u00fanicamente la parte gr\u00e1fica de \u201cuna pantalla\u201d de nuestra aplicaci\u00f3n y que por tanto es responsabilidad del desarrollador cambiar de un controlador a otro y cargar el NIB correspondiente conforme se va navegando. Un archivo .xib, que es lo que vemos en la lista de archivos de proyecto en Xcode, es b\u00e1sicamente un NIB serializado en forma de XML, lo que podemos comprobar haciendo clic sobre \u00e9l con el bot\u00f3n derecho en Xcode y seleccionando Open as > Source code . En Xcode podemos crear un NIB de dos formas: - Crear un controller y autom\u00e1ticamente un NIB asociado - Crear directamente el NIB y luego asociarle un controller por c\u00f3digo","title":"NIBs"},{"location":"1_controllers/apuntes/#crear-y-editar-un-nib","text":"Podemos crear un view controller con un NIB asociado con File > New > File... , seleccionando la plantilla \u201cCocoa Touch Class\u201d dentro del apartado \u201cSource\u201d y en el paso siguiente, haciendo que nuestra clase sea subclase de un controller est\u00e1ndar (por ejemplo UIViewController ) y marcando la casilla create XIB file . Tambi\u00e9n podemos crear directamente un NIB, sin controller , yendo al men\u00fa File > New > File... y seleccionando la plantilla \u201cView\u201d dentro del apartado \u201cUser interface\u201d. El editor visual para NIB es el mismo que para storyboard , con la \u00fanica diferencia de que estamos editando una \u201c\u00fanica pantalla\u201d de nuestra aplicaci\u00f3n. El NIB tiene un concepto que no tienen los storyboard y es el del File\u2019s Owner . Este es el objeto que ha cargado en memoria el NIB. Normalmente el \u201cpropietario\u201d del NIB va a ser el controller asociado, pero puede ser cualquier otro objeto. El file s owner tiene su propio icono en el editor visual En el m\u00f3dulo de introducci\u00f3n a iOS cre\u00e1bamos visualmente el esqueleto de los outlets y actions haciendo Ctrl-Drag desde los elementos del interfaz hacia el c\u00f3digo fuente. Tambi\u00e9n se pueden crear outlets y actions arrastrando entre el icono del File\u2019s Owner y el elemento de interfaz, pero es un m\u00e9todo ligeramente distinto (primero se escribe manualmente el c\u00f3digo y luego se hace la conexi\u00f3n). Podemos especificar la clase concreta del File\u2019s owner haciendo clic sobre su icono y yendo al Identity inspector del \u00e1rea de Utilities . Aqu\u00ed normalmente seleccionaremos el controller que queremos que gestione esta \u201cpantalla\u201d de la aplicaci\u00f3n.","title":"Crear y editar un NIB"},{"location":"1_controllers/apuntes/#mostrar-un-controller-con-un-nib","text":"Si el NIB tiene un controller asociado, se cargar\u00e1 autom\u00e1ticamente al presentar el controller . Por ejemplo, supongamos que hemos creado una clase ViewControllerNIB . Una vez creada una instancia del controller especificamos, si es necesario, el estilo de la transici\u00f3n ( modalTransitionStyle ) y el estilo de presentaci\u00f3n ( modalPresentationStyle ). Y finalmente presentamos el controller con present(_,animated:,completion:) , donde: - animated es un booleano que indica si queremos o no animaci\u00f3n - completion es una clausura en la que ponemos el c\u00f3digo a ejecutar una vez se haya presentado el controller 1 2 3 4 5 6 7 8 //creamos el controller let vc = ViewControllerNIB () //Seleccionamos la transici\u00f3n. Por defecto es \"coverVertical\" vc . modalTransitionStyle = UIModalTransitionStyle . flipHorizontal ; //presentamos el controller. Usamos una \"trailing closure\" self . present ( vc , animated : true ) { print ( \"presentado!\" ) } Ahora, para volver atr\u00e1s y dejar de ver el controller presentado, usamos el m\u00e9todo dismiss(animated:completion) , cuyos par\u00e1metros son iguales que el present excepto el primero que se omite. Este m\u00e9todo lo podemos implementar en el controlador que se ha presentado, o bien en el presentador , ya que si el \u201cpresentado\u201d no lo implementa el sistema lo redirige al otro.","title":"Mostrar un controller con un NIB"},{"location":"1_controllers/ejercicios/","text":"Ejercicios de view controllers (1,5 puntos) \u00b6 Vamos a hacer una aplicaci\u00f3n que vamos a llamar \u201cPioneras\u201d, y que nos dar\u00e1 datos de algunas mujeres pioneras de la inform\u00e1tica. La aplicaci\u00f3n tendr\u00e1 una pantalla principal en la que aparecer\u00e1n sus im\u00e1genes, y haciendo tap sobre cada una podremos ir a las pantallas secundarias donde se nos dar\u00e1 m\u00e1s informaci\u00f3n. Al crear el proyecto asegur\u00e1os de estar usando git (Sea desde Xcode o manualmente) ya que habr\u00e1 que guardar y marcar el estado con un commit especial en un momento intermedio Realizar la estructura b\u00e1sica de la aplicaci\u00f3n (0,5 puntos) \u00b6 En este archivo tenemos las im\u00e1genes de las tres pioneras: Ada Lovelace, Grace Hopper y Barbara Liskov, que como siempre arrastraremos al Assets.xcassets . Tambi\u00e9n tenemos los textos sobre ellas que se mostrar\u00e1n en las pantallas secundarias. Crea tres botones en la pantalla principal, y para cada uno de ellos en lugar de texto vamos a usar como imagen de fondo la de cada mujer. Al final cada bot\u00f3n deber\u00eda ocupar todo el ancho de la pantalla y m\u00e1s o menos un tercio del alto. Importante: no es necesario que la interfaz sea perfecta (todos los botones exactamente del mismo alto, etc). De hecho si la pruebas en un dispositivo de tama\u00f1o de pantalla distinto al que est\u00e1s usando ahora mismo en Xcode ver\u00e1s que se ve \u201cfatal\u201d. Para hacer que todos los botones tengan el mismo alto y que se adapten bien a la pantalla usaremos un mecanismo que todav\u00eda no hemos visto denominado autolayout . Por el momento vamos a ignorar este tema Arrastra un nuevo \u201cview controller\u201d al storyboard (una \u201cpantalla\u201d nueva), que ser\u00e1 el que aparezca cuando se pulse en el primero de los botones (el de Ada Lovelace). Inserta un campo de texto de varias l\u00edneas ( text view ) y copia en \u00e9l el contenido de lovelace.txt Ahora establece el segue entre las dos pantallas : haz Ctrl+Arrastrar desde el primero de los botones con la imagen de Ada Lovelace hasta la segunda pantalla. Ejecuta el proyecto para comprobar que funciona lo que has hecho, aunque todav\u00eda no puede volver atr\u00e1s desde la pantalla secundaria Implementa la opci\u00f3n de volver atr\u00e1s de la secundaria a la principal Crea un bot\u00f3n \u201catr\u00e1s\u201d en la pantalla secundaria y col\u00f3calo en la parte de arriba (para que no lo tape el teclado on-screen si aparece) En el controller destino crea un m\u00e9todo para que funcione el unwinding (no hace falta que haga nada, solo que exista) 1 2 3 @IBAction func retornoDeSecundaria ( segue : UIStoryboardSegue ) { } Con Ctrl+Arrastrar conecta el bot\u00f3n \u201catr\u00e1s\u201d con el icono de \u201cExit\u201d de la parte superior del controller Ejecuta el proyecto y comprueba que puedes volver atr\u00e1s desde la pantalla secundaria 6. Repite lo que has hecho en el caso de Ada Lovelace para las otras dos mujeres, creando las pantallas secundarias y la navegaci\u00f3n adelante y atr\u00e1s. Asegur\u00e1os de guardar el estado actual del proyecto con un commit cuyo comentario sea \u201cversion 1\u201d. Comunicar un controller con otro (1 punto) \u00b6 Es un poco redundante tener tantas pantallas secundarias cuando en realidad lo \u00fanico que cambia es el texto a mostrar. Valdr\u00eda con una sola secundaria en la que cambi\u00e1ramos din\u00e1micamente dicho texto. Vamos a implementarlo as\u00ed. Ahora pod\u00e9is eliminar los segues y las pantallas secundarias, es mejor crearlos de nuevo. Crear la nueva interfaz \u00b6 Crea de nuevo una pantalla secundaria con un campo de texto de varias l\u00edneas Con Ctrl+arrastrar podemos crear un segue desde cada uno de los botones hasta la pantalla. Habr\u00e1n tres segues que lleguen a la misma, no deber\u00eda ser problema. A\u00f1\u00e1dele a la pantalla el bot\u00f3n de \u201catr\u00e1s\u201d y con\u00e9ctalo con el icono de \u201cexit\u201d. El c\u00f3digo necesario para el unwinding (m\u00e9todo retornoDeSecundaria ) ya deber\u00eda estar en el ViewController Comprueba que la navegaci\u00f3n funciona correctamente yendo adelante y atr\u00e1s Crear un controlador personalizado para la pantalla secundaria \u00b6 Si en la parte derecha de la pantalla miras el identity inspector ver\u00e1s que el controlador de la pantalla secundaria es un tipo propio de Cocoa, el UIViewController . Vamos a cambiarlo por uno propio Crea una nueva clase de Cocoa Touch, (File> New > File\u2026, plantilla \u201ccocoa touch class\u201d). En la segunda pantalla del asistente dale a la clase el nombre SecundarioViewController y haz que sea una subclase de UIViewController . Deja sin marcar la opci\u00f3n de crear el .XIB En el storyboard , selecciona el controller de la pantalla secundaria (es mejor que lo hagas pulsando en el primero de los iconos que aparecen en la parte superior) Una vez seleccionado, ve al identity inspector en el \u00e1rea de Utilities y en el apartado de Custom class selecciona como clase la que has creado, SecundarioViewController A\u00f1adirle un outlet al controlador secundario \u00b6 Tienes que a\u00f1adir un outlet al campo de texto para que su contenido se pueda cambiar desde el controlador secundario. Hazlo como habitualmente, con ctrl+arrastrar entre el campo y el SecundarioViewController , en el assistant editor . Hacer que el texto cambie seg\u00fan el bot\u00f3n pulsado \u00b6 Lo primero es a\u00f1adir f\u00edsicamente los ficheros *.txt con los textos al proyecto para que se puedan cargar din\u00e1micamente por c\u00f3digo. Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona Add files to Pioneras . Selecciona los tres .txt , que se a\u00f1adir\u00e1n al proyecto Otra opci\u00f3n ser\u00eda a\u00f1adir los ficheros a la carpeta Assets.xcassets . Si quieres hacerlo as\u00ed, clica en esa carpeta y con el bot\u00f3n + de la parte inferior crea un nuevo asset de tipo New Data Set . Por defecto se llama data . C\u00e1mbiale el nombre por lovelace y arrastra el archivo lovelace.txt . Repite la misma operaci\u00f3n de crear asset , cambiar nombre y arrastrar archivo para las otras dos \"pioneras\". Para que le podamos decir al controlador secundario qu\u00e9 fichero tiene que abrir, debes crear una propiedad en el SecundarioViewController llamada nomFich de tipo String Para establecer una asociaci\u00f3n sencilla entre cada segue y los datos a mostrar puedes usar el identificador del segue . Haz clic sobre \u00e9l y en el Attributes inspector cambia su identifier , respectivamente por lovelace , hopper y liskov ahora en la clase ViewController , que es el controlador de la pantalla principal, puedes implementar el prepare(for:,sender:) 1 2 3 4 5 6 override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { //obtenemos el controller destino y forzamos la conversi\u00f3n al tipo adecuado let controller = segue . destination as ! SecundarioViewController //fijamosla propiedad \"nomFich\" al identificador del segue controller . nomFich = segue . identifier } Finalmente, en el viewDidLoad() del SecundarioViewController puedes acceder a la propiedad self.nomFich , cargar el texto del fichero y mostrarlo en el campo de texto. Tendr\u00e1s que escribir el c\u00f3digo t\u00fa mismo . Si no has usado el assets.xcassets puedes utilizar los m\u00e9todos: Bundle.main.path(forResource:, ofType:) , que devuelve la trayectoria completa para acceder a un recurso incluido en el proyecto sabiendo su nombre y su tipo (en el tipo pon solo \u201ctxt\u201d, sin el punto). Una vez obtenida la trayectoria, puedes leer el contenido del archivo como una cadena con el constructor de String(contentsOfFile:,encoding:) . Donde el primer par\u00e1metro es la trayectoria y el segundo el juego de caracteres (en nuestro caso el valor enumerado String.Encoding.utf8 ). CUIDADO, este m\u00e9todo est\u00e1 marcado con throws , as\u00ed que tendr\u00e1s que actuar en consecuencia. (usar do..catch o cualquier otra alternativa que veas razonable) Si has usado el assets.xcassets puedes cargar los datos como sigue: 1 2 3 4 5 //CAMBIA nombre_del_asset por el que proceda var texto = \"\" if let data = NSDataAsset ( name : \"nombre_del_asset\" )?. data { texto = String ( data : data , encoding : . utf8 ) }","title":"Ejercicios"},{"location":"1_controllers/ejercicios/#ejercicios-de-view-controllers-15-puntos","text":"Vamos a hacer una aplicaci\u00f3n que vamos a llamar \u201cPioneras\u201d, y que nos dar\u00e1 datos de algunas mujeres pioneras de la inform\u00e1tica. La aplicaci\u00f3n tendr\u00e1 una pantalla principal en la que aparecer\u00e1n sus im\u00e1genes, y haciendo tap sobre cada una podremos ir a las pantallas secundarias donde se nos dar\u00e1 m\u00e1s informaci\u00f3n. Al crear el proyecto asegur\u00e1os de estar usando git (Sea desde Xcode o manualmente) ya que habr\u00e1 que guardar y marcar el estado con un commit especial en un momento intermedio","title":"Ejercicios de view controllers (1,5 puntos)"},{"location":"1_controllers/ejercicios/#realizar-la-estructura-basica-de-la-aplicacion-05-puntos","text":"En este archivo tenemos las im\u00e1genes de las tres pioneras: Ada Lovelace, Grace Hopper y Barbara Liskov, que como siempre arrastraremos al Assets.xcassets . Tambi\u00e9n tenemos los textos sobre ellas que se mostrar\u00e1n en las pantallas secundarias. Crea tres botones en la pantalla principal, y para cada uno de ellos en lugar de texto vamos a usar como imagen de fondo la de cada mujer. Al final cada bot\u00f3n deber\u00eda ocupar todo el ancho de la pantalla y m\u00e1s o menos un tercio del alto. Importante: no es necesario que la interfaz sea perfecta (todos los botones exactamente del mismo alto, etc). De hecho si la pruebas en un dispositivo de tama\u00f1o de pantalla distinto al que est\u00e1s usando ahora mismo en Xcode ver\u00e1s que se ve \u201cfatal\u201d. Para hacer que todos los botones tengan el mismo alto y que se adapten bien a la pantalla usaremos un mecanismo que todav\u00eda no hemos visto denominado autolayout . Por el momento vamos a ignorar este tema Arrastra un nuevo \u201cview controller\u201d al storyboard (una \u201cpantalla\u201d nueva), que ser\u00e1 el que aparezca cuando se pulse en el primero de los botones (el de Ada Lovelace). Inserta un campo de texto de varias l\u00edneas ( text view ) y copia en \u00e9l el contenido de lovelace.txt Ahora establece el segue entre las dos pantallas : haz Ctrl+Arrastrar desde el primero de los botones con la imagen de Ada Lovelace hasta la segunda pantalla. Ejecuta el proyecto para comprobar que funciona lo que has hecho, aunque todav\u00eda no puede volver atr\u00e1s desde la pantalla secundaria Implementa la opci\u00f3n de volver atr\u00e1s de la secundaria a la principal Crea un bot\u00f3n \u201catr\u00e1s\u201d en la pantalla secundaria y col\u00f3calo en la parte de arriba (para que no lo tape el teclado on-screen si aparece) En el controller destino crea un m\u00e9todo para que funcione el unwinding (no hace falta que haga nada, solo que exista) 1 2 3 @IBAction func retornoDeSecundaria ( segue : UIStoryboardSegue ) { } Con Ctrl+Arrastrar conecta el bot\u00f3n \u201catr\u00e1s\u201d con el icono de \u201cExit\u201d de la parte superior del controller Ejecuta el proyecto y comprueba que puedes volver atr\u00e1s desde la pantalla secundaria 6. Repite lo que has hecho en el caso de Ada Lovelace para las otras dos mujeres, creando las pantallas secundarias y la navegaci\u00f3n adelante y atr\u00e1s. Asegur\u00e1os de guardar el estado actual del proyecto con un commit cuyo comentario sea \u201cversion 1\u201d.","title":"Realizar la estructura b\u00e1sica de la aplicaci\u00f3n (0,5 puntos)"},{"location":"1_controllers/ejercicios/#comunicar-un-controller-con-otro-1-punto","text":"Es un poco redundante tener tantas pantallas secundarias cuando en realidad lo \u00fanico que cambia es el texto a mostrar. Valdr\u00eda con una sola secundaria en la que cambi\u00e1ramos din\u00e1micamente dicho texto. Vamos a implementarlo as\u00ed. Ahora pod\u00e9is eliminar los segues y las pantallas secundarias, es mejor crearlos de nuevo.","title":"Comunicar un controller con otro (1 punto)"},{"location":"1_controllers/ejercicios/#crear-la-nueva-interfaz","text":"Crea de nuevo una pantalla secundaria con un campo de texto de varias l\u00edneas Con Ctrl+arrastrar podemos crear un segue desde cada uno de los botones hasta la pantalla. Habr\u00e1n tres segues que lleguen a la misma, no deber\u00eda ser problema. A\u00f1\u00e1dele a la pantalla el bot\u00f3n de \u201catr\u00e1s\u201d y con\u00e9ctalo con el icono de \u201cexit\u201d. El c\u00f3digo necesario para el unwinding (m\u00e9todo retornoDeSecundaria ) ya deber\u00eda estar en el ViewController Comprueba que la navegaci\u00f3n funciona correctamente yendo adelante y atr\u00e1s","title":"Crear la nueva interfaz"},{"location":"1_controllers/ejercicios/#crear-un-controlador-personalizado-para-la-pantalla-secundaria","text":"Si en la parte derecha de la pantalla miras el identity inspector ver\u00e1s que el controlador de la pantalla secundaria es un tipo propio de Cocoa, el UIViewController . Vamos a cambiarlo por uno propio Crea una nueva clase de Cocoa Touch, (File> New > File\u2026, plantilla \u201ccocoa touch class\u201d). En la segunda pantalla del asistente dale a la clase el nombre SecundarioViewController y haz que sea una subclase de UIViewController . Deja sin marcar la opci\u00f3n de crear el .XIB En el storyboard , selecciona el controller de la pantalla secundaria (es mejor que lo hagas pulsando en el primero de los iconos que aparecen en la parte superior) Una vez seleccionado, ve al identity inspector en el \u00e1rea de Utilities y en el apartado de Custom class selecciona como clase la que has creado, SecundarioViewController","title":"Crear un controlador personalizado para la pantalla secundaria"},{"location":"1_controllers/ejercicios/#anadirle-un-outlet-al-controlador-secundario","text":"Tienes que a\u00f1adir un outlet al campo de texto para que su contenido se pueda cambiar desde el controlador secundario. Hazlo como habitualmente, con ctrl+arrastrar entre el campo y el SecundarioViewController , en el assistant editor .","title":"A\u00f1adirle un outlet al controlador secundario"},{"location":"1_controllers/ejercicios/#hacer-que-el-texto-cambie-segun-el-boton-pulsado","text":"Lo primero es a\u00f1adir f\u00edsicamente los ficheros *.txt con los textos al proyecto para que se puedan cargar din\u00e1micamente por c\u00f3digo. Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona Add files to Pioneras . Selecciona los tres .txt , que se a\u00f1adir\u00e1n al proyecto Otra opci\u00f3n ser\u00eda a\u00f1adir los ficheros a la carpeta Assets.xcassets . Si quieres hacerlo as\u00ed, clica en esa carpeta y con el bot\u00f3n + de la parte inferior crea un nuevo asset de tipo New Data Set . Por defecto se llama data . C\u00e1mbiale el nombre por lovelace y arrastra el archivo lovelace.txt . Repite la misma operaci\u00f3n de crear asset , cambiar nombre y arrastrar archivo para las otras dos \"pioneras\". Para que le podamos decir al controlador secundario qu\u00e9 fichero tiene que abrir, debes crear una propiedad en el SecundarioViewController llamada nomFich de tipo String Para establecer una asociaci\u00f3n sencilla entre cada segue y los datos a mostrar puedes usar el identificador del segue . Haz clic sobre \u00e9l y en el Attributes inspector cambia su identifier , respectivamente por lovelace , hopper y liskov ahora en la clase ViewController , que es el controlador de la pantalla principal, puedes implementar el prepare(for:,sender:) 1 2 3 4 5 6 override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { //obtenemos el controller destino y forzamos la conversi\u00f3n al tipo adecuado let controller = segue . destination as ! SecundarioViewController //fijamosla propiedad \"nomFich\" al identificador del segue controller . nomFich = segue . identifier } Finalmente, en el viewDidLoad() del SecundarioViewController puedes acceder a la propiedad self.nomFich , cargar el texto del fichero y mostrarlo en el campo de texto. Tendr\u00e1s que escribir el c\u00f3digo t\u00fa mismo . Si no has usado el assets.xcassets puedes utilizar los m\u00e9todos: Bundle.main.path(forResource:, ofType:) , que devuelve la trayectoria completa para acceder a un recurso incluido en el proyecto sabiendo su nombre y su tipo (en el tipo pon solo \u201ctxt\u201d, sin el punto). Una vez obtenida la trayectoria, puedes leer el contenido del archivo como una cadena con el constructor de String(contentsOfFile:,encoding:) . Donde el primer par\u00e1metro es la trayectoria y el segundo el juego de caracteres (en nuestro caso el valor enumerado String.Encoding.utf8 ). CUIDADO, este m\u00e9todo est\u00e1 marcado con throws , as\u00ed que tendr\u00e1s que actuar en consecuencia. (usar do..catch o cualquier otra alternativa que veas razonable) Si has usado el assets.xcassets puedes cargar los datos como sigue: 1 2 3 4 5 //CAMBIA nombre_del_asset por el que proceda var texto = \"\" if let data = NSDataAsset ( name : \"nombre_del_asset\" )?. data { texto = String ( data : data , encoding : . utf8 ) }","title":"Hacer que el texto cambie seg\u00fan el bot\u00f3n pulsado"},{"location":"2_vistas/apuntes/","text":"Sesi\u00f3n 2: Vistas \u00b6 Interacci\u00f3n con la interfaz por c\u00f3digo \u00b6 Hasta ahora hemos visto como crear la interfaz visualmente con Xcode, mediante storyboards o NIBs, pero todo lo que se puede hacer con dicha herramienta se puede hacer tambi\u00e9n de forma program\u00e1tica, ya que lo \u00fanico que hace el entorno es crear objetos de la API de Cocoa Touch (o definidos por nosotros) y establecer visualmente sus propiedades. Ventanas \u00b6 Las aplicaciones iOS en principio tienen una \u00fanica ventana, que es la propiedad window del Application Delegate . Esta ventana la instancia y gestiona de forma autom\u00e1tica el delegate , as\u00ed que no tenemos que hacer nada al respecto. Solo en caso de no usar storyboards tendr\u00edamos que instanciar el controller a mostrar y asign\u00e1rselo a la propiedad rootView del objeto window . El application delegate es el objeto que gestiona la ventana principal de la aplicaci\u00f3n. Adem\u00e1s de esto, tambi\u00e9n gestiona el ciclo de vida de la aplicaci\u00f3n. Recibe los eventos correspondientes a cuando la aplicaci\u00f3n arranca, cuando se sale de ella, cuando pasa a segundo plano, etc. Es la clase AppDelegate que crea autom\u00e1ticamente la plantilla de Xcode para cualquier aplicaci\u00f3n nueva. En aplicaciones que usen una pantalla externa ( external display ) s\u00ed necesitaremos crear una ventana de las dimensiones apropiadas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Contamos cu\u00e1ntas pantallas hay (principal + externas) let screens = UIScreen . screens if screens . count > 1 { //cogemos \"a pi\u00f1\u00f3n\" la primera externa let extScreen = screens [ 1 ] //creamos una ventana con el mismo tama\u00f1o que la pantalla externa let extWindow = UIWindow ( frame : extScreen . bounds ) //asignamos la ventana a la pantalla extWindow . screen = extScreen //desde iOS9 todas las ventanas deben tener un controller //aqu\u00ed suponemos definida en alg\u00fan lugar su clase let extController = ViewControllerSecundario () //hacemos que la ventana tenga como controller principal el creado extWindow . rootViewController = extController //mostramos la ventana extWindow . isHidden = false } Vistas \u00b6 En el ejemplo anterior hemos supuesto que ten\u00edamos una clase ViewControllerSecundario que us\u00e1bamos para mostrar la vista externa. Vamos a ver paso a paso c\u00f3mo construir\u00edamos esa clase si no quisi\u00e9ramos emplear un NIB o un storyboard . Podemos construir una vista creando un objeto de tipo UIView . En el inicializador deberemos proporcionar el marco que ocupar\u00e1 dicha vista. El marco se define mediante el tipo CGRect (se trata de una estructura, no de un objeto). Por ejemplo, podr\u00edamos inicializar una vista de la siguiente forma: 1 var vista = UIView ( frame : CGRect ( x : 0 , y : 0 , width : 100 , height : 100 )) En lugar de poner un tama\u00f1o fijo deber\u00edamos usar el de la pantalla en la que queramos que aparezca. Se puede obtener el CGRect con los l\u00edmites de la pantalla en la propiedad bounds del objeto UIScreen que nos interese. En los siguientes apartados explicaremos el sistema de coordenadas usado en CGRect Las vistas ( UIView ) tambi\u00e9n nos proporcionan una serie de m\u00e9todos para consultar y modificar la jerarqu\u00eda. El m\u00e9todo b\u00e1sico que necesitaremos es addSubview , que nos permitir\u00e1 a\u00f1adir una subvista a una vista determinada (o a una ventana): 1 2 3 var label = UILabel () label . text = \"Soy la pantalla secundaria\" vista . addSubView ( label ) En el controlador debemos sobreescribir el m\u00e9todo loadView del controlador, que es el m\u00e9todo encargado por defecto de crear las vistas (usualmente desde un NIB o storyboard , aqu\u00ed por c\u00f3digo), y en \u00e9l crear las vistas necesarias, asignando la vista ra\u00edz a self.view . 1 2 3 4 5 6 7 8 9 10 //m\u00e9todo del controlador de la pantalla secundaria override func loadView () { let vista = UIView ( frame : self . screen . bounds ) vista . backgroundColor = UIColor . green let label = UILabel () label . text = \"soy la pantalla secundaria\" label . frame = CGRect ( x : 0 , y : 0 , width : 200 , height : 100 ) vista . addSubView ( label ) self . view = vista } Podemos eliminar una vista envi\u00e1ndole el mensaje removeFromSuperview (se le env\u00eda a la vista hija que queremos eliminar). Podemos tambi\u00e9n consultar la jerarqu\u00eda con los siguientes m\u00e9todos: superview : Nos da la vista padre de la vista destinataria del mensaje. subviews : Nos da la lista de subvistas de una vista dada. isDescendantOfView: Comprueba si una vista es descendiente de otra. Como vemos, una vista tiene una lista de vistas hijas. Cada vista hija tiene un \u00edndice, que determinar\u00e1 el orden en el que se dibujan. El \u00edndice 0 es el m\u00e1s cercano al observador, y por lo tanto tapar\u00e1 a los \u00edndices superiores. Podemos insertar una vista en un \u00edndice determinado de la lista de subvistas con insertSubview:atIndex: . Puede que tengamos una jerarqu\u00eda compleja y necesitemos acceder desde el c\u00f3digo a una determinada vista por ejemplo para inicializar su valor. Una opci\u00f3n es hacer un outlet para cada vista que queramos modificar, pero esto podr\u00eda sobrecargar nuestro objeto de outlets . Tambi\u00e9n puede ser complejo y poco fiable el buscar la vista en la jerarqu\u00eda. En estos casos, lo m\u00e1s sencillo es darle a las vistas que buscamos una etiqueta ( tag ) mediante la propiedad Tag del inspector de atributos (debe ser un valor entero), o asignando la propiedad tag de forma program\u00e1tica. Podremos localizar en nuestro c\u00f3digo una vista a partir de su etiqueta mediante viewWithTag . Llamando a este m\u00e9todo sobre una vista, buscar\u00e1 entre todas las subvistas aquella con la etiqueta indicada: 1 texto = self . window . viewWithTag ( tag : 1 ) La jerarqu\u00eda de vistas de una pantalla determinada de nuestra aplicaci\u00f3n puede llegar a ser muy compleja. Es por eso que en Xcode 6 se ha a\u00f1adido una opci\u00f3n que nos permite mostrar un \u201cdespiece\u201d visual en 3D de las vistas que componen la pantalla actual. Dicha opci\u00f3n est\u00e1 disponible en Debug > View Debugging .En modo texto podemos usar la propiedad recursiveDescription para imprimir la descripci\u00f3n textual de las vistas que contiene una vista dada. Propiedades de una vista \u00b6 A continuaci\u00f3n vamos a repasar las propiedades b\u00e1sicas de las vistas, que podremos modificar tanto desde Xcode como de forma program\u00e1tica. Disposici\u00f3n \u00b6 Entre las propiedades m\u00e1s importantes en las vistas encontramos aquellas referentes a su disposici\u00f3n en pantalla. Hemos visto que tanto cuando creamos la vista con Xcode como cuando la inicializamos de forma program\u00e1tica hay que especificar el marco que ocupar\u00e1 la vista en la pantalla. Cuando se crea de forma visual, el marco se puede definir pulsando con el rat\u00f3n sobre los m\u00e1rgenes de la vista y arrastrando para as\u00ed mover sus l\u00edmites. En el c\u00f3digo estos l\u00edmites se especifican mediante el tipo CGRect , en el que se especifica posici\u00f3n (x,y) de inicio, y el ancho y el alto que ocupa la vista. Estos datos se especifican en el sistema de coordenadas de la supervista. El sistema de coordenadas tiene su origen en la esquina superior izquierda. Las coordenadas no se dan en pixels , sino en puntos , una medida que nos permite independizarnos de la resoluci\u00f3n en pixels de la pantalla. Las coordenadas en puntos son reales, no enteras. En los modelos de iPhone/iPod Touch de 3.5\u2019\u2019 la resoluci\u00f3n de pantalla en puntos es de 320x480 (aun en los de retina display , que tiene un n\u00famero de pixels mucho mayor). Los dispositivos de 4\u2019\u2019 usan una resoluci\u00f3n de 320x568 puntos. El iPhone 6 devuelve 375x667 y el 6 plus 736x414. Pod\u00e9is consultar una tabla muy completa con muchos m\u00e1s datos Otros frameworks de iOS definen sistemas de coordenadas distintos. Los de gr\u00e1ficos (Core Graphics y OpenGL ES) ponen el origen en la esquina inferior izquierda con el eje Y apuntando hacia arriba. Algunos ejemplos de c\u00f3mo obtener la posici\u00f3n y dimensiones de una vista: 1 2 3 4 5 6 7 // Limites en coordenadas locales // Su origen siempre es (0,0) CGRect areaLocal = vista . bounds // Posici\u00f3n del centro de la vista en coordenadas de su supervista CGPoint centro = vista . center // Marco en coordenadas de la supervista CGRect marco = vista . frame N\u00f3tese que a partir de bounds y center podemos calcular frame , aunque nos lo da directamente el sistema Aqu\u00ed estamos usando tama\u00f1os fijos para las coordenadas de CGRect . Sin embargo, en la mayor\u00eda de ocasiones nos interesa que el tama\u00f1o de las vistas no sea fijo sino que se adapte al \u00e1rea disponible. De esta forma nuestra interfaz podr\u00eda adaptarse de forma sencilla a distintas orientaciones del dispositivo (horizontal o vertical) o a distintas resoluciones de la pantalla. Esto lo podemos conseguir mediante el uso del autolayout , que calcula de manera autom\u00e1tica el frame de cada vista bas\u00e1ndose en un conjunto de restricciones . Veremos esta tecnolog\u00eda en sesiones posteriores. Transformaciones \u00b6 Podemos tambi\u00e9n aplicar una transformaci\u00f3n a las vistas, mediante su propiedad transform . Por defecto las vistas tienen aplicada la transformaci\u00f3n identidad CGAffineTransform.identity . La transformaci\u00f3n se define mediante una matriz de transformaci\u00f3n 2D de dimensi\u00f3n 3x3. Podemos crear transformaciones sencillas (rotaciones, traslaciones o escalados \u201cpuros\u201d con las funciones CGAffineTransform(rotationAngle:) , CGAffineTransform(translationX:,y:) y CGAffineTransform(scaleX:,y:) . Si nuestra vista tiene aplicada una transformaci\u00f3n diferente a la identidad, su propiedad frame no ser\u00e1 significativa. En este caso s\u00f3lo deberemos utilizar center y bounds . Otras propiedades \u00b6 En las vistas encontramos otras propiedades que nos permiten determinar su color o su opacidad. En primer lugar tenemos backgroundColor , con la que podemos fijar el color de fondo de una vista. En el inspector de atributos (secci\u00f3n View ) podemos verlo como propiedad Background . El color de fondo puede ser transparente, o puede utilizarse como fondo un determinado patr\u00f3n basado en una imagen. De forma program\u00e1tica, el color se especifica mediante un objeto de clase UIColor . En esta clase podemos crear un color personalizado a partir de sus componentes (rojo, verde, azul, alpha), como en UIColor(red:,green:,blue:,alpha:) o con una constante predefinida (por ejemplo, UIColor.green ) Por otro lado, tambi\u00e9n podemos hacer que una vista tenga un cierto grado de transparencia, o est\u00e9 oculta. A diferencia de backgroundColor , que s\u00f3lo afecta al fondo de la vista, con la propiedad alpha , de tipo CGFloat , podemos controlar el nivel de transparencia de la vista completa con todo su contenido y sus subvistas. Si una vista no tiene transparencia, podemos poner su propiedad opaque a true para as\u00ed optimizar la forma de dibujarla. Esta propiedad s\u00f3lo debe establecerse a true si la vista llena todo su contendo y no deja ver nada del fondo. De no ser as\u00ed, el resultado es impredecible. Debemos llevar cuidado con esto, ya que por defecto dicha propiedad es true . Por \u00faltimo, tambi\u00e9n podemos ocultar una vista con la propiedad isHidden . Cuando hagamos que una vista se oculte, aunque seguir\u00e1 ocupando su correspondiente espacio en pantalla, no ser\u00e1 visible ni recibir\u00e1 eventos. Algunos componentes de interfaz de usuario \u00b6 A lo largo de los ejemplos que hemos ido haciendo en las sesiones anteriores ya hemos probado bastantes de los controles b\u00e1sicos de interfaz de usuario que nos proporciona iOS: botones, etiquetas, im\u00e1genes, campos de texto,\u2026 Vamos a ver aqu\u00ed algunas de las caracter\u00edsticas de los controles, aunque solo vamos a dar unas pinceladas, ya que una descripci\u00f3n exhaustiva de cada propiedad ser\u00eda imposible y tediosa. Se os recomienda consultar la documentaci\u00f3n de Apple, en concreto hay dos tipos de documentaci\u00f3n que os pueden resultar \u00fatiles: Desde el punto de vista del dise\u00f1o y la usabilidad, el documento llamado Interface Essentials . Desde el punto de vista de desarrollo pod\u00e9is consultar el apartado \"views and controls\" de la documentaci\u00f3n de UIKit , con la referencia del API y la forma de usar cada componente en nuestro c\u00f3digo. Aunque aqu\u00ed hablemos de controles indistintamente para referirnos a las etiquetas, botones, \u2026 en realidad este t\u00e9rmino tiene un significado m\u00e1s preciso en iOS. La clase UIControl es de la que heredan los controles m\u00e1s \u201cinteractivos\u201d como los botones, mientras que las etiquetas lo hacen de UIView (no obstante todos los UIControl son tambi\u00e9n vistas ya que a su vez esta clase hereda de UIView ). Campos de texto \u00b6 Un campo de texto nos proporciona un espacio donde el usuario puede introducir y editar texto. Se define en la clase UITextField , y pertenece a un grupo de vistas denominados controles, junto a otros componentes como por ejemplo los botones. Esto es as\u00ed porque permiten al usuario interactuar con la aplicaci\u00f3n. No heredan directamente de UIView , sino de su subclase UIControl , que incorpora los m\u00e9todos para tratar eventos de la interfaz mediante el patr\u00f3n target-action como hemos visto anteriormente. Sus propiedades se pueden encontrar en la secci\u00f3n Text Field del inspector de atributos. Podremos especificar un texto por defecto ( Text ), o bien un texto a mostrar sombreado en caso de que el usuario no haya introducido nada ( Placeholder Text ). Esto ser\u00e1 \u00fatil por ejemplo para dar una pista al usuario sobre lo que debe introducir en dicho campo. Si nos fijamos en el inspector de conexiones del campos de texto, veremos la lista de eventos que podemos conectar a nuestra acciones. Esta lista de eventos es com\u00fan para cualquier control. En el caso de un campo de texto por ejemplo nos puede interesar el evento Value Changed . Teclado en pantalla Cuando un campo de texto adquiere el foco porque el usuario hace tap sobre \u00e9l, autom\u00e1ticamente aparece el teclado software on screen . El problema es que por defecto no desaparece salvo que escribamos algo de c\u00f3digo. Si queremos que desaparezca cuando pulsamos sobre la tecla de \u201cAceptar\u201d tenemos que escribir un action que responda al evento Did end on exit del campo de texto. Cuando crees el action indica en el men\u00fa popup que el type debe ser UITextField . Esta opci\u00f3n es el par\u00e1metro que se le pasar\u00e1 al action y representa el objeto que ha disparado el evento, en nuestro caso el campo de texto. Si lo pasamos como AnyObject no tendremos acceso a los m\u00e9todos del API de UITextField (salvo que hici\u00e9ramos una conversi\u00f3n con as ) En teor\u00eda dentro de este action debemos hacer que el campo deje de ser el objeto que hace de first responder para que el teclado deje de mostrarse El first responder es el objeto que recibe en primer lugar ciertas clases de eventos, por ejemplo los de teclado o movimiento. Cuando hacemos tap sobre un campo de texto, iOS hace que este pase a ser el first responder 1 2 3 @IBAction func introPulsado ( _ sender : UITextField ) { sender . resignFirstResponder () } Aunque en muchas fuentes (libros, tutoriales en web, \u2026) aparece el m\u00e9todo del resignFirstResponder , curiosamente parece bastar con tener un action que responda al Did end on exit , aunque no haga nada para ocultar el teclado.* Por desgracia, no todos los tipos de teclado en pantalla tienen un bot\u00f3n de \u201cintro\u201d y por tanto no disparan el evento Did end on exit , por ejemplo el teclado num\u00e9rico no lo hace. En ese caso hay que usar una soluci\u00f3n algo m\u00e1s rebuscada. Por ejemplo, es muy t\u00edpico que al pulsar sobre cualquier parte de la pantalla que no sea el campo el teclado se oculte. Esto podemos conseguirlo detectando el evento de toque sobre la vista. Si un evento no se procesa en los componentes de la vista va \u201csubiendo\u201d en la jerarqu\u00eda hasta llegar al view controller , por lo que en \u00e9l podr\u00edamos hacer esto (no es necesario crear un action , ya que el evento no va a ir directamente al controller , solo escribir el c\u00f3digo): 1 2 3 4 override func touchesEnded ( _ touches : Set < UITouch >, with : UIEvent ?) { print ( \"\u00a1touch en la pantalla!\" ) self . view . viewWithTag ( 100 )?. resignFirstResponder () } Botones \u00b6 Al igual que los campos de texto, los botones son otro tipo de control (heredan de UIControl ). Se definen en la clase UIButton , que puede ser inicializada de la misma forma que el resto de vistas. Si nos fijamos en el inspector de atributos de un bot\u00f3n (en la secci\u00f3n Button ), vemos que podemos elegir el tipo de bot\u00f3n (atributo Type ). Podemos seleccionar una serie de estilos prefedinidos para los botones, o bien darle un estilo propio ( Custom ). El texto que aparece en el bot\u00f3n se especifica en la propiedad Title , y podemos configurar tambi\u00e9n su color, sombreado, o a\u00f1adir una imagen como icono. En el inspector de conexiones, el evento que utilizaremos m\u00e1s com\u00fanmente en los botones es Touch Up Inside , que se producir\u00e1 cuando levantemos el dedo tras pulsar dentro del bot\u00f3n. Este ser\u00e1 el momento en el que se realizar\u00e1 la acci\u00f3n asociada al bot\u00f3n. Alertas y action sheets \u00b6 Son cuadros de di\u00e1logo modales que se usan para informar al usuario de eventos importantes. No se crean gr\u00e1ficamente en Xcode sino por c\u00f3digo Pueden simplemente informar de algo o adem\u00e1s pedir al usuario que elija uno entre varios cursos de acci\u00f3n. Vamos a ver primero c\u00f3mo crear una alerta . En realidad el API para alertas y action sheets es el mismo, solo se diferencian en una constante que se le pasa al inicializador. Luego veremos las diferencias en cuanto a su significado de cara al usuario. Por ejemplo veamos c\u00f3mo se mostrar\u00eda una alerta con dos opciones 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //El alert en s\u00ed. Vemos que el preferredStyle es .alert let alert = UIAlertController ( title : \"\u00a1Elige!\" , message : \"Tienes que elegir uno de estos dos\" , preferredStyle : . alert ) //cada opci\u00f3n es un UIAlertAction let susto = UIAlertAction ( title : \"Susto\" , style : . cancel ) { action in print ( \"BU!!! haber elegido muerte!\" ) } let muerte = UIAlertAction ( title : \"Muerte\" , style : . default ) { action in print ( \"Aqu\u00ed se acaba todo\" ) } //A\u00f1adimos las opciones al cuadro de di\u00e1logo alert . addAction ( susto ) alert . addAction ( muerte ) //Mostramos el alert con present, como se hace con cualquier controller self . present ( alert , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del alert\" ) } Podemos tener el n\u00famero de botones que queramos. No obstante, las \u201ciOS Human Interface Guidelines\u201d recomiendan como m\u00e1ximo dos , y en caso que necesitemos m\u00e1s usar un \u201cAction Sheet\u201d . Por otro lado un action sheet es un cuadro de di\u00e1logo que se usa para dar alternativas al usuario cuando ha realizado una acci\u00f3n. Por ejemplo supongamos un gestor de email en el que el usuario ha hecho tap sobre un mensaje. Podr\u00eda aparecer la siguiente action sheet El API es exactamente el mismo, solo que en el inicializador de UIAlertController se pasa como par\u00e1metro preferredStyle el valor actionSheet . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let actionSheet = UIAlertController ( title : \"Opciones\" , message : \"Seleccione la opci\u00f3n\" , preferredStyle : . actionSheet ) let archivar = UIAlertAction ( title : \"Archivar\" , style : . default ){ action in print ( \"Aqu\u00ed se archivar\u00eda el mensaje\" ) } let eliminar = UIAlertAction ( title : \"Eliminar\" , style : . destructive ) { action in print ( \"Aqu\u00ed se eliminar\u00eda el mensaje\" ) } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in print ( \"Aqu\u00ed no se har\u00eda nada\" ) } actionSheet . addAction ( archivar ) actionSheet . addAction ( eliminar ) actionSheet . addAction ( cancelar ) self . present ( actionSheet , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del action sheet\" ) } Pickers \u00b6 Nos permiten elegir uno de entre una lista de valores, usando la met\u00e1fora visual de la t\u00edpica rueda que se gira para seleccionar el valor deseado. En el API se corresponden con la clase UIPickerView . Comparados con la mayor\u00eda de los otros controles son bastante m\u00e1s complejos, ya que un picker necesita de la ayuda de dos delegates (dos objetos que sean conformes a ciertos protocolos): Un delegate (protocolo UIPickerViewDelegate ): gestiona el comportamiento general del picker Un datasource (protocolo UIPickerViewDataSource ): gestiona el \"modelo de datos\": cu\u00e1ntas filas y columnas tiene Estos dos protocolos heredan de NSObjectProtocol , con lo que los objetos conformes a ellos deben ser conformes tambi\u00e9n a este \u00faltimo (esto se puede conseguir de modo sencillo haciendo que la clase herede de NSObject , ya que esta clase es conforme a este protocolo). Por ejemplo supongamos una clase GestorPicker que para hacer el c\u00f3digo m\u00e1s compacto va a hacer tanto de delegate como de datasource : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] //METODOS DE UIPickerViewDatasource //n\u00famero de \"columnas\" del Picker func numberOfComponents ( in pickerView : UIPickerView ) -> Int { return 1 } //n\u00famero de \"filas\" func pickerView ( _ pickerView : UIPickerView , numberOfRowsInComponent component : Int ) -> Int { return lista . count } //METODOS DE UIPickerViewDelegate func pickerView ( _ pickerView : UIPickerView , titleForRow row : Int , forComponent component : Int ) -> String ? { return lista [ row ] } } En el view controller de la pantalla con el picker definir\u00edamos una instancia de GestorPicker 1 let gestorPicker = GestorPicker () Crear\u00edamos un outlet que represente al picker con Ctrl+Arrastrar 1 @IBOutlet weak var miPicker : UIPickerView ! Y finalmente dentro del viewDidLoad \"enlazar\u00edamos\" el picker con su datasource y su delegate , que en este caso son el mismo objeto. 1 2 self . miPicker . delegate = self . gestorPicker self . miPicker . dataSource = self . gestorPicker Los m\u00e9todos anteriores nos permiten pintar el picker , pero adem\u00e1s nos interesar\u00e1 saber qu\u00e9 opci\u00f3n est\u00e1 seleccionada. En cualquier momento podemos obtener el n\u00famero de fila seleccionado en el picker con 1 2 //Cambiar el 0 por la \"columna\" que queramos self . miPicker . selectedRow ( inComponent : 0 ) Adem\u00e1s si nos interesa podemos ser avisados en el momento en que el usuario seleccione una opci\u00f3n. Cuando se produzca ese evento, el objeto que act\u00fae de delegate del picker recibir\u00e1 una llamada a su m\u00e9todo pickerView(_:,didSelectRow:,inComponent:) : 1 2 3 4 5 6 7 8 class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] ... func pickerView ( _ pickerView : UIPickerView , didSelectRow row : Int , inComponent component : Int ) { print ( \"Seleccionada fila: \\( row ) , dato: \\( lista [ row ] ) \" ) } ... } Otros controles ( sliders , switches , date pickers ) \u00b6 Estos controles son muy heterog\u00e9neos, pero todos tienen en com\u00fan que tienen un valor asociado y que este valor puede cambiar debido a las acciones del usuario. El tipo del valor y la(s) propiedade(s) para acceder a \u00e9l ser\u00e1n muy distintas seg\u00fan el tipo de control, por ejemplo: Un UISwitch es booleano y se sabe si est\u00e1 a \"on\" con isOn Un UISlider tiene un valor Float y se accede a \u00e9l con la propiedad value Un UIDatePicker tiene una fecha y se accede a ella con la propiedad date Pero en todos se usa la misma idea, implementar un action vinculado al evento de cambio del valor de modo que en su c\u00f3digo podamos acceder al valor actual. Por ejemplo para un slider tendr\u00edamos algo como 1 2 3 4 5 6 //Este m\u00e9todo se ha creado con el \"assistant editor\" y Ctrl+Arrastrar //de la ventana del storyboard al editor con el c\u00f3digo del view controller //Elegimos Connection \"action\" y type \"UISlider\" @IBAction func cambiaSlider ( _ sender : UISlider ) { print ( \"El valor es: \\( sender . value ) \" ) } Es importante que al crear el action , si lo hacemos gr\u00e1ficamente con Ctrl+Arrastrar, en el popup de opciones elijamos como tipo UISlider (o en general, el tipo del control en cuesti\u00f3n). As\u00ed el par\u00e1metro sender que representa el objeto que ha generado el evento tendr\u00e1 el tipo adecuado y no necesitaremos hacer un cast para acceder a la propiedad deseada, como pasar\u00eda si lo dejamos con tipo Any .","title":"Vistas"},{"location":"2_vistas/apuntes/#sesion-2-vistas","text":"","title":"Sesi\u00f3n 2: Vistas"},{"location":"2_vistas/apuntes/#interaccion-con-la-interfaz-por-codigo","text":"Hasta ahora hemos visto como crear la interfaz visualmente con Xcode, mediante storyboards o NIBs, pero todo lo que se puede hacer con dicha herramienta se puede hacer tambi\u00e9n de forma program\u00e1tica, ya que lo \u00fanico que hace el entorno es crear objetos de la API de Cocoa Touch (o definidos por nosotros) y establecer visualmente sus propiedades.","title":"Interacci\u00f3n con la interfaz por c\u00f3digo"},{"location":"2_vistas/apuntes/#ventanas","text":"Las aplicaciones iOS en principio tienen una \u00fanica ventana, que es la propiedad window del Application Delegate . Esta ventana la instancia y gestiona de forma autom\u00e1tica el delegate , as\u00ed que no tenemos que hacer nada al respecto. Solo en caso de no usar storyboards tendr\u00edamos que instanciar el controller a mostrar y asign\u00e1rselo a la propiedad rootView del objeto window . El application delegate es el objeto que gestiona la ventana principal de la aplicaci\u00f3n. Adem\u00e1s de esto, tambi\u00e9n gestiona el ciclo de vida de la aplicaci\u00f3n. Recibe los eventos correspondientes a cuando la aplicaci\u00f3n arranca, cuando se sale de ella, cuando pasa a segundo plano, etc. Es la clase AppDelegate que crea autom\u00e1ticamente la plantilla de Xcode para cualquier aplicaci\u00f3n nueva. En aplicaciones que usen una pantalla externa ( external display ) s\u00ed necesitaremos crear una ventana de las dimensiones apropiadas 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Contamos cu\u00e1ntas pantallas hay (principal + externas) let screens = UIScreen . screens if screens . count > 1 { //cogemos \"a pi\u00f1\u00f3n\" la primera externa let extScreen = screens [ 1 ] //creamos una ventana con el mismo tama\u00f1o que la pantalla externa let extWindow = UIWindow ( frame : extScreen . bounds ) //asignamos la ventana a la pantalla extWindow . screen = extScreen //desde iOS9 todas las ventanas deben tener un controller //aqu\u00ed suponemos definida en alg\u00fan lugar su clase let extController = ViewControllerSecundario () //hacemos que la ventana tenga como controller principal el creado extWindow . rootViewController = extController //mostramos la ventana extWindow . isHidden = false }","title":"Ventanas"},{"location":"2_vistas/apuntes/#vistas","text":"En el ejemplo anterior hemos supuesto que ten\u00edamos una clase ViewControllerSecundario que us\u00e1bamos para mostrar la vista externa. Vamos a ver paso a paso c\u00f3mo construir\u00edamos esa clase si no quisi\u00e9ramos emplear un NIB o un storyboard . Podemos construir una vista creando un objeto de tipo UIView . En el inicializador deberemos proporcionar el marco que ocupar\u00e1 dicha vista. El marco se define mediante el tipo CGRect (se trata de una estructura, no de un objeto). Por ejemplo, podr\u00edamos inicializar una vista de la siguiente forma: 1 var vista = UIView ( frame : CGRect ( x : 0 , y : 0 , width : 100 , height : 100 )) En lugar de poner un tama\u00f1o fijo deber\u00edamos usar el de la pantalla en la que queramos que aparezca. Se puede obtener el CGRect con los l\u00edmites de la pantalla en la propiedad bounds del objeto UIScreen que nos interese. En los siguientes apartados explicaremos el sistema de coordenadas usado en CGRect Las vistas ( UIView ) tambi\u00e9n nos proporcionan una serie de m\u00e9todos para consultar y modificar la jerarqu\u00eda. El m\u00e9todo b\u00e1sico que necesitaremos es addSubview , que nos permitir\u00e1 a\u00f1adir una subvista a una vista determinada (o a una ventana): 1 2 3 var label = UILabel () label . text = \"Soy la pantalla secundaria\" vista . addSubView ( label ) En el controlador debemos sobreescribir el m\u00e9todo loadView del controlador, que es el m\u00e9todo encargado por defecto de crear las vistas (usualmente desde un NIB o storyboard , aqu\u00ed por c\u00f3digo), y en \u00e9l crear las vistas necesarias, asignando la vista ra\u00edz a self.view . 1 2 3 4 5 6 7 8 9 10 //m\u00e9todo del controlador de la pantalla secundaria override func loadView () { let vista = UIView ( frame : self . screen . bounds ) vista . backgroundColor = UIColor . green let label = UILabel () label . text = \"soy la pantalla secundaria\" label . frame = CGRect ( x : 0 , y : 0 , width : 200 , height : 100 ) vista . addSubView ( label ) self . view = vista } Podemos eliminar una vista envi\u00e1ndole el mensaje removeFromSuperview (se le env\u00eda a la vista hija que queremos eliminar). Podemos tambi\u00e9n consultar la jerarqu\u00eda con los siguientes m\u00e9todos: superview : Nos da la vista padre de la vista destinataria del mensaje. subviews : Nos da la lista de subvistas de una vista dada. isDescendantOfView: Comprueba si una vista es descendiente de otra. Como vemos, una vista tiene una lista de vistas hijas. Cada vista hija tiene un \u00edndice, que determinar\u00e1 el orden en el que se dibujan. El \u00edndice 0 es el m\u00e1s cercano al observador, y por lo tanto tapar\u00e1 a los \u00edndices superiores. Podemos insertar una vista en un \u00edndice determinado de la lista de subvistas con insertSubview:atIndex: . Puede que tengamos una jerarqu\u00eda compleja y necesitemos acceder desde el c\u00f3digo a una determinada vista por ejemplo para inicializar su valor. Una opci\u00f3n es hacer un outlet para cada vista que queramos modificar, pero esto podr\u00eda sobrecargar nuestro objeto de outlets . Tambi\u00e9n puede ser complejo y poco fiable el buscar la vista en la jerarqu\u00eda. En estos casos, lo m\u00e1s sencillo es darle a las vistas que buscamos una etiqueta ( tag ) mediante la propiedad Tag del inspector de atributos (debe ser un valor entero), o asignando la propiedad tag de forma program\u00e1tica. Podremos localizar en nuestro c\u00f3digo una vista a partir de su etiqueta mediante viewWithTag . Llamando a este m\u00e9todo sobre una vista, buscar\u00e1 entre todas las subvistas aquella con la etiqueta indicada: 1 texto = self . window . viewWithTag ( tag : 1 ) La jerarqu\u00eda de vistas de una pantalla determinada de nuestra aplicaci\u00f3n puede llegar a ser muy compleja. Es por eso que en Xcode 6 se ha a\u00f1adido una opci\u00f3n que nos permite mostrar un \u201cdespiece\u201d visual en 3D de las vistas que componen la pantalla actual. Dicha opci\u00f3n est\u00e1 disponible en Debug > View Debugging .En modo texto podemos usar la propiedad recursiveDescription para imprimir la descripci\u00f3n textual de las vistas que contiene una vista dada.","title":"Vistas"},{"location":"2_vistas/apuntes/#propiedades-de-una-vista","text":"A continuaci\u00f3n vamos a repasar las propiedades b\u00e1sicas de las vistas, que podremos modificar tanto desde Xcode como de forma program\u00e1tica.","title":"Propiedades de una vista"},{"location":"2_vistas/apuntes/#disposicion","text":"Entre las propiedades m\u00e1s importantes en las vistas encontramos aquellas referentes a su disposici\u00f3n en pantalla. Hemos visto que tanto cuando creamos la vista con Xcode como cuando la inicializamos de forma program\u00e1tica hay que especificar el marco que ocupar\u00e1 la vista en la pantalla. Cuando se crea de forma visual, el marco se puede definir pulsando con el rat\u00f3n sobre los m\u00e1rgenes de la vista y arrastrando para as\u00ed mover sus l\u00edmites. En el c\u00f3digo estos l\u00edmites se especifican mediante el tipo CGRect , en el que se especifica posici\u00f3n (x,y) de inicio, y el ancho y el alto que ocupa la vista. Estos datos se especifican en el sistema de coordenadas de la supervista. El sistema de coordenadas tiene su origen en la esquina superior izquierda. Las coordenadas no se dan en pixels , sino en puntos , una medida que nos permite independizarnos de la resoluci\u00f3n en pixels de la pantalla. Las coordenadas en puntos son reales, no enteras. En los modelos de iPhone/iPod Touch de 3.5\u2019\u2019 la resoluci\u00f3n de pantalla en puntos es de 320x480 (aun en los de retina display , que tiene un n\u00famero de pixels mucho mayor). Los dispositivos de 4\u2019\u2019 usan una resoluci\u00f3n de 320x568 puntos. El iPhone 6 devuelve 375x667 y el 6 plus 736x414. Pod\u00e9is consultar una tabla muy completa con muchos m\u00e1s datos Otros frameworks de iOS definen sistemas de coordenadas distintos. Los de gr\u00e1ficos (Core Graphics y OpenGL ES) ponen el origen en la esquina inferior izquierda con el eje Y apuntando hacia arriba. Algunos ejemplos de c\u00f3mo obtener la posici\u00f3n y dimensiones de una vista: 1 2 3 4 5 6 7 // Limites en coordenadas locales // Su origen siempre es (0,0) CGRect areaLocal = vista . bounds // Posici\u00f3n del centro de la vista en coordenadas de su supervista CGPoint centro = vista . center // Marco en coordenadas de la supervista CGRect marco = vista . frame N\u00f3tese que a partir de bounds y center podemos calcular frame , aunque nos lo da directamente el sistema Aqu\u00ed estamos usando tama\u00f1os fijos para las coordenadas de CGRect . Sin embargo, en la mayor\u00eda de ocasiones nos interesa que el tama\u00f1o de las vistas no sea fijo sino que se adapte al \u00e1rea disponible. De esta forma nuestra interfaz podr\u00eda adaptarse de forma sencilla a distintas orientaciones del dispositivo (horizontal o vertical) o a distintas resoluciones de la pantalla. Esto lo podemos conseguir mediante el uso del autolayout , que calcula de manera autom\u00e1tica el frame de cada vista bas\u00e1ndose en un conjunto de restricciones . Veremos esta tecnolog\u00eda en sesiones posteriores.","title":"Disposici\u00f3n"},{"location":"2_vistas/apuntes/#transformaciones","text":"Podemos tambi\u00e9n aplicar una transformaci\u00f3n a las vistas, mediante su propiedad transform . Por defecto las vistas tienen aplicada la transformaci\u00f3n identidad CGAffineTransform.identity . La transformaci\u00f3n se define mediante una matriz de transformaci\u00f3n 2D de dimensi\u00f3n 3x3. Podemos crear transformaciones sencillas (rotaciones, traslaciones o escalados \u201cpuros\u201d con las funciones CGAffineTransform(rotationAngle:) , CGAffineTransform(translationX:,y:) y CGAffineTransform(scaleX:,y:) . Si nuestra vista tiene aplicada una transformaci\u00f3n diferente a la identidad, su propiedad frame no ser\u00e1 significativa. En este caso s\u00f3lo deberemos utilizar center y bounds .","title":"Transformaciones"},{"location":"2_vistas/apuntes/#otras-propiedades","text":"En las vistas encontramos otras propiedades que nos permiten determinar su color o su opacidad. En primer lugar tenemos backgroundColor , con la que podemos fijar el color de fondo de una vista. En el inspector de atributos (secci\u00f3n View ) podemos verlo como propiedad Background . El color de fondo puede ser transparente, o puede utilizarse como fondo un determinado patr\u00f3n basado en una imagen. De forma program\u00e1tica, el color se especifica mediante un objeto de clase UIColor . En esta clase podemos crear un color personalizado a partir de sus componentes (rojo, verde, azul, alpha), como en UIColor(red:,green:,blue:,alpha:) o con una constante predefinida (por ejemplo, UIColor.green ) Por otro lado, tambi\u00e9n podemos hacer que una vista tenga un cierto grado de transparencia, o est\u00e9 oculta. A diferencia de backgroundColor , que s\u00f3lo afecta al fondo de la vista, con la propiedad alpha , de tipo CGFloat , podemos controlar el nivel de transparencia de la vista completa con todo su contenido y sus subvistas. Si una vista no tiene transparencia, podemos poner su propiedad opaque a true para as\u00ed optimizar la forma de dibujarla. Esta propiedad s\u00f3lo debe establecerse a true si la vista llena todo su contendo y no deja ver nada del fondo. De no ser as\u00ed, el resultado es impredecible. Debemos llevar cuidado con esto, ya que por defecto dicha propiedad es true . Por \u00faltimo, tambi\u00e9n podemos ocultar una vista con la propiedad isHidden . Cuando hagamos que una vista se oculte, aunque seguir\u00e1 ocupando su correspondiente espacio en pantalla, no ser\u00e1 visible ni recibir\u00e1 eventos.","title":"Otras propiedades"},{"location":"2_vistas/apuntes/#algunos-componentes-de-interfaz-de-usuario","text":"A lo largo de los ejemplos que hemos ido haciendo en las sesiones anteriores ya hemos probado bastantes de los controles b\u00e1sicos de interfaz de usuario que nos proporciona iOS: botones, etiquetas, im\u00e1genes, campos de texto,\u2026 Vamos a ver aqu\u00ed algunas de las caracter\u00edsticas de los controles, aunque solo vamos a dar unas pinceladas, ya que una descripci\u00f3n exhaustiva de cada propiedad ser\u00eda imposible y tediosa. Se os recomienda consultar la documentaci\u00f3n de Apple, en concreto hay dos tipos de documentaci\u00f3n que os pueden resultar \u00fatiles: Desde el punto de vista del dise\u00f1o y la usabilidad, el documento llamado Interface Essentials . Desde el punto de vista de desarrollo pod\u00e9is consultar el apartado \"views and controls\" de la documentaci\u00f3n de UIKit , con la referencia del API y la forma de usar cada componente en nuestro c\u00f3digo. Aunque aqu\u00ed hablemos de controles indistintamente para referirnos a las etiquetas, botones, \u2026 en realidad este t\u00e9rmino tiene un significado m\u00e1s preciso en iOS. La clase UIControl es de la que heredan los controles m\u00e1s \u201cinteractivos\u201d como los botones, mientras que las etiquetas lo hacen de UIView (no obstante todos los UIControl son tambi\u00e9n vistas ya que a su vez esta clase hereda de UIView ).","title":"Algunos componentes de interfaz de usuario"},{"location":"2_vistas/apuntes/#campos-de-texto","text":"Un campo de texto nos proporciona un espacio donde el usuario puede introducir y editar texto. Se define en la clase UITextField , y pertenece a un grupo de vistas denominados controles, junto a otros componentes como por ejemplo los botones. Esto es as\u00ed porque permiten al usuario interactuar con la aplicaci\u00f3n. No heredan directamente de UIView , sino de su subclase UIControl , que incorpora los m\u00e9todos para tratar eventos de la interfaz mediante el patr\u00f3n target-action como hemos visto anteriormente. Sus propiedades se pueden encontrar en la secci\u00f3n Text Field del inspector de atributos. Podremos especificar un texto por defecto ( Text ), o bien un texto a mostrar sombreado en caso de que el usuario no haya introducido nada ( Placeholder Text ). Esto ser\u00e1 \u00fatil por ejemplo para dar una pista al usuario sobre lo que debe introducir en dicho campo. Si nos fijamos en el inspector de conexiones del campos de texto, veremos la lista de eventos que podemos conectar a nuestra acciones. Esta lista de eventos es com\u00fan para cualquier control. En el caso de un campo de texto por ejemplo nos puede interesar el evento Value Changed .","title":"Campos de texto"},{"location":"2_vistas/apuntes/#botones","text":"Al igual que los campos de texto, los botones son otro tipo de control (heredan de UIControl ). Se definen en la clase UIButton , que puede ser inicializada de la misma forma que el resto de vistas. Si nos fijamos en el inspector de atributos de un bot\u00f3n (en la secci\u00f3n Button ), vemos que podemos elegir el tipo de bot\u00f3n (atributo Type ). Podemos seleccionar una serie de estilos prefedinidos para los botones, o bien darle un estilo propio ( Custom ). El texto que aparece en el bot\u00f3n se especifica en la propiedad Title , y podemos configurar tambi\u00e9n su color, sombreado, o a\u00f1adir una imagen como icono. En el inspector de conexiones, el evento que utilizaremos m\u00e1s com\u00fanmente en los botones es Touch Up Inside , que se producir\u00e1 cuando levantemos el dedo tras pulsar dentro del bot\u00f3n. Este ser\u00e1 el momento en el que se realizar\u00e1 la acci\u00f3n asociada al bot\u00f3n.","title":"Botones"},{"location":"2_vistas/apuntes/#alertas-y-action-sheets","text":"Son cuadros de di\u00e1logo modales que se usan para informar al usuario de eventos importantes. No se crean gr\u00e1ficamente en Xcode sino por c\u00f3digo Pueden simplemente informar de algo o adem\u00e1s pedir al usuario que elija uno entre varios cursos de acci\u00f3n. Vamos a ver primero c\u00f3mo crear una alerta . En realidad el API para alertas y action sheets es el mismo, solo se diferencian en una constante que se le pasa al inicializador. Luego veremos las diferencias en cuanto a su significado de cara al usuario. Por ejemplo veamos c\u00f3mo se mostrar\u00eda una alerta con dos opciones 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //El alert en s\u00ed. Vemos que el preferredStyle es .alert let alert = UIAlertController ( title : \"\u00a1Elige!\" , message : \"Tienes que elegir uno de estos dos\" , preferredStyle : . alert ) //cada opci\u00f3n es un UIAlertAction let susto = UIAlertAction ( title : \"Susto\" , style : . cancel ) { action in print ( \"BU!!! haber elegido muerte!\" ) } let muerte = UIAlertAction ( title : \"Muerte\" , style : . default ) { action in print ( \"Aqu\u00ed se acaba todo\" ) } //A\u00f1adimos las opciones al cuadro de di\u00e1logo alert . addAction ( susto ) alert . addAction ( muerte ) //Mostramos el alert con present, como se hace con cualquier controller self . present ( alert , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del alert\" ) } Podemos tener el n\u00famero de botones que queramos. No obstante, las \u201ciOS Human Interface Guidelines\u201d recomiendan como m\u00e1ximo dos , y en caso que necesitemos m\u00e1s usar un \u201cAction Sheet\u201d . Por otro lado un action sheet es un cuadro de di\u00e1logo que se usa para dar alternativas al usuario cuando ha realizado una acci\u00f3n. Por ejemplo supongamos un gestor de email en el que el usuario ha hecho tap sobre un mensaje. Podr\u00eda aparecer la siguiente action sheet El API es exactamente el mismo, solo que en el inicializador de UIAlertController se pasa como par\u00e1metro preferredStyle el valor actionSheet . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let actionSheet = UIAlertController ( title : \"Opciones\" , message : \"Seleccione la opci\u00f3n\" , preferredStyle : . actionSheet ) let archivar = UIAlertAction ( title : \"Archivar\" , style : . default ){ action in print ( \"Aqu\u00ed se archivar\u00eda el mensaje\" ) } let eliminar = UIAlertAction ( title : \"Eliminar\" , style : . destructive ) { action in print ( \"Aqu\u00ed se eliminar\u00eda el mensaje\" ) } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in print ( \"Aqu\u00ed no se har\u00eda nada\" ) } actionSheet . addAction ( archivar ) actionSheet . addAction ( eliminar ) actionSheet . addAction ( cancelar ) self . present ( actionSheet , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del action sheet\" ) }","title":"Alertas y action sheets"},{"location":"2_vistas/apuntes/#pickers","text":"Nos permiten elegir uno de entre una lista de valores, usando la met\u00e1fora visual de la t\u00edpica rueda que se gira para seleccionar el valor deseado. En el API se corresponden con la clase UIPickerView . Comparados con la mayor\u00eda de los otros controles son bastante m\u00e1s complejos, ya que un picker necesita de la ayuda de dos delegates (dos objetos que sean conformes a ciertos protocolos): Un delegate (protocolo UIPickerViewDelegate ): gestiona el comportamiento general del picker Un datasource (protocolo UIPickerViewDataSource ): gestiona el \"modelo de datos\": cu\u00e1ntas filas y columnas tiene Estos dos protocolos heredan de NSObjectProtocol , con lo que los objetos conformes a ellos deben ser conformes tambi\u00e9n a este \u00faltimo (esto se puede conseguir de modo sencillo haciendo que la clase herede de NSObject , ya que esta clase es conforme a este protocolo). Por ejemplo supongamos una clase GestorPicker que para hacer el c\u00f3digo m\u00e1s compacto va a hacer tanto de delegate como de datasource : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] //METODOS DE UIPickerViewDatasource //n\u00famero de \"columnas\" del Picker func numberOfComponents ( in pickerView : UIPickerView ) -> Int { return 1 } //n\u00famero de \"filas\" func pickerView ( _ pickerView : UIPickerView , numberOfRowsInComponent component : Int ) -> Int { return lista . count } //METODOS DE UIPickerViewDelegate func pickerView ( _ pickerView : UIPickerView , titleForRow row : Int , forComponent component : Int ) -> String ? { return lista [ row ] } } En el view controller de la pantalla con el picker definir\u00edamos una instancia de GestorPicker 1 let gestorPicker = GestorPicker () Crear\u00edamos un outlet que represente al picker con Ctrl+Arrastrar 1 @IBOutlet weak var miPicker : UIPickerView ! Y finalmente dentro del viewDidLoad \"enlazar\u00edamos\" el picker con su datasource y su delegate , que en este caso son el mismo objeto. 1 2 self . miPicker . delegate = self . gestorPicker self . miPicker . dataSource = self . gestorPicker Los m\u00e9todos anteriores nos permiten pintar el picker , pero adem\u00e1s nos interesar\u00e1 saber qu\u00e9 opci\u00f3n est\u00e1 seleccionada. En cualquier momento podemos obtener el n\u00famero de fila seleccionado en el picker con 1 2 //Cambiar el 0 por la \"columna\" que queramos self . miPicker . selectedRow ( inComponent : 0 ) Adem\u00e1s si nos interesa podemos ser avisados en el momento en que el usuario seleccione una opci\u00f3n. Cuando se produzca ese evento, el objeto que act\u00fae de delegate del picker recibir\u00e1 una llamada a su m\u00e9todo pickerView(_:,didSelectRow:,inComponent:) : 1 2 3 4 5 6 7 8 class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] ... func pickerView ( _ pickerView : UIPickerView , didSelectRow row : Int , inComponent component : Int ) { print ( \"Seleccionada fila: \\( row ) , dato: \\( lista [ row ] ) \" ) } ... }","title":"Pickers"},{"location":"2_vistas/apuntes/#otros-controles-sliders-switches-date-pickers","text":"Estos controles son muy heterog\u00e9neos, pero todos tienen en com\u00fan que tienen un valor asociado y que este valor puede cambiar debido a las acciones del usuario. El tipo del valor y la(s) propiedade(s) para acceder a \u00e9l ser\u00e1n muy distintas seg\u00fan el tipo de control, por ejemplo: Un UISwitch es booleano y se sabe si est\u00e1 a \"on\" con isOn Un UISlider tiene un valor Float y se accede a \u00e9l con la propiedad value Un UIDatePicker tiene una fecha y se accede a ella con la propiedad date Pero en todos se usa la misma idea, implementar un action vinculado al evento de cambio del valor de modo que en su c\u00f3digo podamos acceder al valor actual. Por ejemplo para un slider tendr\u00edamos algo como 1 2 3 4 5 6 //Este m\u00e9todo se ha creado con el \"assistant editor\" y Ctrl+Arrastrar //de la ventana del storyboard al editor con el c\u00f3digo del view controller //Elegimos Connection \"action\" y type \"UISlider\" @IBAction func cambiaSlider ( _ sender : UISlider ) { print ( \"El valor es: \\( sender . value ) \" ) } Es importante que al crear el action , si lo hacemos gr\u00e1ficamente con Ctrl+Arrastrar, en el popup de opciones elijamos como tipo UISlider (o en general, el tipo del control en cuesti\u00f3n). As\u00ed el par\u00e1metro sender que representa el objeto que ha generado el evento tendr\u00e1 el tipo adecuado y no necesitaremos hacer un cast para acceder a la propiedad deseada, como pasar\u00eda si lo dejamos con tipo Any .","title":"Otros controles (sliders, switches, date pickers)"},{"location":"2_vistas/ejercicios/","text":"Ejercicio de vistas en iOS: controles b\u00e1sicos (2,5 puntos) \u00b6 El objetivo es practicar con los controles b\u00e1sicos de la interfaz de usuario en iOS creando un \"panel de control\" ficticio para una supuesta nave espacial al estilo del que aparece en la figura. Puedes ayudarte de la documentaci\u00f3n de referencia de UIKit para ver los m\u00e9todos y propiedades de los componentes: (0,25 puntos) Campo de texto: Al escribir en \u00e9l y pulsar intro en el teclado onscreen ,debe concatenarse lo escrito al campo de texto de varias l\u00edneas (un text view ) Si quieres que aparezca el teclado onscreen en el simulador debes desactivar la opci\u00f3n de men\u00fa de Hardware > Keyboard > Connect Hardware Keyboard , ya que si est\u00e1 activada se usar\u00e1 el teclado f\u00edsico del Mac pero no aparecer\u00e1 el teclado en pantalla. (0,5 puntos) Slider : Debes fijar el valor inicial en 0 y el final en 100 (son propiedades del objeto). F\u00edjalas por c\u00f3digo en el viewDidLoad del controller, consulta la documentaci\u00f3n para ver el nombre. Necesitar\u00e1s un outlet para acceder al slider y poder cambiar sus propiedades por c\u00f3digo. Al cambiar su valor debe aparecer en un label al lado cu\u00e1l es el valor actual. Al igual que los botones, para procesar un cambio en un slider puedes crear un action con Ctrl+Arrastrar (0,5 puntos) Al pulsar el bot\u00f3n \u00a1Emergencia! debe aparecer un action sheet con tres opciones: \"nave salvavidas\", \"hiperespacio\" o \"autodestrucci\u00f3n\" (como ves, una opci\u00f3n a la que deber\u00edas ponerle style: .destructive ). Las opciones simplemente imprimir\u00e1n un mensaje adecuado con print , no es necesario que destruyas nada en el mundo real. (0,25 puntos) Si el switch est\u00e1 activado, el bot\u00f3n de \"emergencia\" estar\u00e1 habilitado, en caso contrario, deshabilitado. Al igual que los botones o los slider puedes detectar un cambio en el switch con un action . (1 punto) A\u00f1ade un picker para elegir el destino del viaje de entre una serie de destinos prefijados (por ejemplo \"Saturno\", \"M13\", \"Nebulosa de Ori\u00f3n\",...). Cada vez que cambie el valor seleccionado en el picker debe aparecer un mensaje en la consola indic\u00e1ndolo y mostrando el valor actual.","title":"Ejercicios"},{"location":"2_vistas/ejercicios/#ejercicio-de-vistas-en-ios-controles-basicos-25-puntos","text":"El objetivo es practicar con los controles b\u00e1sicos de la interfaz de usuario en iOS creando un \"panel de control\" ficticio para una supuesta nave espacial al estilo del que aparece en la figura. Puedes ayudarte de la documentaci\u00f3n de referencia de UIKit para ver los m\u00e9todos y propiedades de los componentes: (0,25 puntos) Campo de texto: Al escribir en \u00e9l y pulsar intro en el teclado onscreen ,debe concatenarse lo escrito al campo de texto de varias l\u00edneas (un text view ) Si quieres que aparezca el teclado onscreen en el simulador debes desactivar la opci\u00f3n de men\u00fa de Hardware > Keyboard > Connect Hardware Keyboard , ya que si est\u00e1 activada se usar\u00e1 el teclado f\u00edsico del Mac pero no aparecer\u00e1 el teclado en pantalla. (0,5 puntos) Slider : Debes fijar el valor inicial en 0 y el final en 100 (son propiedades del objeto). F\u00edjalas por c\u00f3digo en el viewDidLoad del controller, consulta la documentaci\u00f3n para ver el nombre. Necesitar\u00e1s un outlet para acceder al slider y poder cambiar sus propiedades por c\u00f3digo. Al cambiar su valor debe aparecer en un label al lado cu\u00e1l es el valor actual. Al igual que los botones, para procesar un cambio en un slider puedes crear un action con Ctrl+Arrastrar (0,5 puntos) Al pulsar el bot\u00f3n \u00a1Emergencia! debe aparecer un action sheet con tres opciones: \"nave salvavidas\", \"hiperespacio\" o \"autodestrucci\u00f3n\" (como ves, una opci\u00f3n a la que deber\u00edas ponerle style: .destructive ). Las opciones simplemente imprimir\u00e1n un mensaje adecuado con print , no es necesario que destruyas nada en el mundo real. (0,25 puntos) Si el switch est\u00e1 activado, el bot\u00f3n de \"emergencia\" estar\u00e1 habilitado, en caso contrario, deshabilitado. Al igual que los botones o los slider puedes detectar un cambio en el switch con un action . (1 punto) A\u00f1ade un picker para elegir el destino del viaje de entre una serie de destinos prefijados (por ejemplo \"Saturno\", \"M13\", \"Nebulosa de Ori\u00f3n\",...). Cada vez que cambie el valor seleccionado en el picker debe aparecer un mensaje en la consola indic\u00e1ndolo y mostrando el valor actual.","title":"Ejercicio de vistas en iOS: controles b\u00e1sicos (2,5 puntos)"},{"location":"3_autolayout/apuntes/","text":"Autolayout \u00b6 El por qu\u00e9 de autolayout \u00b6 Hasta ahora en todas las apps que hemos desarrollado hemos colocado los componentes de interfaz en coordenadas fijas, arrastr\u00e1ndolas hasta su posici\u00f3n visualmente con Xcode o bien especificando directamente las coordenadas en Swift. El problema de esto es que si cambiamos de dispositivo o se rota la pantalla la interfaz no se va adaptar adecuadamente, ya que las dimensiones han cambiado y las coordenadas antes especificadas ahora pueden no tener sentido. Por ejemplo, supongamos que queremos centrar un bot\u00f3n en la pantalla, tanto vertical como horizontalmente. En principio parece que basta con moverlo con el rat\u00f3n hacia el centro. En el momento que el bot\u00f3n est\u00e1 centrado, aparecen unas gu\u00edas punteadas que nos lo indican. Sin embargo estas gu\u00edas solo nos est\u00e1n indicando que el componente est\u00e1 centrado con la resoluci\u00f3n actual , pero no va a seguir centrado si esta cambia. Si ejecutamos la aplicaci\u00f3n en el simulador usando el mismo dispositivo que hemos usado en el proceso de dise\u00f1o veremos que efectivamente est\u00e1 centrado. Pero no es as\u00ed si cambiamos el dispositivo, o si por ejemplo rotamos la pantalla en el simulador (tecla Cmd-Flecha izquierda) Necesitamos alg\u00fan sistema que adapte autom\u00e1ticamente las dimensiones de los componentes de la interfaz a la resoluci\u00f3n actual. En iOS ese sistema es Autolayout . Es un sistema declarativo y basado en restricciones. El sistema usa las restricciones especificadas para calcular autom\u00e1ticamente el frame de cada vista de la interfaz, y adaptarlo a las dimensiones actuales de la ventana. Manejo de restricciones desde Xcode \u00b6 Para especificar qu\u00e9 aspecto queremos que tenga la interfaz independientemente de la resoluci\u00f3n hay que a\u00f1adir restricciones . B\u00e1sicamente las hay de dos tipos: De alineaci\u00f3n ( align ): por ejemplo queremos que un bot\u00f3n est\u00e9 centrado horizontalmente o verticalmente en su contenedor. O que varios componentes est\u00e9n alineados entre s\u00ed. De espaciado ( pin ): por ejemplo queremos que entre un componente y otro, o entre un componente y el borde izquierdo de la pantalla haya un espacio vac\u00edo. Aqu\u00ed tambi\u00e9n se incluir\u00edan las restricciones de tama\u00f1o de un componente individual. (fijar el ancho, el alto,\u2026) Hay dos formas de a\u00f1adir restricciones en Xcode: \"haciendo clic y arrastrando\" con el rat\u00f3n o bien a trav\u00e9s de la barra de herramientas de AutoLayout. A\u00f1adiendo restricciones con botones/men\u00fas \u00b6 En la parte inferior derecha del storyboard hay una barra de botones espec\u00edficos para autolayout : Los que nos sirven para a\u00f1adir restricciones son el tercero y el cuarto. Luego veremos el uso de los restantes. Vamos a arreglar el ejemplo anterior en el que quer\u00edamos centrar horizontal y verticalmente el bot\u00f3n. Tenemos que a\u00f1adir dos restricciones: una de centrado horizontal y otra de centrado vertical. En terminolog\u00eda de autolayout esto son restricciones de alineado ( align ). Seleccionamos este con el rat\u00f3n y pulsamos sobre el icono de Align (el tercero). En el popup que aparece marcamos las casillas de Horizontally in container y Vertically in container Pulsamos sobre el bot\u00f3n que ahora pondr\u00e1 Add 2 constraints para hacer efectivas las restricciones. Las l\u00edneas de gu\u00eda, que antes aparec\u00edan punteadas, ahora ser\u00e1n continuas indicando que ahora son restricciones de autolayout . Aunque cambiemos de dispositivo o de orientaci\u00f3n veremos que el bot\u00f3n sigue centrado. Las restricciones a\u00f1adidas las podemos ver en varios sitios de Xcode: En el \u00e1rea de Document outline , que es accesible pulsando sobre el icono que aparece en la parte inferior izquierda del storyboard . Aqu\u00ed podemos ver un \u201c\u00e1rbol\u201d desplegable con las restricciones. En el Size inspector (icono del panel de la derecha de Xcode) aparece una lista de restricciones aplicadas al componente actual. Cada una tiene un bot\u00f3n Edit para cambiar sus propiedades. Para editar las restricciones: Si hacemos clic sobre una restricci\u00f3n, en el \u00e1rea de Utilities de la derecha de la pantalla, dentro del Size inspector (el icono con una regla del panel derecho de Xcode) aparecer\u00e1n sus propiedades, que podemos editar. Luego veremos qu\u00e9 significan exactamente estas propiedades. Si seleccionamos una restricci\u00f3n y pulsamos la tecla Backspace se eliminar\u00e1 esta. A\u00f1adiendo restricciones con el rat\u00f3n \u00b6 Esta forma es algo m\u00e1s \u00e1gil que la anterior pero requiere de cierta pr\u00e1ctica. Cuando queremos establecer una restricci\u00f3n entre dos elementos arrastramos de uno a otro manteniendo pulsada la tecla Ctrl (igual que para crear un outlet o un action ). Cuando soltamos el bot\u00f3n del rat\u00f3n, aparece un men\u00fa contextual donde elegir la restricci\u00f3n. Las opciones disponibles en el men\u00fa dependen de la direcci\u00f3n y sentido en que se haya arrastrado: - Si arrastramos en sentido horizontal, podemos (entre otros) centrar verticalmente. Y al contrario si arrastramos en vertical. - Las restricciones de espaciado ser\u00e1n hacia el borde que hayamos arrastrado. Cuando se a\u00f1aden restricciones de espaciado con respecto al borde superior e inferior de la pantalla, puede verse que en realidad no se est\u00e1n referenciando los bordes de la pantalla en s\u00ed sino los de un \u00e1rea que Xcode llama safe area Estas \u00e1reas \u201ccrecen autom\u00e1ticamente\u201d para dejar espacio a las barras de navegaci\u00f3n y de botones que veremos cuando usemos navigation controllers y tab bar controllers , asegur\u00e1ndonos as\u00ed de que dichas barras no tapan a nuestras vistas. Restricciones insuficientes o contradictorias \u00b6 Generalmente cuando comenzamos a a\u00f1adir restricciones, las l\u00edneas que las representan aparecen en color naranja en lugar de azul. Esto sucede porque todav\u00eda las restricciones son insuficientes para determinar un\u00edvocamente las coordenadas del frame del componente. Por ejemplo si acabamos de crear un bot\u00f3n y lo centramos verticalmente, lo hemos \u201cfijado\u201d en el eje de las x pero no as\u00ed en el de las y . Adem\u00e1s se muestra un contorno dibujado en l\u00ednea punteada que indica d\u00f3nde calcula Xcode que acabar\u00e1 posicion\u00e1ndose el componente con las restricciones actuales (y que a lo mejor no es donde nosotros queremos). Como regla general nos van a hacer falta dos restricciones por cada dimensi\u00f3n (X e Y) para eliminar la ambig\u00fcedad, aunque hay elementos que solo necesitan una restricci\u00f3n por dimensi\u00f3n, como los botones. Veamos por qu\u00e9. Los botones tienen lo que se denomina un tama\u00f1o intr\u00ednseco . Es decir, aunque no lo digamos expl\u00edcitamente, iOS le asigna el ancho y el alto justo para que quepa el texto mostrado. O sea, es como si ya tuvieran una restricci\u00f3n impl\u00edcita en la X y en la Y. As\u00ed que cuando decimos que el bot\u00f3n est\u00e9 centrado en la X (verticalmente), a autolayout le basta esta restricci\u00f3n para determinar el comportamiento del bot\u00f3n en esta dimensi\u00f3n, ya que la combina con el tama\u00f1o impl\u00edcito. Sin embargo no ocurre lo mismo con otros componentes. Por ejemplo los text view no tienen un tama\u00f1o intr\u00ednseco . De este modo, a\u00f1adir la restricci\u00f3n de centrar un Text View en la dimensi\u00f3n X no resuelve la ambig\u00fcedad de qu\u00e9 ancho deber\u00eda tener, o visto de otro modo, en qu\u00e9 valor de x deber\u00eda empezar su borde izquierdo. Para este tipo de elementos nos har\u00e1n falta dos restricciones por cada dimensi\u00f3n, o dicho de otro modo 4 en total para posicionar el elemento sin ambig\u00fcedades. Otros componentes tienen un tama\u00f1o intr\u00ednseco solo en una dimensi\u00f3n, por ejemplo los slider lo tienen en la Y pero no en la X, por lo que nos har\u00e1 falta una \u00fanica restricci\u00f3n en la Y pero dos en la X. Otro problema t\u00edpico es cuando movemos con el rat\u00f3n el elemento una vez se ha establecido la restricci\u00f3n, de modo que no ocupa la posici\u00f3n que esta restricci\u00f3n est\u00e1 induciendo. Las l\u00edneas de restricci\u00f3n tambi\u00e9n aparecer\u00e1n en naranja, y el n\u00famero que indica su tama\u00f1o tendr\u00e1 un s\u00edmbolo + o - para indicar el desplazamiento. Podemos hacer que el elemento vuelva a la posici\u00f3n que indican las restricciones pulsando sobre el primero de los botones de autolayout , Update Frames . Cuando las restricciones son contradictorias , las l\u00edneas que las representan aparecen en color rojo. Por ejemplo en la siguiente figura hemos intentado especificar un espaciado de 20 puntos con el margen derecho y simult\u00e1neamente que est\u00e9 centrado en horizontal. Claramente esto es imposible, y as\u00ed lo indica Xcode. Cuando hay problemas con las restricciones estos se muestran tambi\u00e9n en el Document outline del storyboard. En el \u00e1ngulo superior derecho del Document outline aparece una peque\u00f1a flecha roja indicando que hay problemas, y si la pulsamos aparecer\u00e1 la lista de restricciones contradictorias e insuficientes. Podemos intentar resolver estos problemas de forma autom\u00e1tica. Para eso est\u00e1 el bot\u00f3n Resolve autolayout issues de la barra de botones de autolayout (recordar que est\u00e1 en la esquina inferior derecha del storyboard ). Hay varias posibilidades: - Update frames : queremos recalcular las posiciones y dimensiones de los frames usando las restricciones actuales. Si hemos movido los elementos con el rat\u00f3n, volver\u00e1n a \u201csu posici\u00f3n\u201d. - Update restrictions : si hemos movido los elementos, Xcode intentar\u00e1 recalcular las restricciones para que se correspondan con la posici\u00f3n actual. - Add missing constraints : bas\u00e1ndose en la posici\u00f3n actual de los elementos, Xcode intentar\u00e1 inferir y a\u00f1adir las restricciones adecuadas para que el layout deje de ser ambiguo. - Reset to suggested constraints : el equivalente a eliminar todas las restricciones ( Clear constraints ) y luego seleccionar Add missing constraints . Previsualizar el efecto de las restricciones \u00b6 Aunque podemos visualizar el efecto de las restricciones ejecutando la aplicaci\u00f3n en el simulador, es un proceso un poco tedioso, y m\u00e1s si queremos comprobar el aspecto en distintos dispositivos con distinto tama\u00f1o de pantalla. Tendr\u00edamos que ejecutar el simulador para cada uno de ellos. Desde Xcode 5 existe la posibilidad de previsualizar el aspecto de la interfaz (incluyendo por supuesto el autolayout). Para previsualizar la interfaz, desde el editor del storyboard seleccionamos el Assistant editor (icono de la barra de herramientas). Como siempre sucede con este tipo de editor, el \u00e1rea principal se dividir\u00e1 en 2. Si en la parte derecha no aparece la preview , la podemos seleccionar manualmente con los iconos de su zona superior En la preview se ve el aspecto que va a tener la interfaz en un determinado hardware. En la parte inferior pone el nombre, por ejemplo \u201ciPhone 4-inch\u201d. Si pasamos el rat\u00f3n por el nombre aparecer\u00e1 a su izquierda un bot\u00f3n que sirve para rotar la pantalla. En la parte inferior izquierda de la ventana de preview hay un s\u00edmbolo + que sirve para a\u00f1adir otros modelos de dispositivo a la previsualizaci\u00f3n. Restricciones sobre el tama\u00f1o \u00b6 Aunque hemos dicho que autolayout calcula el frame de cada componente, hasta ahora hemos ignorado el tama\u00f1o de los mismos. Centrar en horizontal y vertical elimina la ambig\u00fcedad en cuanto a en qu\u00e9 coordenadas \u201canclar\u201d el frame pero \u00bfqu\u00e9 hay de su ancho y alto?. Para muchos componentes ( UILabel , UIButton , UIImage ) no es necesario especificar un tama\u00f1o ya que lo tienen por defecto (el llamado \u201ctama\u00f1o intr\u00ednseco\u201d en el argot de autolayout). En el API la propiedad correspondiente es intrinsicContentSize . Lo m\u00e1s habitual es que sea el tama\u00f1o del texto que contienen. No obstante, tambi\u00e9n podemos poner restricciones sobre el tama\u00f1o. Podemos fijar el ancho y/o el alto o el aspect ratio . Estas son restricciones del tipo pin y por tanto las podemos encontrar donde encontramos las de espaciado entre componentes (en el men\u00fa principal o en la barra de botones de autolayout). Si usamos ctrl-arrastrar con el rat\u00f3n bastar\u00e1 con que arrastremos sin salirnos del componente (al arrastrar en horizontal se nos dar\u00e1 la posibilidad de finar el ancho y lo mismo con el alto si arrastramos en vertical). Si especificamos el tama\u00f1o mediante una restricci\u00f3n podemos forzar a que el contenido del bot\u00f3n tenga que \u201ccortarse\u201d porque no cabe, o bien que tenga que a\u00f1adirse un padding al sobrar espacio. M\u00e1s sobre las restricciones \u00b6 Formulaci\u00f3n completa de una restricci\u00f3n \u00b6 Internamente, cada restricci\u00f3n se formula como una ecuaci\u00f3n lineal en la que: 1 item1.atributo1 = multiplicador * item2.atributo2 + cte Algunas restricciones no son ecuaciones sino inecuaciones , sustituyendo el s\u00edmbolo = por <= o >= . Es decir, desde el punto de vista formal, lo que hace autolayout es resolver un sistema de ecuaciones lineales. Estas propiedades podemos verlas en el Size inspector (parte derecha de la pantalla, icono de la regla ). Si seleccionamos un componente de UI aparecer\u00e1n aqu\u00ed todas sus restricciones, que podemos editar pulsando en Edit . Por ejemplo, aqu\u00ed vemos las restricciones de un bot\u00f3n centrado en el eje de las X y con un espaciado est\u00e1ndar (8 puntos) con respecto a la gu\u00eda inferior. Podemos observar en la figura las propiedades de la restricci\u00f3n, que se corresponden directamente con los coeficientes del lado derecho de la ecuaci\u00f3n lineal (el multiplicador y la constante). Adem\u00e1s aparece una prioridad , que explicaremos en el siguiente apartado. Haciendo clic en el desplegable con el s\u00edmbolo = podemos cambiar la ecuaci\u00f3n por una inecuaci\u00f3n. En nuestro ejemplo la constante es 0 y el multiplicador 1 porque queremos centrar el componente en el contenedor, es decir 1 contenedor.centerX = componente.centerX Podemos por ejemplo cambiar la constante por 50, con lo que conseguiremos que el componente est\u00e9 desplazado 50 puntos a la izquierda de la posici\u00f3n de \u201ccentrado en X\u201d. Si en lugar de seleccionar el componente GUI seleccionamos directamente una restricci\u00f3n y nos vamos al Size inspector podremos editar directamente las propiedades de la restricci\u00f3n, incluyendo tambi\u00e9n los propios atributos. Prioridades \u00b6 Cada restricci\u00f3n tiene asignada una prioridad , que es un valor num\u00e9rico que especifica su \u201cimportancia\u201d (a mayor valor, mayor prioridad). El valor por defecto es 1000, que significa que el sistema entiende que la restricci\u00f3n debe cumplirse . Valores menores que 1000 indican que el sistema intentar\u00e1 cumplir la restricci\u00f3n pero que es posible que no lo haga si hay restricciones contradictorias de mayor prioridad. Podemos cambiar/ver la prioridad actual de la misma forma que podemos cambiar/ver el resto de propiedades de la restricci\u00f3n (ver apartado anterior). Adem\u00e1s de las restricciones, tambi\u00e9n los componentes GUI tienen dos valores de prioridad, relativos al tama\u00f1o: Compression resistance : indica la prioridad que para el componente tiene mostrar completo su contenido (resisti\u00e9ndose por tanto a ser comprimido, y de ah\u00ed el nombre. Por defecto los componentes tienen este valor alto (aunque menos que 1000, en Xcode 6 est\u00e1 fijado a 750). Si una regla con prioridad por defecto conlleva a que el contenido del bot\u00f3n no se vea completo ganar\u00e1 la regla, pero no ser\u00e1 as\u00ed si su prioridad es menor que 750. Content hugging : indica la prioridad que para el componente tiene evitar el padding . Por defecto tiene un valor bajo, indicando que si hay reglas que lleven a aumentar el padding se tomar\u00e1n en cuenta salvo que tengan prioridad muy baja. Formular restricciones usando c\u00f3digo \u00b6 En lugar de usar el editor visual de Xcode podemos especificar las restricciones en el c\u00f3digo fuente. Esto puede resultar interesante en diversas situaciones: a veces los elementos de la interfaz se crean din\u00e1micamente y por tanto no se puede especificar el layout en Xcode. Otras veces puede ser que aunque los elementos del interfaz no cambien s\u00ed queramos que cambien din\u00e1micamente las restricciones para conseguir distintos efectos de layout . Hay dos formas de hacerlo: directamente con el API de autolayout o con un mayor nivel de abstracci\u00f3n usando el llamado \u201cVisual Format Language\u201d. Si podemos elegir, la mejor forma es la segunda, ya que es mucho m\u00e1s intuitivo especificar las restricciones y entenderlas leyendo luego el c\u00f3digo. El API b\u00e1sico de autolayout \u00b6 Cada restricci\u00f3n es un objeto de la clase NSLayoutConstraint . En el inicializador de esta clase se especifica directamente par\u00e1metro por par\u00e1metro cada una de las propiedades de la restricci\u00f3n. Por ejemplo, supongamos que estamos en un view controller y queremos centrar un bot\u00f3n en su contenedor en el eje de las X. El bot\u00f3n lo tenemos en un outlet llamado boton , y ya sabemos que a la vista podemos acceder desde el controller con self.view . La restricci\u00f3n en forma de expresi\u00f3n matem\u00e1tica ser\u00eda algo como 1 self.view.centerX = 1*boton.centerX+0 Donde se ha puesto de forma expl\u00edcita la constante y el multiplicador para ver m\u00e1s clara la correspondencia directa con el c\u00f3digo Swift, donde se har\u00eda como: 1 2 3 4 5 6 7 let centradoX = NSLayoutConstraint ( item : self . boton , attribute : . centerY , relatedBy : . equal , toItem : self . view , attribute : . centerY , multiplier : 1.0 , constant : 0.0 ) Como vemos hay una correspondencia bastante directa entre la expresi\u00f3n matem\u00e1tica y el c\u00f3digo. Una vez creada la constante hay que activarla . Esto se puede hacer fijando isActive a true 1 centradoX . isActive = true Una alternativa es a\u00f1adir la restricci\u00f3n a la vista con addConstraint() 1 self . view . addConstraint ( centradoX ) Como vemos, hemos a\u00f1adido la restricci\u00f3n al contenedor del bot\u00f3n. Como norma general, si son vistas \u201cmadre/hija\u201d la a\u00f1adiremos a la \u201cmadre\u201d, y en otro caso al ancestro com\u00fan m\u00e1s cercano de ambas vistas . Por ejemplo si fuera una relaci\u00f3n entre dos botones dentro del mismo contenedor la a\u00f1adir\u00edamos al contenedor. MUY IMPORTANTE: Xcode a\u00f1ade impl\u00edcitamente algunas restricciones a los componentes, adem\u00e1s de las puestas expl\u00edcitamente por nosotros en c\u00f3digo, y es bastante probable que entren en conflicto con las nuestras y para resolver el problema el sistema las acabe ignorando. Por ello para usar autolayout por c\u00f3digo lo primero es indicar que para un determinado componente no queremos esas restricciones \u201cautom\u00e1ticas\u201d. En nuestro caso para el bot\u00f3n: 1 self . boton . translatesAutoresizingMaskIntoConstraints = false Esto habr\u00eda que hacerlo antes de activar las restricciones. Visual Format Language \u00b6 La conversi\u00f3n de ecuaci\u00f3n matem\u00e1tica a llamada del API es bastante directa, pero tiene el problema de que no es f\u00e1cil y r\u00e1pido deducir intuitivamente la restricci\u00f3n leyendo el c\u00f3digo. Es mucho m\u00e1s intuitivo leer \u201cel componente debe estar centrado en el eje X pero desplazado 10 pixels a la izquierda\u201d que leer superview.centroX = componente.centroX + 10 . La descripci\u00f3n formal pero a la vez intuitiva de un conjunto de restricciones se puede hacer con una ingeniosa \u201crepresentaci\u00f3n en modo texto\u201d de la representaci\u00f3n gr\u00e1fica de las restricciones llamada Visual Format Language . Dicho formato permite representar un conjunto de restricciones con una cadena de caracteres. La representaci\u00f3n usa s\u00edmbolos \u201csemi-gr\u00e1ficos\u201d, un poco al estilo del ASCII-ART (salvando las distancias). As\u00ed, por ejemplo si queremos especificar que entre dos componentes debe haber una separaci\u00f3n est\u00e1ndar (8 pixels) usar\u00edamos la cadena: 1 [boton1]-[boton2] Donde los corchetes indican un componente, y el ``-``` indica la separaci\u00f3n est\u00e1ndar. La cadena se parece razonablemente a la representaci\u00f3n gr\u00e1fica que podr\u00edamos ver en Xcode de la misma restricci\u00f3n. Hay que indicar que boton1 y boton2 no son exactamente nombres de variables sino etiquetas arbitrarias. La llamada al API para crear esta restricci\u00f3n usando el visual format language ser\u00eda algo como: 1 2 3 4 5 let constraint = NSLayoutConstraint . constraints ( withVisualFormat : \"[boton1]-[boton2]\" options : . alignAllCenterY , metrics : nil , views : viewsDict ]; donde: - El primer par\u00e1metro es la cadena de formato - options es una m\u00e1scara de bits formada a partir de enumerados describiendo la direcci\u00f3n y la alineaci\u00f3n de los componentes - metrics se usa si hay constantes en la restricci\u00f3n (no es el caso del ejemplo). Es un diccionario en el que las claves son los nombres de las constantes y los valores son los de las constantes. - El \u00faltimo es un diccionario donde las claves son los nombres de componentes en la cadena y los valores son las variables correspondientes a las vistas. Lo habr\u00edamos creado con un c\u00f3digo como: 1 2 3 let b1 = UIButton () let b2 = UIButton () let viewsDict = [ \"boton1\" : b1 , \"boton2\" : b2 ] Algunos ejemplos adicionales de cadenas de formato: [boton1]-20-[boton2] separaci\u00f3n de 20 puntos [boton1(50)]-20-[boton2(>=50)] entre par\u00e9ntesis especificamos el ancho del bot\u00f3n, n\u00f3tese que se pueden poner desigualdades [boton1]-20@800-[boton2] las prioridades se ponen con la @ [boton1]-20-[boton2(==boton1)] el bot\u00f3n 2 debe ser del mismo tama\u00f1o que el 1. V:[topField]-10-[bottomField] con la V especificamos que es un layout en vertical, los dos campos estar\u00e1n uno encima del otro separados por una distancia de 10 puntos. |-[find]-[findNext]-[findField(>=20)]-| una l\u00ednea completa de layout , donde las barras verticales representan los bordes del contenedor. Se recomienda consultar la documentaci\u00f3n de Apple para m\u00e1s informaci\u00f3n sobre la sintaxis y ejemplos adicionales. En el dise\u00f1o del formato, se ha preferido la claridad y el paralelismo con la representaci\u00f3n gr\u00e1fica a la expresividad. Como resultado, ciertas restricciones no son expresables. Por ejemplo no se puede especificar que el ancho de un bot\u00f3n sea el doble que el de otro.","title":"Autolayout"},{"location":"3_autolayout/apuntes/#autolayout","text":"","title":"Autolayout"},{"location":"3_autolayout/apuntes/#el-por-que-de-autolayout","text":"Hasta ahora en todas las apps que hemos desarrollado hemos colocado los componentes de interfaz en coordenadas fijas, arrastr\u00e1ndolas hasta su posici\u00f3n visualmente con Xcode o bien especificando directamente las coordenadas en Swift. El problema de esto es que si cambiamos de dispositivo o se rota la pantalla la interfaz no se va adaptar adecuadamente, ya que las dimensiones han cambiado y las coordenadas antes especificadas ahora pueden no tener sentido. Por ejemplo, supongamos que queremos centrar un bot\u00f3n en la pantalla, tanto vertical como horizontalmente. En principio parece que basta con moverlo con el rat\u00f3n hacia el centro. En el momento que el bot\u00f3n est\u00e1 centrado, aparecen unas gu\u00edas punteadas que nos lo indican. Sin embargo estas gu\u00edas solo nos est\u00e1n indicando que el componente est\u00e1 centrado con la resoluci\u00f3n actual , pero no va a seguir centrado si esta cambia. Si ejecutamos la aplicaci\u00f3n en el simulador usando el mismo dispositivo que hemos usado en el proceso de dise\u00f1o veremos que efectivamente est\u00e1 centrado. Pero no es as\u00ed si cambiamos el dispositivo, o si por ejemplo rotamos la pantalla en el simulador (tecla Cmd-Flecha izquierda) Necesitamos alg\u00fan sistema que adapte autom\u00e1ticamente las dimensiones de los componentes de la interfaz a la resoluci\u00f3n actual. En iOS ese sistema es Autolayout . Es un sistema declarativo y basado en restricciones. El sistema usa las restricciones especificadas para calcular autom\u00e1ticamente el frame de cada vista de la interfaz, y adaptarlo a las dimensiones actuales de la ventana.","title":"El por qu\u00e9 de autolayout"},{"location":"3_autolayout/apuntes/#manejo-de-restricciones-desde-xcode","text":"Para especificar qu\u00e9 aspecto queremos que tenga la interfaz independientemente de la resoluci\u00f3n hay que a\u00f1adir restricciones . B\u00e1sicamente las hay de dos tipos: De alineaci\u00f3n ( align ): por ejemplo queremos que un bot\u00f3n est\u00e9 centrado horizontalmente o verticalmente en su contenedor. O que varios componentes est\u00e9n alineados entre s\u00ed. De espaciado ( pin ): por ejemplo queremos que entre un componente y otro, o entre un componente y el borde izquierdo de la pantalla haya un espacio vac\u00edo. Aqu\u00ed tambi\u00e9n se incluir\u00edan las restricciones de tama\u00f1o de un componente individual. (fijar el ancho, el alto,\u2026) Hay dos formas de a\u00f1adir restricciones en Xcode: \"haciendo clic y arrastrando\" con el rat\u00f3n o bien a trav\u00e9s de la barra de herramientas de AutoLayout.","title":"Manejo de restricciones desde Xcode"},{"location":"3_autolayout/apuntes/#anadiendo-restricciones-con-botonesmenus","text":"En la parte inferior derecha del storyboard hay una barra de botones espec\u00edficos para autolayout : Los que nos sirven para a\u00f1adir restricciones son el tercero y el cuarto. Luego veremos el uso de los restantes. Vamos a arreglar el ejemplo anterior en el que quer\u00edamos centrar horizontal y verticalmente el bot\u00f3n. Tenemos que a\u00f1adir dos restricciones: una de centrado horizontal y otra de centrado vertical. En terminolog\u00eda de autolayout esto son restricciones de alineado ( align ). Seleccionamos este con el rat\u00f3n y pulsamos sobre el icono de Align (el tercero). En el popup que aparece marcamos las casillas de Horizontally in container y Vertically in container Pulsamos sobre el bot\u00f3n que ahora pondr\u00e1 Add 2 constraints para hacer efectivas las restricciones. Las l\u00edneas de gu\u00eda, que antes aparec\u00edan punteadas, ahora ser\u00e1n continuas indicando que ahora son restricciones de autolayout . Aunque cambiemos de dispositivo o de orientaci\u00f3n veremos que el bot\u00f3n sigue centrado. Las restricciones a\u00f1adidas las podemos ver en varios sitios de Xcode: En el \u00e1rea de Document outline , que es accesible pulsando sobre el icono que aparece en la parte inferior izquierda del storyboard . Aqu\u00ed podemos ver un \u201c\u00e1rbol\u201d desplegable con las restricciones. En el Size inspector (icono del panel de la derecha de Xcode) aparece una lista de restricciones aplicadas al componente actual. Cada una tiene un bot\u00f3n Edit para cambiar sus propiedades. Para editar las restricciones: Si hacemos clic sobre una restricci\u00f3n, en el \u00e1rea de Utilities de la derecha de la pantalla, dentro del Size inspector (el icono con una regla del panel derecho de Xcode) aparecer\u00e1n sus propiedades, que podemos editar. Luego veremos qu\u00e9 significan exactamente estas propiedades. Si seleccionamos una restricci\u00f3n y pulsamos la tecla Backspace se eliminar\u00e1 esta.","title":"A\u00f1adiendo restricciones con botones/men\u00fas"},{"location":"3_autolayout/apuntes/#anadiendo-restricciones-con-el-raton","text":"Esta forma es algo m\u00e1s \u00e1gil que la anterior pero requiere de cierta pr\u00e1ctica. Cuando queremos establecer una restricci\u00f3n entre dos elementos arrastramos de uno a otro manteniendo pulsada la tecla Ctrl (igual que para crear un outlet o un action ). Cuando soltamos el bot\u00f3n del rat\u00f3n, aparece un men\u00fa contextual donde elegir la restricci\u00f3n. Las opciones disponibles en el men\u00fa dependen de la direcci\u00f3n y sentido en que se haya arrastrado: - Si arrastramos en sentido horizontal, podemos (entre otros) centrar verticalmente. Y al contrario si arrastramos en vertical. - Las restricciones de espaciado ser\u00e1n hacia el borde que hayamos arrastrado. Cuando se a\u00f1aden restricciones de espaciado con respecto al borde superior e inferior de la pantalla, puede verse que en realidad no se est\u00e1n referenciando los bordes de la pantalla en s\u00ed sino los de un \u00e1rea que Xcode llama safe area Estas \u00e1reas \u201ccrecen autom\u00e1ticamente\u201d para dejar espacio a las barras de navegaci\u00f3n y de botones que veremos cuando usemos navigation controllers y tab bar controllers , asegur\u00e1ndonos as\u00ed de que dichas barras no tapan a nuestras vistas.","title":"A\u00f1adiendo restricciones con el rat\u00f3n"},{"location":"3_autolayout/apuntes/#restricciones-insuficientes-o-contradictorias","text":"Generalmente cuando comenzamos a a\u00f1adir restricciones, las l\u00edneas que las representan aparecen en color naranja en lugar de azul. Esto sucede porque todav\u00eda las restricciones son insuficientes para determinar un\u00edvocamente las coordenadas del frame del componente. Por ejemplo si acabamos de crear un bot\u00f3n y lo centramos verticalmente, lo hemos \u201cfijado\u201d en el eje de las x pero no as\u00ed en el de las y . Adem\u00e1s se muestra un contorno dibujado en l\u00ednea punteada que indica d\u00f3nde calcula Xcode que acabar\u00e1 posicion\u00e1ndose el componente con las restricciones actuales (y que a lo mejor no es donde nosotros queremos). Como regla general nos van a hacer falta dos restricciones por cada dimensi\u00f3n (X e Y) para eliminar la ambig\u00fcedad, aunque hay elementos que solo necesitan una restricci\u00f3n por dimensi\u00f3n, como los botones. Veamos por qu\u00e9. Los botones tienen lo que se denomina un tama\u00f1o intr\u00ednseco . Es decir, aunque no lo digamos expl\u00edcitamente, iOS le asigna el ancho y el alto justo para que quepa el texto mostrado. O sea, es como si ya tuvieran una restricci\u00f3n impl\u00edcita en la X y en la Y. As\u00ed que cuando decimos que el bot\u00f3n est\u00e9 centrado en la X (verticalmente), a autolayout le basta esta restricci\u00f3n para determinar el comportamiento del bot\u00f3n en esta dimensi\u00f3n, ya que la combina con el tama\u00f1o impl\u00edcito. Sin embargo no ocurre lo mismo con otros componentes. Por ejemplo los text view no tienen un tama\u00f1o intr\u00ednseco . De este modo, a\u00f1adir la restricci\u00f3n de centrar un Text View en la dimensi\u00f3n X no resuelve la ambig\u00fcedad de qu\u00e9 ancho deber\u00eda tener, o visto de otro modo, en qu\u00e9 valor de x deber\u00eda empezar su borde izquierdo. Para este tipo de elementos nos har\u00e1n falta dos restricciones por cada dimensi\u00f3n, o dicho de otro modo 4 en total para posicionar el elemento sin ambig\u00fcedades. Otros componentes tienen un tama\u00f1o intr\u00ednseco solo en una dimensi\u00f3n, por ejemplo los slider lo tienen en la Y pero no en la X, por lo que nos har\u00e1 falta una \u00fanica restricci\u00f3n en la Y pero dos en la X. Otro problema t\u00edpico es cuando movemos con el rat\u00f3n el elemento una vez se ha establecido la restricci\u00f3n, de modo que no ocupa la posici\u00f3n que esta restricci\u00f3n est\u00e1 induciendo. Las l\u00edneas de restricci\u00f3n tambi\u00e9n aparecer\u00e1n en naranja, y el n\u00famero que indica su tama\u00f1o tendr\u00e1 un s\u00edmbolo + o - para indicar el desplazamiento. Podemos hacer que el elemento vuelva a la posici\u00f3n que indican las restricciones pulsando sobre el primero de los botones de autolayout , Update Frames . Cuando las restricciones son contradictorias , las l\u00edneas que las representan aparecen en color rojo. Por ejemplo en la siguiente figura hemos intentado especificar un espaciado de 20 puntos con el margen derecho y simult\u00e1neamente que est\u00e9 centrado en horizontal. Claramente esto es imposible, y as\u00ed lo indica Xcode. Cuando hay problemas con las restricciones estos se muestran tambi\u00e9n en el Document outline del storyboard. En el \u00e1ngulo superior derecho del Document outline aparece una peque\u00f1a flecha roja indicando que hay problemas, y si la pulsamos aparecer\u00e1 la lista de restricciones contradictorias e insuficientes. Podemos intentar resolver estos problemas de forma autom\u00e1tica. Para eso est\u00e1 el bot\u00f3n Resolve autolayout issues de la barra de botones de autolayout (recordar que est\u00e1 en la esquina inferior derecha del storyboard ). Hay varias posibilidades: - Update frames : queremos recalcular las posiciones y dimensiones de los frames usando las restricciones actuales. Si hemos movido los elementos con el rat\u00f3n, volver\u00e1n a \u201csu posici\u00f3n\u201d. - Update restrictions : si hemos movido los elementos, Xcode intentar\u00e1 recalcular las restricciones para que se correspondan con la posici\u00f3n actual. - Add missing constraints : bas\u00e1ndose en la posici\u00f3n actual de los elementos, Xcode intentar\u00e1 inferir y a\u00f1adir las restricciones adecuadas para que el layout deje de ser ambiguo. - Reset to suggested constraints : el equivalente a eliminar todas las restricciones ( Clear constraints ) y luego seleccionar Add missing constraints .","title":"Restricciones insuficientes o contradictorias"},{"location":"3_autolayout/apuntes/#previsualizar-el-efecto-de-las-restricciones","text":"Aunque podemos visualizar el efecto de las restricciones ejecutando la aplicaci\u00f3n en el simulador, es un proceso un poco tedioso, y m\u00e1s si queremos comprobar el aspecto en distintos dispositivos con distinto tama\u00f1o de pantalla. Tendr\u00edamos que ejecutar el simulador para cada uno de ellos. Desde Xcode 5 existe la posibilidad de previsualizar el aspecto de la interfaz (incluyendo por supuesto el autolayout). Para previsualizar la interfaz, desde el editor del storyboard seleccionamos el Assistant editor (icono de la barra de herramientas). Como siempre sucede con este tipo de editor, el \u00e1rea principal se dividir\u00e1 en 2. Si en la parte derecha no aparece la preview , la podemos seleccionar manualmente con los iconos de su zona superior En la preview se ve el aspecto que va a tener la interfaz en un determinado hardware. En la parte inferior pone el nombre, por ejemplo \u201ciPhone 4-inch\u201d. Si pasamos el rat\u00f3n por el nombre aparecer\u00e1 a su izquierda un bot\u00f3n que sirve para rotar la pantalla. En la parte inferior izquierda de la ventana de preview hay un s\u00edmbolo + que sirve para a\u00f1adir otros modelos de dispositivo a la previsualizaci\u00f3n.","title":"Previsualizar el efecto de las restricciones"},{"location":"3_autolayout/apuntes/#restricciones-sobre-el-tamano","text":"Aunque hemos dicho que autolayout calcula el frame de cada componente, hasta ahora hemos ignorado el tama\u00f1o de los mismos. Centrar en horizontal y vertical elimina la ambig\u00fcedad en cuanto a en qu\u00e9 coordenadas \u201canclar\u201d el frame pero \u00bfqu\u00e9 hay de su ancho y alto?. Para muchos componentes ( UILabel , UIButton , UIImage ) no es necesario especificar un tama\u00f1o ya que lo tienen por defecto (el llamado \u201ctama\u00f1o intr\u00ednseco\u201d en el argot de autolayout). En el API la propiedad correspondiente es intrinsicContentSize . Lo m\u00e1s habitual es que sea el tama\u00f1o del texto que contienen. No obstante, tambi\u00e9n podemos poner restricciones sobre el tama\u00f1o. Podemos fijar el ancho y/o el alto o el aspect ratio . Estas son restricciones del tipo pin y por tanto las podemos encontrar donde encontramos las de espaciado entre componentes (en el men\u00fa principal o en la barra de botones de autolayout). Si usamos ctrl-arrastrar con el rat\u00f3n bastar\u00e1 con que arrastremos sin salirnos del componente (al arrastrar en horizontal se nos dar\u00e1 la posibilidad de finar el ancho y lo mismo con el alto si arrastramos en vertical). Si especificamos el tama\u00f1o mediante una restricci\u00f3n podemos forzar a que el contenido del bot\u00f3n tenga que \u201ccortarse\u201d porque no cabe, o bien que tenga que a\u00f1adirse un padding al sobrar espacio.","title":"Restricciones sobre el tama\u00f1o"},{"location":"3_autolayout/apuntes/#mas-sobre-las-restricciones","text":"","title":"M\u00e1s sobre las restricciones"},{"location":"3_autolayout/apuntes/#formulacion-completa-de-una-restriccion","text":"Internamente, cada restricci\u00f3n se formula como una ecuaci\u00f3n lineal en la que: 1 item1.atributo1 = multiplicador * item2.atributo2 + cte Algunas restricciones no son ecuaciones sino inecuaciones , sustituyendo el s\u00edmbolo = por <= o >= . Es decir, desde el punto de vista formal, lo que hace autolayout es resolver un sistema de ecuaciones lineales. Estas propiedades podemos verlas en el Size inspector (parte derecha de la pantalla, icono de la regla ). Si seleccionamos un componente de UI aparecer\u00e1n aqu\u00ed todas sus restricciones, que podemos editar pulsando en Edit . Por ejemplo, aqu\u00ed vemos las restricciones de un bot\u00f3n centrado en el eje de las X y con un espaciado est\u00e1ndar (8 puntos) con respecto a la gu\u00eda inferior. Podemos observar en la figura las propiedades de la restricci\u00f3n, que se corresponden directamente con los coeficientes del lado derecho de la ecuaci\u00f3n lineal (el multiplicador y la constante). Adem\u00e1s aparece una prioridad , que explicaremos en el siguiente apartado. Haciendo clic en el desplegable con el s\u00edmbolo = podemos cambiar la ecuaci\u00f3n por una inecuaci\u00f3n. En nuestro ejemplo la constante es 0 y el multiplicador 1 porque queremos centrar el componente en el contenedor, es decir 1 contenedor.centerX = componente.centerX Podemos por ejemplo cambiar la constante por 50, con lo que conseguiremos que el componente est\u00e9 desplazado 50 puntos a la izquierda de la posici\u00f3n de \u201ccentrado en X\u201d. Si en lugar de seleccionar el componente GUI seleccionamos directamente una restricci\u00f3n y nos vamos al Size inspector podremos editar directamente las propiedades de la restricci\u00f3n, incluyendo tambi\u00e9n los propios atributos.","title":"Formulaci\u00f3n completa de una restricci\u00f3n"},{"location":"3_autolayout/apuntes/#prioridades","text":"Cada restricci\u00f3n tiene asignada una prioridad , que es un valor num\u00e9rico que especifica su \u201cimportancia\u201d (a mayor valor, mayor prioridad). El valor por defecto es 1000, que significa que el sistema entiende que la restricci\u00f3n debe cumplirse . Valores menores que 1000 indican que el sistema intentar\u00e1 cumplir la restricci\u00f3n pero que es posible que no lo haga si hay restricciones contradictorias de mayor prioridad. Podemos cambiar/ver la prioridad actual de la misma forma que podemos cambiar/ver el resto de propiedades de la restricci\u00f3n (ver apartado anterior). Adem\u00e1s de las restricciones, tambi\u00e9n los componentes GUI tienen dos valores de prioridad, relativos al tama\u00f1o: Compression resistance : indica la prioridad que para el componente tiene mostrar completo su contenido (resisti\u00e9ndose por tanto a ser comprimido, y de ah\u00ed el nombre. Por defecto los componentes tienen este valor alto (aunque menos que 1000, en Xcode 6 est\u00e1 fijado a 750). Si una regla con prioridad por defecto conlleva a que el contenido del bot\u00f3n no se vea completo ganar\u00e1 la regla, pero no ser\u00e1 as\u00ed si su prioridad es menor que 750. Content hugging : indica la prioridad que para el componente tiene evitar el padding . Por defecto tiene un valor bajo, indicando que si hay reglas que lleven a aumentar el padding se tomar\u00e1n en cuenta salvo que tengan prioridad muy baja.","title":"Prioridades"},{"location":"3_autolayout/apuntes/#formular-restricciones-usando-codigo","text":"En lugar de usar el editor visual de Xcode podemos especificar las restricciones en el c\u00f3digo fuente. Esto puede resultar interesante en diversas situaciones: a veces los elementos de la interfaz se crean din\u00e1micamente y por tanto no se puede especificar el layout en Xcode. Otras veces puede ser que aunque los elementos del interfaz no cambien s\u00ed queramos que cambien din\u00e1micamente las restricciones para conseguir distintos efectos de layout . Hay dos formas de hacerlo: directamente con el API de autolayout o con un mayor nivel de abstracci\u00f3n usando el llamado \u201cVisual Format Language\u201d. Si podemos elegir, la mejor forma es la segunda, ya que es mucho m\u00e1s intuitivo especificar las restricciones y entenderlas leyendo luego el c\u00f3digo.","title":"Formular restricciones usando c\u00f3digo"},{"location":"3_autolayout/apuntes/#el-api-basico-de-autolayout","text":"Cada restricci\u00f3n es un objeto de la clase NSLayoutConstraint . En el inicializador de esta clase se especifica directamente par\u00e1metro por par\u00e1metro cada una de las propiedades de la restricci\u00f3n. Por ejemplo, supongamos que estamos en un view controller y queremos centrar un bot\u00f3n en su contenedor en el eje de las X. El bot\u00f3n lo tenemos en un outlet llamado boton , y ya sabemos que a la vista podemos acceder desde el controller con self.view . La restricci\u00f3n en forma de expresi\u00f3n matem\u00e1tica ser\u00eda algo como 1 self.view.centerX = 1*boton.centerX+0 Donde se ha puesto de forma expl\u00edcita la constante y el multiplicador para ver m\u00e1s clara la correspondencia directa con el c\u00f3digo Swift, donde se har\u00eda como: 1 2 3 4 5 6 7 let centradoX = NSLayoutConstraint ( item : self . boton , attribute : . centerY , relatedBy : . equal , toItem : self . view , attribute : . centerY , multiplier : 1.0 , constant : 0.0 ) Como vemos hay una correspondencia bastante directa entre la expresi\u00f3n matem\u00e1tica y el c\u00f3digo. Una vez creada la constante hay que activarla . Esto se puede hacer fijando isActive a true 1 centradoX . isActive = true Una alternativa es a\u00f1adir la restricci\u00f3n a la vista con addConstraint() 1 self . view . addConstraint ( centradoX ) Como vemos, hemos a\u00f1adido la restricci\u00f3n al contenedor del bot\u00f3n. Como norma general, si son vistas \u201cmadre/hija\u201d la a\u00f1adiremos a la \u201cmadre\u201d, y en otro caso al ancestro com\u00fan m\u00e1s cercano de ambas vistas . Por ejemplo si fuera una relaci\u00f3n entre dos botones dentro del mismo contenedor la a\u00f1adir\u00edamos al contenedor. MUY IMPORTANTE: Xcode a\u00f1ade impl\u00edcitamente algunas restricciones a los componentes, adem\u00e1s de las puestas expl\u00edcitamente por nosotros en c\u00f3digo, y es bastante probable que entren en conflicto con las nuestras y para resolver el problema el sistema las acabe ignorando. Por ello para usar autolayout por c\u00f3digo lo primero es indicar que para un determinado componente no queremos esas restricciones \u201cautom\u00e1ticas\u201d. En nuestro caso para el bot\u00f3n: 1 self . boton . translatesAutoresizingMaskIntoConstraints = false Esto habr\u00eda que hacerlo antes de activar las restricciones.","title":"El API b\u00e1sico de autolayout"},{"location":"3_autolayout/apuntes/#visual-format-language","text":"La conversi\u00f3n de ecuaci\u00f3n matem\u00e1tica a llamada del API es bastante directa, pero tiene el problema de que no es f\u00e1cil y r\u00e1pido deducir intuitivamente la restricci\u00f3n leyendo el c\u00f3digo. Es mucho m\u00e1s intuitivo leer \u201cel componente debe estar centrado en el eje X pero desplazado 10 pixels a la izquierda\u201d que leer superview.centroX = componente.centroX + 10 . La descripci\u00f3n formal pero a la vez intuitiva de un conjunto de restricciones se puede hacer con una ingeniosa \u201crepresentaci\u00f3n en modo texto\u201d de la representaci\u00f3n gr\u00e1fica de las restricciones llamada Visual Format Language . Dicho formato permite representar un conjunto de restricciones con una cadena de caracteres. La representaci\u00f3n usa s\u00edmbolos \u201csemi-gr\u00e1ficos\u201d, un poco al estilo del ASCII-ART (salvando las distancias). As\u00ed, por ejemplo si queremos especificar que entre dos componentes debe haber una separaci\u00f3n est\u00e1ndar (8 pixels) usar\u00edamos la cadena: 1 [boton1]-[boton2] Donde los corchetes indican un componente, y el ``-``` indica la separaci\u00f3n est\u00e1ndar. La cadena se parece razonablemente a la representaci\u00f3n gr\u00e1fica que podr\u00edamos ver en Xcode de la misma restricci\u00f3n. Hay que indicar que boton1 y boton2 no son exactamente nombres de variables sino etiquetas arbitrarias. La llamada al API para crear esta restricci\u00f3n usando el visual format language ser\u00eda algo como: 1 2 3 4 5 let constraint = NSLayoutConstraint . constraints ( withVisualFormat : \"[boton1]-[boton2]\" options : . alignAllCenterY , metrics : nil , views : viewsDict ]; donde: - El primer par\u00e1metro es la cadena de formato - options es una m\u00e1scara de bits formada a partir de enumerados describiendo la direcci\u00f3n y la alineaci\u00f3n de los componentes - metrics se usa si hay constantes en la restricci\u00f3n (no es el caso del ejemplo). Es un diccionario en el que las claves son los nombres de las constantes y los valores son los de las constantes. - El \u00faltimo es un diccionario donde las claves son los nombres de componentes en la cadena y los valores son las variables correspondientes a las vistas. Lo habr\u00edamos creado con un c\u00f3digo como: 1 2 3 let b1 = UIButton () let b2 = UIButton () let viewsDict = [ \"boton1\" : b1 , \"boton2\" : b2 ] Algunos ejemplos adicionales de cadenas de formato: [boton1]-20-[boton2] separaci\u00f3n de 20 puntos [boton1(50)]-20-[boton2(>=50)] entre par\u00e9ntesis especificamos el ancho del bot\u00f3n, n\u00f3tese que se pueden poner desigualdades [boton1]-20@800-[boton2] las prioridades se ponen con la @ [boton1]-20-[boton2(==boton1)] el bot\u00f3n 2 debe ser del mismo tama\u00f1o que el 1. V:[topField]-10-[bottomField] con la V especificamos que es un layout en vertical, los dos campos estar\u00e1n uno encima del otro separados por una distancia de 10 puntos. |-[find]-[findNext]-[findField(>=20)]-| una l\u00ednea completa de layout , donde las barras verticales representan los bordes del contenedor. Se recomienda consultar la documentaci\u00f3n de Apple para m\u00e1s informaci\u00f3n sobre la sintaxis y ejemplos adicionales. En el dise\u00f1o del formato, se ha preferido la claridad y el paralelismo con la representaci\u00f3n gr\u00e1fica a la expresividad. Como resultado, ciertas restricciones no son expresables. Por ejemplo no se puede especificar que el ancho de un bot\u00f3n sea el doble que el de otro.","title":"Visual Format Language"},{"location":"3_autolayout/ejercicios/","text":"Ejercicios de Autolayout (1,5 puntos) \u00b6 El objetivo es a\u00f1adir autolayout a la aplicaci\u00f3n de \u201cpioneras\u201d que hicimos en sesiones anteriores para que la interfaz se vea correctamente en todos los modelos de iPhone. Usar un stack view (0,75 puntos) \u00b6 Usa un stack view en la pantalla principal (la de los botones) para que estos aparezcan ocupando toda la pantalla sea cual sea la resoluci\u00f3n. (no es necesario que sea estrictamente toda la pantalla, puedes dejar un margen alrededor de los botones si lo prefieres). A\u00f1adir restricciones de manera visual (0,75 puntos) \u00b6 A\u00f1adid restricciones a la pantalla secundaria (la que muestra informaci\u00f3n sobre cada pionera). Se deben cumplir las siguientes condiciones: El text view debe aparecer centrado horizontal y verticalmente El bot\u00f3n debe aparecer en la parte inferior de la pantalla y centrado horizontalmente","title":"Ejercicios"},{"location":"3_autolayout/ejercicios/#ejercicios-de-autolayout-15-puntos","text":"El objetivo es a\u00f1adir autolayout a la aplicaci\u00f3n de \u201cpioneras\u201d que hicimos en sesiones anteriores para que la interfaz se vea correctamente en todos los modelos de iPhone.","title":"Ejercicios de Autolayout (1,5 puntos)"},{"location":"3_autolayout/ejercicios/#usar-un-stack-view-075-puntos","text":"Usa un stack view en la pantalla principal (la de los botones) para que estos aparezcan ocupando toda la pantalla sea cual sea la resoluci\u00f3n. (no es necesario que sea estrictamente toda la pantalla, puedes dejar un margen alrededor de los botones si lo prefieres).","title":"Usar un stack view (0,75 puntos)"},{"location":"3_autolayout/ejercicios/#anadir-restricciones-de-manera-visual-075-puntos","text":"A\u00f1adid restricciones a la pantalla secundaria (la que muestra informaci\u00f3n sobre cada pionera). Se deben cumplir las siguientes condiciones: El text view debe aparecer centrado horizontal y verticalmente El bot\u00f3n debe aparecer en la parte inferior de la pantalla y centrado horizontalmente","title":"A\u00f1adir restricciones de manera visual (0,75 puntos)"},{"location":"4_tablas/apuntes/","text":"Tablas \u00b6 Introducci\u00f3n \u00b6 Las vistas de tabla ( UITableView ) se encargan de mostrar, gestionar y hacer scrolling de una tabla de elementos de una sola columna. Cada una de las filas se modela con un UITableViewCell . Si necesitamos m\u00e1s de una columna podemos usar UICollectionView , que ver\u00e9is en la parte \u201cavanzada\u201d de la asignatura. Descritas as\u00ed, puede parecer que las tablas deben desempe\u00f1ar un papel muy limitado en las aplicaciones iOS, pero nada m\u00e1s lejos de la realidad. Son la forma m\u00e1s habitual en aplicaciones m\u00f3viles de mostrar listas de elementos, no solo en iOS sino en todas las plataformas. Adem\u00e1s su aspecto visual es enormemente configurable, con lo que que muchas \"pantallas\" de apps que a primera vista no lo parecen, en realidad son tablas, por ejemplo en las aplicaciones de Mail, Ajustes, Reloj\u2026 Las tablas pueden ser simples ( UITableViewStylePlain ) o agrupadas ( UITableViewStyleGrouped ) Hay varios estilos predefinidos para las filas, que nos permiten mostrar diversos elementos: t\u00edtulo, subt\u00edtulo, icono a la izquierda, \u2026 Tambi\u00e9n podemos crear nuestros propios estilos de celda bien por c\u00f3digo o bien gr\u00e1ficamente en el interface builder . Creaci\u00f3n de vistas de tabla \u00b6 Una vista de tabla interact\u00faa b\u00e1sicamente con tres objetos (aunque podemos implementar todas las funcionalidades en una \u00fanica clase, como se suele hacer en los casos m\u00e1s simples) En primer lugar, el view controller . Ya hemos visto el papel que hace en las aplicaciones. En segundo lugar, el data source : las vistas de tabla solo almacenan directamente los datos de las filas actualmente visibles en pantalla. El resto se los piden a un objeto que debe ser conforme al protocolo UITableViewDataSource . Este es obligatorio, no podemos crear una tabla sin \u00e9l. Y finalmente el delegate : para gestionar algunos eventos de manipulaci\u00f3n de la tabla (como la edici\u00f3n, el borrado, o el mover una fila) y controlar algunos aspectos de la apariencia de las celdas, se usa el UITableViewDelegate Es muy habitual que el controller , el delegate y el data source sean el mismo objeto. Si usamos una vista de tabla dibujada en el storyboard podemos conectarla con los dos \u201ccolaboradores\u201d gr\u00e1ficamente mediante el \u201cConnections Inspector\u201d del panel \u201cUtilities\u201d Tablas est\u00e1ticas \u00b6 En algunos casos conocemos de partida los elementos que queremos dibujar en la tabla. Ejemplo t\u00edpico de esto es la aplicaci\u00f3n de Ajustes , en la que las opciones est\u00e1n colocadas en una tabla simplemente para que est\u00e9n m\u00e1s organizadas y tengan un formato atractivo. Esto lo podemos conseguir con una tabla est\u00e1tica . Para crear una pantalla con una tabla est\u00e1tica arrastramos un Table View Controller al storyboard . Es un controller asociado a una vista de tabla que ocupa toda la pantalla del dispositivo. Por defecto usa una tabla din\u00e1mica, pero podemos cambiarlo seleccionando la tabla en el Attributes inspector y seleccionando Static Cells en la primera propiedad, Content . Podemos a\u00f1adir secciones a la tabla y cambiar el n\u00famero de celdas en cada secci\u00f3n. Para poder cambiar el n\u00famero de celdas hay que tener seleccionada la secci\u00f3n deseada, lo que a veces es dif\u00edcil con el rat\u00f3n, por lo que podemos usar los nodos del Document outline : Podemos aumentar el n\u00famero de celdas de modo que no quepan en la pantalla. Para desplazarnos por la tabla podemos seleccionarla y hacer scroll con la rueda del rat\u00f3n Tablas din\u00e1micas \u00b6 En este tipo de tablas los datos son din\u00e1micos: no se conocen por adelantado cuando se est\u00e1 dise\u00f1ando la aplicaci\u00f3n y suelen proceder de alguna fuente externa como una base de datos o un servidor. Vamos a ver primero c\u00f3mo crear la tabla en s\u00ed y luego el objeto que va a ocuparse de los datos que queremos mostrar en la tabla El objeto Tabla \u00b6 La tabla en s\u00ed es una componente m\u00e1s de interfaz de usuario, como un bot\u00f3n, un slider ,\u2026 Para crear una tabla, arrastramos un table view desde la librer\u00eda de componentes de la parte inferior derecha de Xcode Cuidado: no us\u00e9is para este caso un table view controller sino un table view . El primero incluye no solo la tabla en s\u00ed sino tambi\u00e9n un controller , y la tabla ocupa todo el tama\u00f1o de la pantalla y no se puede cambiar de tama\u00f1o. Una vez creada la tabla, nos vamos al attributes inspector (icono , en la parte superior derecha de Xcode) y hacemos que el Content sea Dynamic prototypes y el n\u00famero de Prototype cells al menos 1. Veremos que en la tabla aparece una \u201csecci\u00f3n\u201d titulada Prototype cells . En esta aparecen los prototypes o plantillas en las que se basar\u00e1n las celdas de nuestra tabla. En muchas tablas todas las celdas son iguales y por eso nos basta con un prototipo, pero podemos crear los necesarios. Para editar gr\u00e1ficamente el prototipo basta con seleccionarlo con el rat\u00f3n y editarlo cambiando sus atributos con el attributes inspector . El m\u00e1s importante es el Style . Podemos usar uno propio ( Custom ) o uno de los predefinidos Para cada estilo tenemos una serie de elementos con los que podemos \u201cjugar\u201d: un t\u00edtulo, una imagen, en algunos casos un texto adicional\u2026. En general, como queremos que el contenido concreto de la celda sea distinto para cada una, lo que haremos ser\u00e1 fijarlos por c\u00f3digo. Aqu\u00ed solo elegimos el aspecto general y si ciertos elementos estar\u00e1n o no presentes. Por ejemplo en el estilo basic la celda solo contiene un texto, mientras que en el detail contiene uno m\u00e1s grande y otro m\u00e1s peque\u00f1o. Otro atributo importante es el reuse identifier , donde escribiremos un identificador inventado por nosotros para este prototipo. Cuando hablemos del datasource veremos d\u00f3nde referenciar este identificador en nuestro c\u00f3digo. La fuente de datos o datasource \u00b6 En iOS se usa el patr\u00f3n delegaci\u00f3n para delegar en otro objeto distinto a la propia tabla la responsabilidad de devolver los datos cuando es necesario pintarlos en pantalla. Este delegado se denomina en iOS datasource . Cuando iOS necesite pintar una celda le pedir\u00e1 al datasource que se la devuelva rellenada con sus contenidos. El datasource puede ser cualquier objeto con tal de que implemente el protocol UITableViewDataSource . En los ejemplos m\u00e1s sencillos habitualmente es el controller de la pantalla en la que est\u00e1 la tabla, aunque este enfoque suele llevar a que acabe habiendo demasiado c\u00f3digo en el controller . Por ello nosotros vamos a usar otra clase adicional Implementar el datasource Como hemos dicho, nuestro objeto debe implementar el protocolo UITableViewDataSource . Este protocolo tiene dos m\u00e9todos obligatorios: Un m\u00e9todo que dado un n\u00famero de secci\u00f3n nos devuelva cu\u00e1ntas filas hay en esa secci\u00f3n. Un m\u00e9todo que dado un n\u00famero de fila nos devuelva una UITableViewCell , que es un objeto de interfaz de usuario que representa una celda. Dicho objeto contiene b\u00e1sicamente el texto a mostrar en la celda, m\u00e1s alguna informaci\u00f3n adicional. Como vemos, son dos tareas que puede y debe hacer el objeto que controle los datos a mostrar, otro objeto no tendr\u00eda esta informaci\u00f3n. Antes de empezar a implementar los m\u00e9todos tendremos que indicar que nuestra clase implementa el protocolo UITableViewDataSource . Un requisito adicional, \u201cfruto\u201d de la \u201cera\u201d de Objective-C es que el datasource debe heredar de la clase Obj-C NSObject , definida en el framework Foundation , as\u00ed que el esqueleto inicial de nuestra clase ser\u00eda algo como: 1 2 3 class MiDataSource : NSObject , UITableViewDataSource { //Definici\u00f3n de la clase } Si usamos un controller como datasource , como es habitual en la mayor\u00eda de ejemplos que ver\u00e1s en libros y en tutoriales en la web, no ser\u00e1 necesario especificar la herencia de NSObject porque los controller ya heredan por defecto de esta clase. Vamos a hacer un ejemplo sencillo en el que cada celda simplemente muestra el n\u00famero de fila en que est\u00e1, y tenemos 1000 celdas. En un ejemplo algo m\u00e1s realista, los datos estar\u00edan almacenados en una BD, o bien en un array en memoria. El m\u00e9todo que devuelve el n\u00famero de celdas para una secci\u00f3n debe tener la signatura tableView(_:, numberOfRowsInSection:) . Aqu\u00ed tenemos la implementaci\u00f3n para nuestro ejemplo sencillo, que devolver\u00e1 simplemente 1000. En una BD tendr\u00edamos que devolver el n\u00famero de registros, o en un array su propiedad count 1 2 3 4 func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return 1000 } El m\u00e9todo que devuelve una celda dada una fila debe tener la signatura tableView(_:, cellForRowAt:) , y es algo m\u00e1s complicado que el anterior. Vamos a ver primero una implementaci\u00f3n \u201cingenua\u201d, que simplemente crea la UITableViewCell , la rellena de contenido y la devuelve. En un momento veremos que este c\u00f3digo es muy ineficiente y no deber\u00edamos usarlo tal cual en una aplicaci\u00f3n real . Pero por el momento nos sirve para discutir qu\u00e9 significan los par\u00e1metros y c\u00f3mo construir un objeto celda. 1 2 3 4 5 6 7 8 func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { //instanciamos una nueva celda let celda = UITableViewCell ( style : . default , reuseIdentifier : \"\" ) //la rellenamos de contenido celda . textLabel ?. text = \"Celda n\u00famero \\( indexPath . row ) \" return celda } Algunas consideraciones sobre el c\u00f3digo anterior: - Un IndexPath es un struct que almacena informaci\u00f3n sobre la posici\u00f3n de una celda. Contiene b\u00e1sicamente el n\u00famero de fila (propiedad row ) y el n\u00famero de secci\u00f3n (propiedad section . Ignoramos este \u00faltimo ya que nuestro ejemplo tiene una \u00fanica secci\u00f3n. - Al inicializador de UITableViewCell le pasamos el estilo de la celda (en principio de entre los predefinidos) y luego el reuseIdentifier , que luego veremos qu\u00e9 es. De momento pasamos la cadena vac\u00eda. Lo que acabamos de hacer, crear un nuevo UITableViewCell por cada fila es muy ineficiente dado que una tabla puede tener cientos o miles de ellas. Por eso se suele usar un truco ingenioso: se crea un peque\u00f1o n\u00famero de celdas (las que se ven simult\u00e1neamente en pantalla) y luego se reutilizan conforme se va haciendo scroll por la tabla, rellen\u00e1ndolas con los nuevos datos. iOS ofrece soporte para esta reutilizaci\u00f3n manteniendo un pool de celdas que podemos reutilizar para rellenar con nuevos datos. Podemos sacar una celda del pool con el m\u00e9todo de la vista de tabla dequeueReusableCell(withIdentifier:) . El identificador sirve para etiquetar el \u201ctipo\u201d de celda. En casos m\u00e1s complicados podr\u00edamos tener varios pool con distintos tipos de celda para reutilizar. En el ejemplo usaremos un \u00fanico identificador (es arbitrario y lo elige el desarrollador). MUY IMPORTANTE: el identificador del reuseIdentifier debe ser el mismo que elegimos gr\u00e1ficamente al editar el prototipo de la celda. Si no fallar\u00e1 nuestro c\u00f3digo La nueva versi\u00f3n del c\u00f3digo queda as\u00ed: 1 2 3 4 5 6 7 func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let nuevaCelda = tableView . dequeueReusableCell ( withIdentifier : \"unaCelda\" , for : indexPath ) nuevaCelda . textLabel ?. text = datos [ indexPath . row ] return nuevaCelda } Conectar la tabla y el datasource Podemos hacer la conexi\u00f3n usando dos m\u00e9todos alternativos: gr\u00e1ficamente o por c\u00f3digo. Cuando el datasource es una clase adicional es algo m\u00e1s sencillo por c\u00f3digo. Cuando es el controller la forma m\u00e1s directa es la gr\u00e1fica. Como en el ejemplo de la secci\u00f3n anterior hemos hecho que el datasource sea una clase adicional, vamos a ver en primer lugar c\u00f3mo se har\u00eda la conexi\u00f3n por c\u00f3digo . Basta con asignar la propiedad dataSource del objeto tabla a una instancia de nuestro objeto datasource . Por ejemplo podr\u00edamos hacer la asignaci\u00f3n en el viewDidLoad() del controller de la pantalla donde est\u00e1 la tabla: 1 2 3 4 5 6 7 8 9 10 //Este outlet lo habr\u00edamos creado gr\u00e1ficamente con Xcode @IBOutlet weak var miTabla : UITableView ! //guardamos el datasource como una propiedad del controller var miDS : MiDataSource ! override func viewDidLoad () { super . viewDidLoad () self . miDS = MiDataSource () //asignamos el datasource como el delegado de la tabla self . miTabla . dataSource = miDS } En el c\u00f3digo anterior puede parecer que podr\u00edamos ahorrarnos la variable miDS y asignar directamente el dataSource a una nueva instancia, es decir self.miTabla.dataSource = MiDataSource() . Pero esto no funcionar\u00e1 y la tabla aparecer\u00e1 vac\u00eda. Si consultamos la documentaci\u00f3n del API de iOS veremos que la propiedad dataSource es weak , lo que significa que si el objeto referenciado por ella no est\u00e1 referenciado por ninguna variable m\u00e1s, iOS considerar\u00e1 que puede liberar la memoria ocupada por \u00e9l. En consecuencia el dataSource se quedar\u00eda vac\u00edo y no aparecer\u00edan los datos. En el c\u00f3digo anterior accedemos al objeto tabla con un outlet creado previamente en Xcode de modo gr\u00e1fico, pero esto no parece tener mucho sentido si hemos dicho que \u00edbamos a establecer la conexi\u00f3n por c\u00f3digo. Si no estamos usando el outlet para alguna tarea adicional, una alternativa ser\u00eda asignar un tag fijo a la tabla (por ejemplo 100) y acceder a ella con self.view.viewWithTag(tag:100) Otra alternativa a lo anterior es hacer la conexi\u00f3n con Xcode. Para conectar gr\u00e1ficamente la tabla con el *datasource * primero necesitamos tener una \u201crepresentaci\u00f3n gr\u00e1fica\u201d en pantalla del objeto MiDataSource con el que queremos conectar. Podemos arrastrar a la pantalla un Object de la librer\u00eda de objetos de la parte inferior derecha de Xcode. Este es como si fuera un componente m\u00e1s de la interfaz gr\u00e1fica pero no tiene representaci\u00f3n en pantalla. En lugar de arrastrarlo a la pantalla en s\u00ed como ocurre con los componentes gr\u00e1ficos convencionales, debemos arrastrarlo al \u00e1rbol de componentes que aparece a su izquierda Una vez colocado aqu\u00ed, vamos a indicar que este objeto es de la clase MiDataSource . Para ello usamos el Identity inspector , y en la propiedad Custom class escribimos el nombre de la clase Ya podemos conectar la propiedad dataSource de la tabla con este objeto. La propiedad la podemos ver si seleccionamos la tabla con el rat\u00f3n y vamos al Connections inspector (el icono del \u00e1rea de Utilities ). Arrastramos con el rat\u00f3n (no hace falta Ctrl ) desde el c\u00edrculo que representa al datasource hasta el icono del objeto que representa a la clase MiDataSource Gesti\u00f3n de tablas \u00b6 En las tablas din\u00e1micas podemos por supuesto insertar y eliminar celdas. Tambi\u00e9n podemos seleccionarlas haciendo tap sobre ellas. Para evitar que la propia tabla se tenga que hacer cargo de estas tareas se usa de nuevo el patr\u00f3n delegaci\u00f3n : designamos una instancia de una clase determinada que se encargar\u00e1 de procesar la inserci\u00f3n y el borrado. Esta instancia se le debe asignar a la propiedad delegate de la tabla, bien por c\u00f3digo o bien gr\u00e1ficamente, como hac\u00edamos en el caso del dataSource . Aunque la tarea primaria es cosa del delegate , el dataSource ser\u00e1 avisado si se va a insertar o eliminar alguna celda, para que procese los datos El delegate tendr\u00e1 que ser de una clase que implemente el protocolo UITableViewDelegate . Este protocolo proporciona m\u00e9todos para manejar secciones de la tabla, configurar las cabeceras y pies de cada secci\u00f3n, gestionar qu\u00e9 hacer cuando se selecciona una celda, insertar, eliminar y reordenar celdas, y algunas otras tareas. En casi todos los ejemplos que ver\u00e9is en libros y en la web se suele hacer que el controller act\u00fae de delegate para simplificar el c\u00f3digo y reducir el n\u00famero de clases del ejemplo, pero a cambio complicamos el c\u00f3digo del controller . El c\u00f3digo de una clase que act\u00fae de delegate de tabla debe tener el siguiente esqueleto b\u00e1sico. Al igual que en el caso del dataSource , la herencia de NSObject es a su vez \u201cherencia\u201d de la \u00e9poca de Objective-C 1 2 3 4 5 6 import Foundation import UIKit class MiDelegate : NSObject , UITableViewDelegate { //definici\u00f3n de la clase } En los siguientes apartados solo vamos a discutir c\u00f3mo implementar los m\u00e9todos del protocolo UITableViewDelegate , no c\u00f3mo hacer la conexi\u00f3n entre la tabla y el delegate , ya que la conexi\u00f3n se hace pr\u00e1cticamente igual que cuando habl\u00e1bamos del datasource , sea por c\u00f3digo o gr\u00e1ficamente. Seleccionar celdas \u00b6 Cuando el usuario selecciona una celda haciendo tap sobre ella se llama al m\u00e9todo tableView(_: didSelectRowAt:) del delegate . Como ejemplo vamos a ver c\u00f3mo implementar\u00edamos este m\u00e9todo de forma que cuando se seleccione una celda se ponga en ella una marca de verificaci\u00f3n, y que si ya est\u00e1 se quite. En las celdas predefinidas, esta marca (y otras similares) se controla con la propiedad accessoryType de la celda. 1 2 3 4 5 6 7 8 9 10 11 12 13 func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let celda = tableView . cellForRow ( at : indexPath ) { //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos if celda . accessoryType == UITableViewCellAccessoryType . none { celda . accessoryType = . checkmark } else { celda . accessoryType = . none } //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris tableView . deselectRow ( at : indexPath , animated : true ) } } Insertar y eliminar filas \u00b6 iOS nos ofrece de forma autom\u00e1tica el \u201cmodo edici\u00f3n\u201d, en el que en la parte izquierda de cada celda aparece un icono indicador de las operaciones que se pueden hacer con ella. Hay dos indicadores: - Una se\u00f1al de \u201cprohibido\u201d para poder borrar la celda(pulsando sobre la se\u00f1al y luego sobre el bot\u00f3n \u201cBorrar\u201d que aparece). - Un s\u00edmbolo de \u2018+\u2019 que sirve para insertar una nueva celda Podemos activar el modo edici\u00f3n con el m\u00e9todo setEditing del objeto tabla: 1 2 // suponemos que \"miTabla\" es un outlet a la tabla self . miTabla . setEditing ( true , animated : true ); Por defecto al activar el modo edici\u00f3n en todas las celdas aparecer\u00e1 la se\u00f1al de \u201cprohibido\u201d. Implementando en el delegate el m\u00e9todo tableView(_:,editingStyleForRowAt:) podemos especificar qu\u00e9 tipo de estilo de edici\u00f3n queremos para una celda determinada. El sistema nos \u201cpreguntar\u00e1\u201d el estilo de edici\u00f3n para un n\u00famero de celda y debemos devolver UITableViewCellEditingStyle.delete o bien UITableViewCellEditingStyle.insert . Aunque el modo edici\u00f3n es autom\u00e1tico, el borrado efectivo de las celdas y de su contenido lo tenemos que hacer nosotros, al igual que la inserci\u00f3n. iOS avisar\u00e1 al datasource de que se est\u00e1 intentando insertar o eliminar una celda, NO al *delegate . Esto es l\u00f3gico ya que los datos los gestiona el datasource*. As\u00ed, cuando se pulse sobre el y luego sobre \u201cdelete\u201d o sobre el , se llamar\u00e1 al m\u00e9todo del datasource llamado tableView(_:, commit:, forRowAt:) . En este m\u00e9todo tenemos que hacer dos cosas: - Actualizar los datos (borrar el dato o insertar uno nuevo) - LLamar a un m\u00e9todo del API de tabla para que esta inserci\u00f3n o borrado se represente de manera visual (que gr\u00e1ficamente aparezca o desaparezca la celda) Es muy importante destacar que primero hay que actualizar los datos y luego ocuparse de la parte gr\u00e1fica. Si lo hacemos al rev\u00e9s no funcionar\u00e1 bien, ya que iOS intentar\u00e1 redibujar la tabla usando los datos \u201cantiguos\u201d. Simplemente implementando el siguiente m\u00e9todo (aunque estuviera vac\u00edo) activaremos el swipe to delete , pero el bot\u00f3n delete no va a funcionar salvo que implementemos el borrado como aqu\u00ed se muestra 1 2 3 4 5 6 7 8 9 10 func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCellEditingStyle , forRowAt indexPath : IndexPath ) { if editingStyle == UITableViewCellEditingStyle . delete { self . datos . remove ( at : indexPath . row ) tableView . deleteRows ( at : [ indexPath ], with : UITableViewRowAnimation . fade ) } else if editingStyle == UITableViewCellEditingStyle . insert { self . datos . insert ( \"Nueva celda\" , at : indexPath . row ) tableView . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . bottom ) } } N\u00f3tese que los m\u00e9todos insertRows y deleteRows permiten insertar o borrar varias celdas a la vez y por ello como primer par\u00e1metro requieren un array de indexPath , y no un indexPath directamente. Si insertamos/borramos una \u00fanica celda ser\u00e1 un array de un \u00fanico componente. Esto que hemos visto se aplica a cuando la inserci\u00f3n o eliminaci\u00f3n las dispara el propio iOS pulsando en los botones del sistema. Pero tambi\u00e9n podemos disparar nosotros manualmente la inserci\u00f3n o eliminaci\u00f3n. Por ejemplo veamos c\u00f3mo se insertar\u00eda una nueva celda \u201cmanualmente\u201d al principio de la tabla. 1 2 3 4 5 6 7 //primero hay que actualizar los datos self . datos . insert ( \"Nueva celda\" , at : 0 ) //y ahora visualmente insertar la celda let indexPath = IndexPath ( row : 0 , section : 0 ) //suponemos que tenemos accesible la tabla, la necesitamos tabla . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . fade )","title":"Tablas"},{"location":"4_tablas/apuntes/#tablas","text":"","title":"Tablas"},{"location":"4_tablas/apuntes/#introduccion","text":"Las vistas de tabla ( UITableView ) se encargan de mostrar, gestionar y hacer scrolling de una tabla de elementos de una sola columna. Cada una de las filas se modela con un UITableViewCell . Si necesitamos m\u00e1s de una columna podemos usar UICollectionView , que ver\u00e9is en la parte \u201cavanzada\u201d de la asignatura. Descritas as\u00ed, puede parecer que las tablas deben desempe\u00f1ar un papel muy limitado en las aplicaciones iOS, pero nada m\u00e1s lejos de la realidad. Son la forma m\u00e1s habitual en aplicaciones m\u00f3viles de mostrar listas de elementos, no solo en iOS sino en todas las plataformas. Adem\u00e1s su aspecto visual es enormemente configurable, con lo que que muchas \"pantallas\" de apps que a primera vista no lo parecen, en realidad son tablas, por ejemplo en las aplicaciones de Mail, Ajustes, Reloj\u2026 Las tablas pueden ser simples ( UITableViewStylePlain ) o agrupadas ( UITableViewStyleGrouped ) Hay varios estilos predefinidos para las filas, que nos permiten mostrar diversos elementos: t\u00edtulo, subt\u00edtulo, icono a la izquierda, \u2026 Tambi\u00e9n podemos crear nuestros propios estilos de celda bien por c\u00f3digo o bien gr\u00e1ficamente en el interface builder .","title":"Introducci\u00f3n"},{"location":"4_tablas/apuntes/#creacion-de-vistas-de-tabla","text":"Una vista de tabla interact\u00faa b\u00e1sicamente con tres objetos (aunque podemos implementar todas las funcionalidades en una \u00fanica clase, como se suele hacer en los casos m\u00e1s simples) En primer lugar, el view controller . Ya hemos visto el papel que hace en las aplicaciones. En segundo lugar, el data source : las vistas de tabla solo almacenan directamente los datos de las filas actualmente visibles en pantalla. El resto se los piden a un objeto que debe ser conforme al protocolo UITableViewDataSource . Este es obligatorio, no podemos crear una tabla sin \u00e9l. Y finalmente el delegate : para gestionar algunos eventos de manipulaci\u00f3n de la tabla (como la edici\u00f3n, el borrado, o el mover una fila) y controlar algunos aspectos de la apariencia de las celdas, se usa el UITableViewDelegate Es muy habitual que el controller , el delegate y el data source sean el mismo objeto. Si usamos una vista de tabla dibujada en el storyboard podemos conectarla con los dos \u201ccolaboradores\u201d gr\u00e1ficamente mediante el \u201cConnections Inspector\u201d del panel \u201cUtilities\u201d","title":"Creaci\u00f3n de vistas de tabla"},{"location":"4_tablas/apuntes/#tablas-estaticas","text":"En algunos casos conocemos de partida los elementos que queremos dibujar en la tabla. Ejemplo t\u00edpico de esto es la aplicaci\u00f3n de Ajustes , en la que las opciones est\u00e1n colocadas en una tabla simplemente para que est\u00e9n m\u00e1s organizadas y tengan un formato atractivo. Esto lo podemos conseguir con una tabla est\u00e1tica . Para crear una pantalla con una tabla est\u00e1tica arrastramos un Table View Controller al storyboard . Es un controller asociado a una vista de tabla que ocupa toda la pantalla del dispositivo. Por defecto usa una tabla din\u00e1mica, pero podemos cambiarlo seleccionando la tabla en el Attributes inspector y seleccionando Static Cells en la primera propiedad, Content . Podemos a\u00f1adir secciones a la tabla y cambiar el n\u00famero de celdas en cada secci\u00f3n. Para poder cambiar el n\u00famero de celdas hay que tener seleccionada la secci\u00f3n deseada, lo que a veces es dif\u00edcil con el rat\u00f3n, por lo que podemos usar los nodos del Document outline : Podemos aumentar el n\u00famero de celdas de modo que no quepan en la pantalla. Para desplazarnos por la tabla podemos seleccionarla y hacer scroll con la rueda del rat\u00f3n","title":"Tablas est\u00e1ticas"},{"location":"4_tablas/apuntes/#tablas-dinamicas","text":"En este tipo de tablas los datos son din\u00e1micos: no se conocen por adelantado cuando se est\u00e1 dise\u00f1ando la aplicaci\u00f3n y suelen proceder de alguna fuente externa como una base de datos o un servidor. Vamos a ver primero c\u00f3mo crear la tabla en s\u00ed y luego el objeto que va a ocuparse de los datos que queremos mostrar en la tabla","title":"Tablas din\u00e1micas"},{"location":"4_tablas/apuntes/#el-objeto-tabla","text":"La tabla en s\u00ed es una componente m\u00e1s de interfaz de usuario, como un bot\u00f3n, un slider ,\u2026 Para crear una tabla, arrastramos un table view desde la librer\u00eda de componentes de la parte inferior derecha de Xcode Cuidado: no us\u00e9is para este caso un table view controller sino un table view . El primero incluye no solo la tabla en s\u00ed sino tambi\u00e9n un controller , y la tabla ocupa todo el tama\u00f1o de la pantalla y no se puede cambiar de tama\u00f1o. Una vez creada la tabla, nos vamos al attributes inspector (icono , en la parte superior derecha de Xcode) y hacemos que el Content sea Dynamic prototypes y el n\u00famero de Prototype cells al menos 1. Veremos que en la tabla aparece una \u201csecci\u00f3n\u201d titulada Prototype cells . En esta aparecen los prototypes o plantillas en las que se basar\u00e1n las celdas de nuestra tabla. En muchas tablas todas las celdas son iguales y por eso nos basta con un prototipo, pero podemos crear los necesarios. Para editar gr\u00e1ficamente el prototipo basta con seleccionarlo con el rat\u00f3n y editarlo cambiando sus atributos con el attributes inspector . El m\u00e1s importante es el Style . Podemos usar uno propio ( Custom ) o uno de los predefinidos Para cada estilo tenemos una serie de elementos con los que podemos \u201cjugar\u201d: un t\u00edtulo, una imagen, en algunos casos un texto adicional\u2026. En general, como queremos que el contenido concreto de la celda sea distinto para cada una, lo que haremos ser\u00e1 fijarlos por c\u00f3digo. Aqu\u00ed solo elegimos el aspecto general y si ciertos elementos estar\u00e1n o no presentes. Por ejemplo en el estilo basic la celda solo contiene un texto, mientras que en el detail contiene uno m\u00e1s grande y otro m\u00e1s peque\u00f1o. Otro atributo importante es el reuse identifier , donde escribiremos un identificador inventado por nosotros para este prototipo. Cuando hablemos del datasource veremos d\u00f3nde referenciar este identificador en nuestro c\u00f3digo.","title":"El objeto Tabla"},{"location":"4_tablas/apuntes/#la-fuente-de-datos-o-datasource","text":"En iOS se usa el patr\u00f3n delegaci\u00f3n para delegar en otro objeto distinto a la propia tabla la responsabilidad de devolver los datos cuando es necesario pintarlos en pantalla. Este delegado se denomina en iOS datasource . Cuando iOS necesite pintar una celda le pedir\u00e1 al datasource que se la devuelva rellenada con sus contenidos. El datasource puede ser cualquier objeto con tal de que implemente el protocol UITableViewDataSource . En los ejemplos m\u00e1s sencillos habitualmente es el controller de la pantalla en la que est\u00e1 la tabla, aunque este enfoque suele llevar a que acabe habiendo demasiado c\u00f3digo en el controller . Por ello nosotros vamos a usar otra clase adicional","title":"La fuente de datos o datasource"},{"location":"4_tablas/apuntes/#gestion-de-tablas","text":"En las tablas din\u00e1micas podemos por supuesto insertar y eliminar celdas. Tambi\u00e9n podemos seleccionarlas haciendo tap sobre ellas. Para evitar que la propia tabla se tenga que hacer cargo de estas tareas se usa de nuevo el patr\u00f3n delegaci\u00f3n : designamos una instancia de una clase determinada que se encargar\u00e1 de procesar la inserci\u00f3n y el borrado. Esta instancia se le debe asignar a la propiedad delegate de la tabla, bien por c\u00f3digo o bien gr\u00e1ficamente, como hac\u00edamos en el caso del dataSource . Aunque la tarea primaria es cosa del delegate , el dataSource ser\u00e1 avisado si se va a insertar o eliminar alguna celda, para que procese los datos El delegate tendr\u00e1 que ser de una clase que implemente el protocolo UITableViewDelegate . Este protocolo proporciona m\u00e9todos para manejar secciones de la tabla, configurar las cabeceras y pies de cada secci\u00f3n, gestionar qu\u00e9 hacer cuando se selecciona una celda, insertar, eliminar y reordenar celdas, y algunas otras tareas. En casi todos los ejemplos que ver\u00e9is en libros y en la web se suele hacer que el controller act\u00fae de delegate para simplificar el c\u00f3digo y reducir el n\u00famero de clases del ejemplo, pero a cambio complicamos el c\u00f3digo del controller . El c\u00f3digo de una clase que act\u00fae de delegate de tabla debe tener el siguiente esqueleto b\u00e1sico. Al igual que en el caso del dataSource , la herencia de NSObject es a su vez \u201cherencia\u201d de la \u00e9poca de Objective-C 1 2 3 4 5 6 import Foundation import UIKit class MiDelegate : NSObject , UITableViewDelegate { //definici\u00f3n de la clase } En los siguientes apartados solo vamos a discutir c\u00f3mo implementar los m\u00e9todos del protocolo UITableViewDelegate , no c\u00f3mo hacer la conexi\u00f3n entre la tabla y el delegate , ya que la conexi\u00f3n se hace pr\u00e1cticamente igual que cuando habl\u00e1bamos del datasource , sea por c\u00f3digo o gr\u00e1ficamente.","title":"Gesti\u00f3n de tablas"},{"location":"4_tablas/apuntes/#seleccionar-celdas","text":"Cuando el usuario selecciona una celda haciendo tap sobre ella se llama al m\u00e9todo tableView(_: didSelectRowAt:) del delegate . Como ejemplo vamos a ver c\u00f3mo implementar\u00edamos este m\u00e9todo de forma que cuando se seleccione una celda se ponga en ella una marca de verificaci\u00f3n, y que si ya est\u00e1 se quite. En las celdas predefinidas, esta marca (y otras similares) se controla con la propiedad accessoryType de la celda. 1 2 3 4 5 6 7 8 9 10 11 12 13 func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let celda = tableView . cellForRow ( at : indexPath ) { //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos if celda . accessoryType == UITableViewCellAccessoryType . none { celda . accessoryType = . checkmark } else { celda . accessoryType = . none } //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris tableView . deselectRow ( at : indexPath , animated : true ) } }","title":"Seleccionar celdas"},{"location":"4_tablas/apuntes/#insertar-y-eliminar-filas","text":"iOS nos ofrece de forma autom\u00e1tica el \u201cmodo edici\u00f3n\u201d, en el que en la parte izquierda de cada celda aparece un icono indicador de las operaciones que se pueden hacer con ella. Hay dos indicadores: - Una se\u00f1al de \u201cprohibido\u201d para poder borrar la celda(pulsando sobre la se\u00f1al y luego sobre el bot\u00f3n \u201cBorrar\u201d que aparece). - Un s\u00edmbolo de \u2018+\u2019 que sirve para insertar una nueva celda Podemos activar el modo edici\u00f3n con el m\u00e9todo setEditing del objeto tabla: 1 2 // suponemos que \"miTabla\" es un outlet a la tabla self . miTabla . setEditing ( true , animated : true ); Por defecto al activar el modo edici\u00f3n en todas las celdas aparecer\u00e1 la se\u00f1al de \u201cprohibido\u201d. Implementando en el delegate el m\u00e9todo tableView(_:,editingStyleForRowAt:) podemos especificar qu\u00e9 tipo de estilo de edici\u00f3n queremos para una celda determinada. El sistema nos \u201cpreguntar\u00e1\u201d el estilo de edici\u00f3n para un n\u00famero de celda y debemos devolver UITableViewCellEditingStyle.delete o bien UITableViewCellEditingStyle.insert . Aunque el modo edici\u00f3n es autom\u00e1tico, el borrado efectivo de las celdas y de su contenido lo tenemos que hacer nosotros, al igual que la inserci\u00f3n. iOS avisar\u00e1 al datasource de que se est\u00e1 intentando insertar o eliminar una celda, NO al *delegate . Esto es l\u00f3gico ya que los datos los gestiona el datasource*. As\u00ed, cuando se pulse sobre el y luego sobre \u201cdelete\u201d o sobre el , se llamar\u00e1 al m\u00e9todo del datasource llamado tableView(_:, commit:, forRowAt:) . En este m\u00e9todo tenemos que hacer dos cosas: - Actualizar los datos (borrar el dato o insertar uno nuevo) - LLamar a un m\u00e9todo del API de tabla para que esta inserci\u00f3n o borrado se represente de manera visual (que gr\u00e1ficamente aparezca o desaparezca la celda) Es muy importante destacar que primero hay que actualizar los datos y luego ocuparse de la parte gr\u00e1fica. Si lo hacemos al rev\u00e9s no funcionar\u00e1 bien, ya que iOS intentar\u00e1 redibujar la tabla usando los datos \u201cantiguos\u201d. Simplemente implementando el siguiente m\u00e9todo (aunque estuviera vac\u00edo) activaremos el swipe to delete , pero el bot\u00f3n delete no va a funcionar salvo que implementemos el borrado como aqu\u00ed se muestra 1 2 3 4 5 6 7 8 9 10 func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCellEditingStyle , forRowAt indexPath : IndexPath ) { if editingStyle == UITableViewCellEditingStyle . delete { self . datos . remove ( at : indexPath . row ) tableView . deleteRows ( at : [ indexPath ], with : UITableViewRowAnimation . fade ) } else if editingStyle == UITableViewCellEditingStyle . insert { self . datos . insert ( \"Nueva celda\" , at : indexPath . row ) tableView . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . bottom ) } } N\u00f3tese que los m\u00e9todos insertRows y deleteRows permiten insertar o borrar varias celdas a la vez y por ello como primer par\u00e1metro requieren un array de indexPath , y no un indexPath directamente. Si insertamos/borramos una \u00fanica celda ser\u00e1 un array de un \u00fanico componente. Esto que hemos visto se aplica a cuando la inserci\u00f3n o eliminaci\u00f3n las dispara el propio iOS pulsando en los botones del sistema. Pero tambi\u00e9n podemos disparar nosotros manualmente la inserci\u00f3n o eliminaci\u00f3n. Por ejemplo veamos c\u00f3mo se insertar\u00eda una nueva celda \u201cmanualmente\u201d al principio de la tabla. 1 2 3 4 5 6 7 //primero hay que actualizar los datos self . datos . insert ( \"Nueva celda\" , at : 0 ) //y ahora visualmente insertar la celda let indexPath = IndexPath ( row : 0 , section : 0 ) //suponemos que tenemos accesible la tabla, la necesitamos tabla . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . fade )","title":"Insertar y eliminar filas"},{"location":"4_tablas/ejercicios/","text":"Ejercicios de tablas (2 puntos) \u00b6 Vamos a crear una peque\u00f1a aplicaci\u00f3n en la que se muestre una tabla con una lista de dato y se puedan insertar y eliminar filas Crear la interfaz (0,25 puntos) \u00b6 Crea otra pantalla, al estilo de la que aparece en la figura. Tiene que tener los siguientes componentes: - Un text field - Un button con el texto \"Insertar\" - Un table view Aunque habr\u00eda que usar autolayout , para simplificar el ejercicio puedes ignorar este aspecto. Mostrar datos en la tabla (0,75 puntos) \u00b6 Crea una clase Swift llamada DSTabla que va a hacer de datasource de la tabla seleccion\u00e1ndola. Haz que el DSTabla implemente el protocolo UITableViewDataSource Conecta el DSTabla con la propiedad dataSource de la tabla El DSTabla va a almacenar los datos en una propiedad lista de tipo array de String (puedes usar los nombres que aparecen en el ejemplo u otros datos cualesquiera, es indiferente) 1 2 //en la clase DSTabla, definimos e inicializamos la propiedad var lista = [ \"Daenerys Targaryen\" , \"Jon Nieve\" , \"Cersei Lannister\" , \"Eddard Stark\" ] Ahora tendr\u00e1s que implementar t\u00fa de manera adecuada los m\u00e9todos: tableView(_:, numberOfRowsInSection:) recuerda que debe devolver el n\u00famero de filas de la tabla tableView(_:, cellForRowAt:) : recuerda que debe devolver la celda para una fila determinada Insertar filas (0,5 puntos) \u00b6 Implementa en el datasource un m\u00e9todo insertarCelda(enTabla:,enFila:,conTexto:) que al pasarle el UITableView , un n\u00famero de fila y un texto a\u00f1ada el texto a la lista de datos y luego a\u00f1ada visualmente la fila en la tabla. En la interfaz haz que cuando se escriba un texto en el campo de texto y se pulse el bot\u00f3n Insertar se llame al m\u00e9todo insertarCelda (enTabla:,enFila:,conTexto:) que has definido. Delegate (0,5 puntos) \u00b6 Vamos a hacer que se puedan \"marcar\" filas de la tabla. Para ello necesitas alg\u00fan objeto que act\u00fae de delegate . Crea para ello una clase DelegateTabla Haz que esta clase herede de NSObject e implemente el protocolo UITableViewDelegate Implementa en esta clase un m\u00e9todo similar al que en las transparencias marca o desmarca una fila poni\u00e9ndole un \"checkmark\", pero aqu\u00ed cambiando el texto a color rojo (propiedad textColor a UIColor.red ) y si est\u00e1 en rojo pasando a negro. Ahora vamos a conectar el delegate con la tabla gr\u00e1ficamente, en vez de por c\u00f3digo. Para ello: Arrastrar un componente Object al \u00e1rbol de componentes de la pantalla del m\u00f3vil (al \u00e1rbol que aparece a la izquierda, no a la pantalla en s\u00ed). Seleccionar el componente, y en el Identity inspector (tercer icono del panel derecho de Xcode), escribir el nombre de la clase DelegateTabla en Custom Class . Conectar tabla y delegate: seleccionamos la tabla con el rat\u00f3n y vamos al Connections inspector (el icono panel derecho de Xcode). Arrastramos con el rat\u00f3n (no hace falta Ctrl ) desde el c\u00edrculo que representa al delegate hasta el icono del objeto que representa a la clase TablaDelegate Una vez hecho esto, comprueba que funciona correctamente.","title":"Ejercicios"},{"location":"4_tablas/ejercicios/#ejercicios-de-tablas-2-puntos","text":"Vamos a crear una peque\u00f1a aplicaci\u00f3n en la que se muestre una tabla con una lista de dato y se puedan insertar y eliminar filas","title":"Ejercicios de tablas (2 puntos)"},{"location":"4_tablas/ejercicios/#crear-la-interfaz-025-puntos","text":"Crea otra pantalla, al estilo de la que aparece en la figura. Tiene que tener los siguientes componentes: - Un text field - Un button con el texto \"Insertar\" - Un table view Aunque habr\u00eda que usar autolayout , para simplificar el ejercicio puedes ignorar este aspecto.","title":"Crear la interfaz (0,25 puntos)"},{"location":"4_tablas/ejercicios/#mostrar-datos-en-la-tabla-075-puntos","text":"Crea una clase Swift llamada DSTabla que va a hacer de datasource de la tabla seleccion\u00e1ndola. Haz que el DSTabla implemente el protocolo UITableViewDataSource Conecta el DSTabla con la propiedad dataSource de la tabla El DSTabla va a almacenar los datos en una propiedad lista de tipo array de String (puedes usar los nombres que aparecen en el ejemplo u otros datos cualesquiera, es indiferente) 1 2 //en la clase DSTabla, definimos e inicializamos la propiedad var lista = [ \"Daenerys Targaryen\" , \"Jon Nieve\" , \"Cersei Lannister\" , \"Eddard Stark\" ] Ahora tendr\u00e1s que implementar t\u00fa de manera adecuada los m\u00e9todos: tableView(_:, numberOfRowsInSection:) recuerda que debe devolver el n\u00famero de filas de la tabla tableView(_:, cellForRowAt:) : recuerda que debe devolver la celda para una fila determinada","title":"Mostrar datos en la tabla (0,75 puntos)"},{"location":"4_tablas/ejercicios/#insertar-filas-05-puntos","text":"Implementa en el datasource un m\u00e9todo insertarCelda(enTabla:,enFila:,conTexto:) que al pasarle el UITableView , un n\u00famero de fila y un texto a\u00f1ada el texto a la lista de datos y luego a\u00f1ada visualmente la fila en la tabla. En la interfaz haz que cuando se escriba un texto en el campo de texto y se pulse el bot\u00f3n Insertar se llame al m\u00e9todo insertarCelda (enTabla:,enFila:,conTexto:) que has definido.","title":"Insertar filas (0,5 puntos)"},{"location":"4_tablas/ejercicios/#delegate-05-puntos","text":"Vamos a hacer que se puedan \"marcar\" filas de la tabla. Para ello necesitas alg\u00fan objeto que act\u00fae de delegate . Crea para ello una clase DelegateTabla Haz que esta clase herede de NSObject e implemente el protocolo UITableViewDelegate Implementa en esta clase un m\u00e9todo similar al que en las transparencias marca o desmarca una fila poni\u00e9ndole un \"checkmark\", pero aqu\u00ed cambiando el texto a color rojo (propiedad textColor a UIColor.red ) y si est\u00e1 en rojo pasando a negro. Ahora vamos a conectar el delegate con la tabla gr\u00e1ficamente, en vez de por c\u00f3digo. Para ello: Arrastrar un componente Object al \u00e1rbol de componentes de la pantalla del m\u00f3vil (al \u00e1rbol que aparece a la izquierda, no a la pantalla en s\u00ed). Seleccionar el componente, y en el Identity inspector (tercer icono del panel derecho de Xcode), escribir el nombre de la clase DelegateTabla en Custom Class . Conectar tabla y delegate: seleccionamos la tabla con el rat\u00f3n y vamos al Connections inspector (el icono panel derecho de Xcode). Arrastramos con el rat\u00f3n (no hace falta Ctrl ) desde el c\u00edrculo que representa al delegate hasta el icono del objeto que representa a la clase TablaDelegate Una vez hecho esto, comprueba que funciona correctamente.","title":"Delegate (0,5 puntos)"},{"location":"5_contenedores/apuntes/","text":"Controladores contenedores \u00b6 A diferencia de los otros tipos de controllers que hemos visto, los controladores contenedores no muestran directamente el contenido \u201cprincipal\u201d de la aplicaci\u00f3n. El papel de estos controladores es, como su propio nombre indica, el de servir de contenedores a los controladores que muestran el contenido y permitir la nanegaci\u00f3n sencilla entre ellos. En esta parte b\u00e1sica de la asignatura vamos a ver los dos controladores contenedores m\u00e1s t\u00edpicos: el tab bar y el navigation . Tab bar controllers \u00b6 Permiten dise\u00f1ar la t\u00edpica aplicaci\u00f3n dividida por \u201capartados\u201d o \u201ctabs\u201d. Por ejemplo lo podemos ver en la aplicaci\u00f3n de \u201csalud\u201d de iOS (entre much\u00edsimas otras) Lo que tenemos es un controlador de tipo \u201ctab bar\u201d que gestiona la barra inferior y la navegaci\u00f3n entre pantallas cuando pulsamos cada uno de sus iconos, pero el contenido de las pantallas lo gestionan los otros controladores. Podemos ver la estructura de forma m\u00e1s clara si arrastramos un tab bar controller al storyboard desde la object library . Vemos que el nuevo tab bar controller aparece conectado a dos controladores convencionales (de la clase UIViewController ). Autom\u00e1ticamente cuando pulsemos en cada icono, se saltar\u00e1 al controller asociado. Podemos a\u00f1adir pantallas a este tab bar controller sin m\u00e1s que crearlas en el storyboard y luego conectarlas. Hacemos Ctrl+arrastrar desde el tab bar controller hasta la pantalla a conectar y en el men\u00fa contextual elegimos el tipo de segue llamado view controllers (en el apartado relationship segue ). Otra forma de crear un tab bar controller relacionado con una pantalla que ya tengamos creada es seleccionar la misma y en el men\u00fa de Editor elegir Embed in > Tab bar controller . Aparecer\u00e1 un tab bar controller con un \u00fanico icono en la barra inferior, y ya conectado a la pantalla actual. Personalizar la barra inferior \u00b6 Desde el interface builder podemos cambiar algunas propiedades b\u00e1sicas de los iconos de la barra inferior en el attribute inspector , como el icono, el t\u00edtulo, la posici\u00f3n del t\u00edtulo con respecto al icono, si queremos que aparezca un badge , etc. El interfaz nos permite especificar las propiedades del UITabBarItem y UIBarItem como si fueran objetos separados. En realidad es el mismo pero las propiedades aparecen separadas ya que la segunda clase es la superclase de la primera En el apartado Tab bar item , si elegimos uno de los iconos del sistema no podremos cambiar el t\u00edtulo ya que Apple considera que lo contrario podr\u00eda inducir a confusi\u00f3n al usuario Si queremos personalizar el icono poniendo nuestra propia imagen hay que tener en cuenta que los iconos de un tab bar son monocrom\u00e1ticos. El formato a usar es .png, del que el sistema examinar\u00e1 el canal alfa o de transparencia. Tomar\u00e1 como forma del icono los pixels que sean opacos ignorando su color. El tama\u00f1o recomendado para los iconos var\u00eda seg\u00fan la interfaz se muestre en modo compact (que en un iPhone corresponder\u00eda a portrait /vertical) o regular (en un iPhone ser\u00eda landscape /horizontal, y en un iPad ser\u00eda cualquier modo, ya que un iPad en vertical es mucho m\u00e1s ancho que un iPhone). Pod\u00e9is consultar m\u00e1s detalles sobre el formato y el tama\u00f1o recomendado en el apartado \" Tab bar icon size \" de las iOS Human Interface Guidelines de Apple. Navigation controllers \u00b6 Los navigation controller sirven para crear estructuras de navegaci\u00f3n jer\u00e1rquica en las que tenemos pantallas y \u201csubpantallas\u201d. Estando en una de ellas podemos volver atr\u00e1s una a una. El navigation controller se encargar\u00e1 de que se vaya cambiando autom\u00e1ticamente al controlador apropiado (el de la pantalla actual). N\u00f3tese que cuando estamos navegando de este modo estamos usando una pila de controladores , en el sentido que tiene este t\u00e9rmino en estructuras de datos, ya que conforme vamos profundizando en la jerarqu\u00eda se van apilando los controladores, y cuando volvemos atr\u00e1s quitamos el de la parte de arriba de la pila. Crear un controlador de navegaci\u00f3n \u00b6 Hay dos formas de crear gr\u00e1ficamente un controlador de navegaci\u00f3n: 1) Seleccionamos un controller en el storyboard y elegimos la opci\u00f3n de men\u00fa de Editor > Embed in > Navigation controller . Se crear\u00e1 un controlador de navegaci\u00f3n que tiene como controlador de contenido asociado al que hab\u00edamos seleccionado. N\u00f3tese que como en el caso de los tab bar controller en el de navegaci\u00f3n la pantalla est\u00e1 en gris indicando que el contenido no es responsabilidad de este controlador. En el controlador de contenido asociado podemos ver que la parte superior aparece en gris, indicando que esta es la barra de navegaci\u00f3n que gestionar\u00e1 el controlador de navegaci\u00f3n. 2) Podemos arrastrar un Navigation controller desde la librer\u00eda de objectos hasta el storyboard . Por defecto nos crear\u00e1 el controlador de navegaci\u00f3n junto con un controlador de tabla, estructura apropiada para comenzar con una vista maestro/detalle. No obstante si no queremos este segundo controlador podemos borrarlo y conectar el de navegaci\u00f3n con uno nuevo con Ctrl+Arrastrar entre ambos y seleccionando en el men\u00fa contextual la opci\u00f3n de root view controller bajo relationship segue . A\u00f1adir pantallas a la jerarqu\u00eda \u00b6 Antes de ver el mecanismo concreto para a\u00f1adir niveles a la jerarqu\u00eda de navegaci\u00f3n hay que tener presente que el tipo de segue var\u00eda seg\u00fan se tenga o no activada la funcionalidad de size classes . La idea es que en el modo \u201ccl\u00e1sico\u201d (sin size classes ) la relaci\u00f3n por defecto entre dos pantallas dentro de un navigation controller es de tipo push , que gr\u00e1ficamente se ve como si el nuevo nivel se deslizara desde la derecha de la pantalla. En cambio si estamos dise\u00f1ando una interfaz gen\u00e9rica es el sistema el que debe adaptar la animaci\u00f3n a las caracter\u00edsticas del dispositivo actual, y quiz\u00e1 la de tipo push no es la m\u00e1s apropiada. Por ello cuando se usan size classes el nombre de los segues ha cambiado al t\u00e9rmino m\u00e1s gen\u00e9rico show . Para a\u00f1adir un controlador a la jerarqu\u00eda de navegaci\u00f3n basta con Ctrl+Arrastrar entre el componente que disparar\u00eda el salto y el controlador de destino. En el men\u00fa contextual hay que elegir el segue adecuado (sea push o show) . Evidentemente el controlador de origen tiene que estar ya en la jerarqu\u00eda de navegaci\u00f3n para que esta operaci\u00f3n funcione. Personalizar la barra de navegaci\u00f3n \u00b6 Autom\u00e1ticamente el controlador de navegaci\u00f3n gestionar\u00e1 una barra de navegaci\u00f3n en la parte superior de la pantalla. Esta barra muestra por defecto en su parte izquierda un bot\u00f3n < Back para ir al controlador anterior. La barra de navegaci\u00f3n es totalmente personalizable. Lo m\u00e1s inmediato es mostrar un t\u00edtulo para la pantalla actual cambiando la propiedad title del controlador. Esta propiedad en general es una simple descripci\u00f3n de la pantalla, pero en el caso de controladores de contenido que est\u00e9n incluidos en un contenedor, representa el t\u00edtulo de la barra de navegaci\u00f3n. El cambio de title podemos hacerlo bien en el interface builder de Xcode o bien por c\u00f3digo, por ejemplo en el m\u00e9todo viewWillAppear del controller , ya que se ejecutar\u00e1 antes de mostrar la vista. Al cambiar el t\u00edtulo del controlador tambi\u00e9n cambiar\u00e1 autom\u00e1ticamente el bot\u00f3n ``< Back``` del siguiente \u201cnivel\u201d para reflejar el nuevo t\u00edtulo. Si el t\u00edtulo del controller es demasiado largo y no cabe en el bot\u00f3n este seguir\u00e1 con el t\u00edtulo por defecto ( Back ) Podemos cambiar completamente la barra de navegaci\u00f3n. Es accesible mediante la propiedad navigationItem del controlador, y podemos cambiar por ejemplo: backBarButtonItem : el bot\u00f3n, de tipo UIBarButtonItem , que se utilizar\u00e1 para volver atr\u00e1s a este controlador titleView : el componente con el t\u00edtulo para el controlador, cuyo texto como hemos visto podemos cambiar con la propiedad title del controlador. rightBarButtonItem : por defecto nil . T\u00edpicamente se usa para a\u00f1adir un bot\u00f3n para editar el contenido de la pantalla actual, pero podemos colocar lo que queramos.","title":"Controladores contenedores"},{"location":"5_contenedores/apuntes/#controladores-contenedores","text":"A diferencia de los otros tipos de controllers que hemos visto, los controladores contenedores no muestran directamente el contenido \u201cprincipal\u201d de la aplicaci\u00f3n. El papel de estos controladores es, como su propio nombre indica, el de servir de contenedores a los controladores que muestran el contenido y permitir la nanegaci\u00f3n sencilla entre ellos. En esta parte b\u00e1sica de la asignatura vamos a ver los dos controladores contenedores m\u00e1s t\u00edpicos: el tab bar y el navigation .","title":"Controladores contenedores"},{"location":"5_contenedores/apuntes/#tab-bar-controllers","text":"Permiten dise\u00f1ar la t\u00edpica aplicaci\u00f3n dividida por \u201capartados\u201d o \u201ctabs\u201d. Por ejemplo lo podemos ver en la aplicaci\u00f3n de \u201csalud\u201d de iOS (entre much\u00edsimas otras) Lo que tenemos es un controlador de tipo \u201ctab bar\u201d que gestiona la barra inferior y la navegaci\u00f3n entre pantallas cuando pulsamos cada uno de sus iconos, pero el contenido de las pantallas lo gestionan los otros controladores. Podemos ver la estructura de forma m\u00e1s clara si arrastramos un tab bar controller al storyboard desde la object library . Vemos que el nuevo tab bar controller aparece conectado a dos controladores convencionales (de la clase UIViewController ). Autom\u00e1ticamente cuando pulsemos en cada icono, se saltar\u00e1 al controller asociado. Podemos a\u00f1adir pantallas a este tab bar controller sin m\u00e1s que crearlas en el storyboard y luego conectarlas. Hacemos Ctrl+arrastrar desde el tab bar controller hasta la pantalla a conectar y en el men\u00fa contextual elegimos el tipo de segue llamado view controllers (en el apartado relationship segue ). Otra forma de crear un tab bar controller relacionado con una pantalla que ya tengamos creada es seleccionar la misma y en el men\u00fa de Editor elegir Embed in > Tab bar controller . Aparecer\u00e1 un tab bar controller con un \u00fanico icono en la barra inferior, y ya conectado a la pantalla actual.","title":"Tab bar controllers"},{"location":"5_contenedores/apuntes/#personalizar-la-barra-inferior","text":"Desde el interface builder podemos cambiar algunas propiedades b\u00e1sicas de los iconos de la barra inferior en el attribute inspector , como el icono, el t\u00edtulo, la posici\u00f3n del t\u00edtulo con respecto al icono, si queremos que aparezca un badge , etc. El interfaz nos permite especificar las propiedades del UITabBarItem y UIBarItem como si fueran objetos separados. En realidad es el mismo pero las propiedades aparecen separadas ya que la segunda clase es la superclase de la primera En el apartado Tab bar item , si elegimos uno de los iconos del sistema no podremos cambiar el t\u00edtulo ya que Apple considera que lo contrario podr\u00eda inducir a confusi\u00f3n al usuario Si queremos personalizar el icono poniendo nuestra propia imagen hay que tener en cuenta que los iconos de un tab bar son monocrom\u00e1ticos. El formato a usar es .png, del que el sistema examinar\u00e1 el canal alfa o de transparencia. Tomar\u00e1 como forma del icono los pixels que sean opacos ignorando su color. El tama\u00f1o recomendado para los iconos var\u00eda seg\u00fan la interfaz se muestre en modo compact (que en un iPhone corresponder\u00eda a portrait /vertical) o regular (en un iPhone ser\u00eda landscape /horizontal, y en un iPad ser\u00eda cualquier modo, ya que un iPad en vertical es mucho m\u00e1s ancho que un iPhone). Pod\u00e9is consultar m\u00e1s detalles sobre el formato y el tama\u00f1o recomendado en el apartado \" Tab bar icon size \" de las iOS Human Interface Guidelines de Apple.","title":"Personalizar la barra inferior"},{"location":"5_contenedores/apuntes/#navigation-controllers","text":"Los navigation controller sirven para crear estructuras de navegaci\u00f3n jer\u00e1rquica en las que tenemos pantallas y \u201csubpantallas\u201d. Estando en una de ellas podemos volver atr\u00e1s una a una. El navigation controller se encargar\u00e1 de que se vaya cambiando autom\u00e1ticamente al controlador apropiado (el de la pantalla actual). N\u00f3tese que cuando estamos navegando de este modo estamos usando una pila de controladores , en el sentido que tiene este t\u00e9rmino en estructuras de datos, ya que conforme vamos profundizando en la jerarqu\u00eda se van apilando los controladores, y cuando volvemos atr\u00e1s quitamos el de la parte de arriba de la pila.","title":"Navigation controllers"},{"location":"5_contenedores/apuntes/#crear-un-controlador-de-navegacion","text":"Hay dos formas de crear gr\u00e1ficamente un controlador de navegaci\u00f3n: 1) Seleccionamos un controller en el storyboard y elegimos la opci\u00f3n de men\u00fa de Editor > Embed in > Navigation controller . Se crear\u00e1 un controlador de navegaci\u00f3n que tiene como controlador de contenido asociado al que hab\u00edamos seleccionado. N\u00f3tese que como en el caso de los tab bar controller en el de navegaci\u00f3n la pantalla est\u00e1 en gris indicando que el contenido no es responsabilidad de este controlador. En el controlador de contenido asociado podemos ver que la parte superior aparece en gris, indicando que esta es la barra de navegaci\u00f3n que gestionar\u00e1 el controlador de navegaci\u00f3n. 2) Podemos arrastrar un Navigation controller desde la librer\u00eda de objectos hasta el storyboard . Por defecto nos crear\u00e1 el controlador de navegaci\u00f3n junto con un controlador de tabla, estructura apropiada para comenzar con una vista maestro/detalle. No obstante si no queremos este segundo controlador podemos borrarlo y conectar el de navegaci\u00f3n con uno nuevo con Ctrl+Arrastrar entre ambos y seleccionando en el men\u00fa contextual la opci\u00f3n de root view controller bajo relationship segue .","title":"Crear un controlador de navegaci\u00f3n"},{"location":"5_contenedores/apuntes/#anadir-pantallas-a-la-jerarquia","text":"Antes de ver el mecanismo concreto para a\u00f1adir niveles a la jerarqu\u00eda de navegaci\u00f3n hay que tener presente que el tipo de segue var\u00eda seg\u00fan se tenga o no activada la funcionalidad de size classes . La idea es que en el modo \u201ccl\u00e1sico\u201d (sin size classes ) la relaci\u00f3n por defecto entre dos pantallas dentro de un navigation controller es de tipo push , que gr\u00e1ficamente se ve como si el nuevo nivel se deslizara desde la derecha de la pantalla. En cambio si estamos dise\u00f1ando una interfaz gen\u00e9rica es el sistema el que debe adaptar la animaci\u00f3n a las caracter\u00edsticas del dispositivo actual, y quiz\u00e1 la de tipo push no es la m\u00e1s apropiada. Por ello cuando se usan size classes el nombre de los segues ha cambiado al t\u00e9rmino m\u00e1s gen\u00e9rico show . Para a\u00f1adir un controlador a la jerarqu\u00eda de navegaci\u00f3n basta con Ctrl+Arrastrar entre el componente que disparar\u00eda el salto y el controlador de destino. En el men\u00fa contextual hay que elegir el segue adecuado (sea push o show) . Evidentemente el controlador de origen tiene que estar ya en la jerarqu\u00eda de navegaci\u00f3n para que esta operaci\u00f3n funcione.","title":"A\u00f1adir pantallas a la jerarqu\u00eda"},{"location":"5_contenedores/apuntes/#personalizar-la-barra-de-navegacion","text":"Autom\u00e1ticamente el controlador de navegaci\u00f3n gestionar\u00e1 una barra de navegaci\u00f3n en la parte superior de la pantalla. Esta barra muestra por defecto en su parte izquierda un bot\u00f3n < Back para ir al controlador anterior. La barra de navegaci\u00f3n es totalmente personalizable. Lo m\u00e1s inmediato es mostrar un t\u00edtulo para la pantalla actual cambiando la propiedad title del controlador. Esta propiedad en general es una simple descripci\u00f3n de la pantalla, pero en el caso de controladores de contenido que est\u00e9n incluidos en un contenedor, representa el t\u00edtulo de la barra de navegaci\u00f3n. El cambio de title podemos hacerlo bien en el interface builder de Xcode o bien por c\u00f3digo, por ejemplo en el m\u00e9todo viewWillAppear del controller , ya que se ejecutar\u00e1 antes de mostrar la vista. Al cambiar el t\u00edtulo del controlador tambi\u00e9n cambiar\u00e1 autom\u00e1ticamente el bot\u00f3n ``< Back``` del siguiente \u201cnivel\u201d para reflejar el nuevo t\u00edtulo. Si el t\u00edtulo del controller es demasiado largo y no cabe en el bot\u00f3n este seguir\u00e1 con el t\u00edtulo por defecto ( Back ) Podemos cambiar completamente la barra de navegaci\u00f3n. Es accesible mediante la propiedad navigationItem del controlador, y podemos cambiar por ejemplo: backBarButtonItem : el bot\u00f3n, de tipo UIBarButtonItem , que se utilizar\u00e1 para volver atr\u00e1s a este controlador titleView : el componente con el t\u00edtulo para el controlador, cuyo texto como hemos visto podemos cambiar con la propiedad title del controlador. rightBarButtonItem : por defecto nil . T\u00edpicamente se usa para a\u00f1adir un bot\u00f3n para editar el contenido de la pantalla actual, pero podemos colocar lo que queramos.","title":"Personalizar la barra de navegaci\u00f3n"},{"location":"proyecto/proyecto/","text":"Proyecto de la asignatura de interfaces de usuario, parte de iOS b\u00e1sico \u00b6 Este \"miniproyecto\" trata de hacer una peque\u00f1a aplicaci\u00f3n bas\u00e1ndose en el API de la editorial Marvel, que nos permite consultar informaci\u00f3n sobre los personajes, los comics , las series ,... Pasos iniciales \u00b6 Registro en la API de Marvel \u00b6 Lo primero que necesitas es registrarte en Marvel para poder obtener un par de claves. Este paso es necesario porque la API tiene un n\u00famero m\u00e1ximo de llamadas diario, lo que significa que no podemos compartir todos las mismas claves. Acceso a la API \u00b6 La API de Marvel es REST, por lo que acepta peticiones HTTP. No obstante hacerlas directamente con los APIs de iOS ser\u00eda un poco engorroso, por lo que vamos a usar un par de librer\u00edas que nos faciliten no solo hacer la petici\u00f3n en s\u00ed sino sobre todo parsear el JSON. Usaremos una librer\u00eda adicional llamada Marvelous, que encapsula las llamadas al API en una serie de clases de modo que no tenemos que hacer peticiones HTTP directamente. IMPORTANTE : para acelerar el trabajo en el aula ten\u00e9is disponible en moodle la plantilla de workspace ya creada. Estructura general de la interfaz \u00b6 En la plantilla de workspace descargada abre el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Primero hay que hacer un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Una vez hecho esto podemos ejecutar la app, en la consola aparecer\u00e1 una lista de personajes cuyo nombre empieza por \"Spider\". Puedes mirar el c\u00f3digo del View Controller para ver c\u00f3mo se ha hecho. Para que te hagas una idea de la estructura, se muestra el storyboard de la aplicaci\u00f3n ya terminada En la aplicaci\u00f3n se podr\u00e1 buscar, listar y mostrar los detalles de alguno de los recursos que ofrece el API. Elige t\u00fa lo que prefieras: personajes, comics, creadores... Pantalla inicial \u00b6 Puedes comenzar creando un tab bar a partir de la pantalla inicial: selecci\u00f3nala y en el men\u00fa Editor elige Embed In > Tab Bar Controller . Vista maestro (2 puntos) \u00b6 Esta debe ser una pantalla con una barra de b\u00fasqueda y una vista de tabla en la que se puede buscar y listar el recurso elegido (por ejemplo personajes). El resultado final ser\u00e1 algo como: Ve a la primera (y por el momento \u00fanica) pantalla de contenido del tab bar , selecciona la barra inferior y en las propiedades bar item ponle un t\u00edtulo apropiado (por ejemplo \"Personajes\") y un icono relevante. Recuerda que tienes unas cuantas webs de donde puedes coger iconos \"planos\", por ejemplo https://www.iconfinder.com/iconsets/ios-7-icons o http://www.flaticon.com/packs/line-icon-set Crear los componentes de la interfaz \u00b6 La tabla: Arrastra una table view a la pantalla de \"personajes\" (o \"comics\", o lo que hayas elegido) Selecciona la tabla y en las propiedades crea un prototipo de celda incrementando el Prototype cells a 1. Selecciona el prototipo de celda reci\u00e9n creado (el table view cell ) y en las propiedades elige como style el valor Basic , para poder usar uno de los tipos predefinidos de celda y no tener que hacerlo t\u00fa. La barra de b\u00fasqueda: Arrastra un componente de tipo search bar a la pantalla y d\u00e9jalo justo arriba de la tabla. Nos falta fijar el autolayout : Selecciona barra y tabla manteniendo pulsada la tecla Cmd e inserta ambas en un stack view utilizando el primero de los botones de autolayout (parte inferior derecha del *storyboard) Haz que este stack view ocupe toda la pantalla. Lo m\u00e1s sencillo es ponerle 4 restricciones de distancia 0 a los bordes. Una vez hecho esto puedes poner en marcha la app para ver si la interfaz tiene buen aspecto. La tabla aparecer\u00e1 vac\u00eda, por supuesto. Gestionar la barra de b\u00fasqueda \u00b6 La barra de b\u00fasqueda utiliza el patr\u00f3n delegaci\u00f3n para gestionar los eventos de escribir en ella, pulsar \"buscar\" en el teclado, etc. El objeto que act\u00fae como delegate de la barra de b\u00fasqueda debe implementar el protocolo UISearchBarDelegate . Puede ser cualquiera, aunque siguiendo la filosof\u00eda MVC (Monster View Controller) haremos que sea el view controller de la pantalla actual :). Vamos a crear este view controller : Crea una nueva clase de Cocoa Touch llamada ListaController y haz que sea una subclase de UIViewController As\u00edgnale ese controller a la pantalla de lista que has creado antes. Recuerda que esto se hace a trav\u00e9s del identity inspector . Ahora vamos a conectar el view controller con la barra de b\u00fasqueda: Selecciona la search bar (te ser\u00e1 m\u00e1s f\u00e1cil si lo haces en el \u00e1rbol de componentes) y en el connections inspector (panel de la derecha de Xcode, icono de m\u00e1s a la derecha) conecta el outlet delegate con el controller de esta pantalla. Recuerda que el controller est\u00e1 representado gr\u00e1ficamente con un icono de color amarillo que aparece en la parte superior de cada pantalla de la app en el storyboard . Pon en la cabecera ListaController que esta clase implementa el protocolo UISearchBarDelegate En el ListaController implementa el m\u00e9todo searchBarSearchButtonClicked(_) , que se llamar\u00e1 cuando se escriba algo en la barra y se pulse el bot\u00f3n del teclado \"buscar\". Para probar que funciona de momento basta que imprimas en la consola el texto escrito en la barra y quites el teclado on screen . 1 2 3 4 func searchBarSearchButtonClicked ( _ searchBar : UISearchBar ) { print ( \"Buscado: \\( searchBar . text ! ) \" ) searchBar . resignFirstResponder () } Ejecuta la app y comprueba que efectivamente funciona. Ahora tendr\u00e1s que poner c\u00f3digo propio para que cuando se pulse en el bot\u00f3n de buscar se haga la llamada a la API de Marvel. Por el momento lo m\u00e1s simple es mostrar los resultados con print . Puedes asign\u00e1rselos tambi\u00e9n a un array que sea una propiedad del controller , para que luego sean sencillos de mostrar en la tabla. Mostrar los resultados en la tabla \u00b6 Una vez conseguido esto, tendr\u00e1s que hacer que los resultados aparezcan en la tabla. Recuerda que necesitas un datasource para ella, y que para simplificar puedes hacer que sea el ListaController . A grandes rasgos esto implica: Que, como dec\u00edamos antes, el controller debe tener acceso a los datos, por ejemplo guard\u00e1ndolos en una propiedad que sea un array. Que tienes que conectar en el connections inspector el outlet datasource con el controller . Que el ListaController debe implementar el protocolo UITableViewDataSource . Hay que poner en la cabecera que esto es as\u00ed, y adem\u00e1s implementar los correspondientes m\u00e9todos en el c\u00f3digo del controller , uno para devolver el n\u00famero de filas en la tabla y otro para devolver una celda dado su indexPath . Cada vez que se haga una b\u00fasqueda y se a\u00f1adan datos al array tendr\u00e1s que decirle a iOS que vuelva a redibujar la tabla llamando a su m\u00e9todo reloadData . Cuidado, porque al ser una actualizaci\u00f3n de la interfaz debes asegurarte de que esto lo est\u00e1s haciendo desde el thread principal, algo como: 1 2 3 4 5 //sustituye self.vistaTabla por el outlet que hayas definido //para acceder a la tabla desde el controlador OperationQueue . main . addOperation () { self . vistaTabla . reloadData (); } Obtener la cola principal de operaciones expl\u00edcitamente es necesario si, como es lo m\u00e1s l\u00f3gico, colocas el c\u00f3digo anterior en el bloque que obtiene la respuesta del API de Marvel. Recuerda que para evitar bloqueos, Marvelous funciona de modo as\u00edncrono en un thread distinto al principal Una vez terminado todo esto, esta pantalla deber\u00eda ser casi totalmente funcional. Solo quedar\u00eda ver los detalles de cada item al hacer tap sobre \u00e9l. Opcionalmente (0,25 puntos extra) , puedes hacer que aparezca un spinner mientras se est\u00e1 procesando la petici\u00f3n, para que el usuario sepa que el sistema est\u00e1 esperando datos. Los spinners en iOS se denominan Activity Indicators . Puedes consultar la referencia de la clase UIActivityIndicator para ver la forma de uso, aunque es muy sencillo, b\u00e1sicamente debes hacer startAnimating para que empiece a girar y stopAnimating para pararlo. Es posible que el activity indicator se te quede detr\u00e1s de los otros elementos de interfaz y no se vea. Puedes usar el m\u00e9todo bringSubviewToFront que se llama desde la vista \"madre\" para pasar a una vista \"hija\" a \"primer plano\". Si estamos en el controller ser\u00eda algo como self.view bringSubview(toFront:self.miActivityIndicator) , ya que recuerda que self.view en un controller es la vista principal. Tendr\u00e1s que sustituir la referencia self.miActivityIndicator por la apropiada en tu caso. Adem\u00e1s de esto lleva cuidado tambi\u00e9n con el color, otro problema t\u00edpico es usar uno del mismo color que el fondo. Vista de detalle (1,5 puntos) \u00b6 La nueva pantalla mostrar\u00e1 los datos de un item al hacer tap . Como una vez en los detalles queremos poder volver atr\u00e1s al listado de forma sencilla, lo mejor es usar un navigation controller : El navigation controller \u00b6 En este apartado todav\u00eda no estamos implementando la vista de detalle, solo creando la jerarqu\u00eda de navegaci\u00f3n. Selecciona la pantalla de lista y elige la opci\u00f3n de men\u00fa Editor > Embed In > Navigation Controller . Aparecer\u00e1 un nuevo navigation controller que tiene como primer nivel de navegaci\u00f3n a la pantalla de lista de items. Fijate que en la parte superior de la pantalla de items habr\u00e1 aparecido un espacio reservado para el t\u00edtulo y los botones de navegaci\u00f3n. Esto puede haber \"trastocado\" en modo dise\u00f1o el resto de los elementos de la interfaz (aunque cuando se ejecute la app deber\u00edan seguir funcionando bien). Recuerda que puedes volverlos \"a su sitio\" en modo dise\u00f1o con el Update Frames del autolayout . Selecciona la nueva barra de t\u00edtulo de la vista de lista y en las propiedades pon como title el recurso que est\u00e1s mostrando (personajes, autores, comics,...). La pantalla de detalles del item \u00b6 Esta ser\u00eda la que muestra todos los datos de un personaje, comic, creador,... junto a su imagen si es que la tiene. Si quieres usar una tabla est\u00e1tica para dise\u00f1ar esta pantalla debes usar como controller una clase que herede de UITableViewController Creaci\u00f3n de la interfaz y conexi\u00f3n con la pantalla anterior \u00b6 Arrastra un \"view controller\" al storyboard En la pantalla anterior, haz ctrl+arrastrar entre la celda prototipo y la pantalla actual. Elige el tipo adecuado de segue . Implementa una clase DetalleViewController que herede de UIViewController y as\u00f3ciala a esta pantalla. Implementaci\u00f3n de la funcionalidad \u00b6 Define en el DetalleViewController una propiedad del tipo de recurso que est\u00e9s mostrando ( RCCharacterObject , RCComicsObject , RCCreatorObject ,...) En el prepareForSegue de la pantalla de lista instancia esta propiedad para que contenga el objeto a mostrar. Para saber qu\u00e9 fila de la tabla se ha seleccionado puedes seleccionar la propiedad del objeto tabla llamada indexPathForSelectedRow , que almacena el indexPath de la fila seleccionada. La propiedad row de este index path es el n\u00famero de fila. Usa los componentes que consideres necesarios para mostrar los datos del objeto (no es necesario que sean todos, solo los que quieras, para probar que funciona). Tendr\u00e1s que crear un outlet por cada campo, y rellenar los campos en el viewDidLoad del controller . Puedes consultar la referencia de clases en la documentaci\u00f3n online de Marvelous para saber qu\u00e9 propiedades tiene cada objeto. La referencia est\u00e1 en Objective-C pero no es dif\u00edcil deducir qu\u00e9 es cada propiedad Entre otras cosas, en esta pantalla deber\u00edas mostrar la imagen del personaje, comic, creador o lo que sea que hayas elegido, a un tama\u00f1o relativamente peque\u00f1o. La carga de la imagen deber\u00edas hacerla en un hilo secundario, para no paralizar la interfaz de usuario si la imagen tarda en cargarse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let colaBackground = OperationQueue () colaBackground . addOperation { if let thumb = personajes [ 0 ]. thumbnail { let url = \" \\( thumb . basePath ! ) /portrait_uncanny. \\( thumb . extension ! ) \" let urlHttps = url . replacingOccurrences ( of : \"http\" , with : \"https\" ) if let urlFinal = URL ( string : urlHttps ) { do { let datos = try Data ( contentsOf : urlFinal ) if let img = UIImage ( data : datos ) { OperationQueue . main . addOperation { self . miImagen . image = img } } } catch { } } } } Puedes consultar esta p\u00e1gina para ver el formato de las URL de las im\u00e1genes. B\u00e1sicamente se construyen con una trayectoria base seguidas de un \"modificador\" de aspecto y tama\u00f1o ( portrait_small , landscape_medium , ...) y la extensi\u00f3n del archivo. En el c\u00f3digo anterior se obtiene la URL de la imagen y luego se cambia el http: por https: . En iOS>=9 una app no puede hacer una petici\u00f3n a una URL web si no es con https: . Esto deber\u00eda cambiarse en la propia librer\u00eda Marvelous , pero podemos salir del paso con este peque\u00f1o parche . Imagen a tama\u00f1o completo (1 punto) \u00b6 Implementa una nueva pantalla en la que se pueda ver solo la imagen a mayor tama\u00f1o. Haz que la transici\u00f3n se realice con un segue modal pulsando sobre alg\u00fan bot\u00f3n \"ver imagen ampliada\" (si tienes activadas las size classes el tipo equivalente es present modally ). En el API de Marvel, la URL de la imagen a tama\u00f1o completo se consigue simplemente concatenando las propiedades basePath y extension , y a\u00f1adiendo un punto entre ellas, de modo que ser\u00eda pr\u00e1cticamente igual al c\u00f3digo para cargar la imagen en la pantalla anterior pero sin poner el \"modificador\" (en el ejemplo era portrait-uncanny ). La pantalla debe tener alg\u00fan bot\u00f3n o similar para volver a la anterior. Vista \"Acerca de\" (0,25 puntos) \u00b6 Esta es la segunda de las pantallas del tab bar . Simplemente debe consistir en una imagen est\u00e1tica y un text view con informaci\u00f3n sobre la aplicaci\u00f3n. Ap\u00e9ndice: creaci\u00f3n de la plantilla de proyecto desde cero \u00b6 Esta secci\u00f3n est\u00e1 solo para que veas c\u00f3mo se ha creado la plantilla de proyecto, no es necesario que lo hagas si has usado la plantilla que est\u00e1 en moodle Por desgracia Xcode no integra ning\u00fan sistema de gesti\u00f3n de dependencias de librer\u00edas de terceros, as\u00ed que acudiremos a una herramienta que no es de Apple pero que se ha convertido en un est\u00e1ndar de facto en el mundo iOS: CocoaPods . Cocoapods es a la vez un repositorio de librer\u00edas y un gestor de dependencias para instalar autom\u00e1ticamente estas librer\u00edas en nuestros proyectos. Hay muchas librer\u00edas de terceros disponibles con este sistema, puedes buscarlas desde la p\u00e1gina de CocoaPods. Para instalar cocoapods , desde la terminal hacer 1 2 #Con --pre decimos que queremos instalar la \u00faltima versi\u00f3n, aunque sea RC sudo gem install cocoapods --pre Esto instala la herramienta desde un repositorio de Internet, as\u00ed que necesitar\u00e1s conectividad...y paciencia, seg\u00fan vaya la red. Si todo va bien se instalar\u00e1 un comando llamado pod . Ejec\u00fatalo desde la terminal para comprobar al menos que existe. Ahora debes seguir estos pasos: Crear un proyecto Xcode para la aplicaci\u00f3n. Ll\u00e1malo por ejemplo Marvel Con un editor de textos cualquiera, crear un fichero llamado Podfile en el directorio del proyecto (el que contiene el fichero .xcodeproj ). Este archivo debe contener la configuraci\u00f3n y las dependencias (o pods ) del proyecto 1 2 3 4 5 6 platform :ios, '11.0' use_frameworks! //SUSTITUYE 'Marvel' por el nombre de tu proyecto, si no se llama as\u00ed!!! target 'Marvel' do pod 'Marvelous' end Abre una terminal. Mu\u00e9vete hasta el directorio donde est\u00e1 el Podfile y desde \u00e9l ejecuta el comando pod install . Las dependencias de nuestro proyecto se bajar\u00e1n autom\u00e1ticamente y se crear\u00e1 en el directorio actual un Marvel.xcworkspace A partir de ahora para trabajar en el proyecto siempre abriremos el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Veremos que en Xcode se muestra nuestro proyecto y adem\u00e1s un proyecto adicional llamado Pods , que contiene las dependencias. Este \u00faltimo no lo tocaremos, pero es necesario que est\u00e9 ah\u00ed para que funcione el nuestro. Uso de Marvelous \u00b6 ANTES de empezar a escribir c\u00f3digo aseg\u00farate de hacer en Xcode un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Para poder hacer llamadas al API de Marvel necesitas un par de claves. Las puedes ver, una vez dado de alta y autentificado en Marvel, en https://developer.marvel.com/account El siguiente c\u00f3digo ya est\u00e1 metido en la plantilla, si te la has bajado. Solo es necesario poner en marcha el proyecto para probar si sale en la consola la lista de personajes. Para probar de manera sencilla la librer\u00eda Marvelous puedes poner este import en el ViewController 1 import Marvelous Y ahora copiar la siguiente funci\u00f3n en el view controller , quemuestran en la consola todos los personajes cuyo nombre comienza por una determinada cadena. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func mostrarPersonajes ( comienzanPor cadena : String ) { let marvelAPI = RCMarvelAPI () //PUEDES CAMBIAR ESTO PARA PONER TUS CLAVES marvelAPI . publicKey = \"a6927e7e15930110aade56ef90244f6d\" marvelAPI . privateKey = \"487b621fc3c0d6f128b468ba86c99c508f24d357\" let filtro = RCCharacterFilter () filtro . nameStartsWith = cadena marvelAPI . characters ( by : filtro ) { resultados , info , error in if let personajes = resultados as ! [ RCCharacterObject ]? { for personaje in personajes { print ( personaje . name ) } print ( \"Hay \\( personajes . count ) personajes\" ) } } } Puedes llamar a la funci\u00f3n anterior desde el viewDidLoad del view controller 1 2 3 4 5 override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view, typically from a nib. mostrarPersonajes ( comienzanPor : \"Spider\" ) }","title":"Miniproyecto"},{"location":"proyecto/proyecto/#proyecto-de-la-asignatura-de-interfaces-de-usuario-parte-de-ios-basico","text":"Este \"miniproyecto\" trata de hacer una peque\u00f1a aplicaci\u00f3n bas\u00e1ndose en el API de la editorial Marvel, que nos permite consultar informaci\u00f3n sobre los personajes, los comics , las series ,...","title":"Proyecto de la asignatura de interfaces de usuario, parte de iOS b\u00e1sico"},{"location":"proyecto/proyecto/#pasos-iniciales","text":"","title":"Pasos iniciales"},{"location":"proyecto/proyecto/#registro-en-la-api-de-marvel","text":"Lo primero que necesitas es registrarte en Marvel para poder obtener un par de claves. Este paso es necesario porque la API tiene un n\u00famero m\u00e1ximo de llamadas diario, lo que significa que no podemos compartir todos las mismas claves.","title":"Registro en la API de Marvel"},{"location":"proyecto/proyecto/#acceso-a-la-api","text":"La API de Marvel es REST, por lo que acepta peticiones HTTP. No obstante hacerlas directamente con los APIs de iOS ser\u00eda un poco engorroso, por lo que vamos a usar un par de librer\u00edas que nos faciliten no solo hacer la petici\u00f3n en s\u00ed sino sobre todo parsear el JSON. Usaremos una librer\u00eda adicional llamada Marvelous, que encapsula las llamadas al API en una serie de clases de modo que no tenemos que hacer peticiones HTTP directamente. IMPORTANTE : para acelerar el trabajo en el aula ten\u00e9is disponible en moodle la plantilla de workspace ya creada.","title":"Acceso a la API"},{"location":"proyecto/proyecto/#estructura-general-de-la-interfaz","text":"En la plantilla de workspace descargada abre el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Primero hay que hacer un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Una vez hecho esto podemos ejecutar la app, en la consola aparecer\u00e1 una lista de personajes cuyo nombre empieza por \"Spider\". Puedes mirar el c\u00f3digo del View Controller para ver c\u00f3mo se ha hecho. Para que te hagas una idea de la estructura, se muestra el storyboard de la aplicaci\u00f3n ya terminada En la aplicaci\u00f3n se podr\u00e1 buscar, listar y mostrar los detalles de alguno de los recursos que ofrece el API. Elige t\u00fa lo que prefieras: personajes, comics, creadores...","title":"Estructura general de la interfaz"},{"location":"proyecto/proyecto/#pantalla-inicial","text":"Puedes comenzar creando un tab bar a partir de la pantalla inicial: selecci\u00f3nala y en el men\u00fa Editor elige Embed In > Tab Bar Controller .","title":"Pantalla inicial"},{"location":"proyecto/proyecto/#vista-maestro-2-puntos","text":"Esta debe ser una pantalla con una barra de b\u00fasqueda y una vista de tabla en la que se puede buscar y listar el recurso elegido (por ejemplo personajes). El resultado final ser\u00e1 algo como: Ve a la primera (y por el momento \u00fanica) pantalla de contenido del tab bar , selecciona la barra inferior y en las propiedades bar item ponle un t\u00edtulo apropiado (por ejemplo \"Personajes\") y un icono relevante. Recuerda que tienes unas cuantas webs de donde puedes coger iconos \"planos\", por ejemplo https://www.iconfinder.com/iconsets/ios-7-icons o http://www.flaticon.com/packs/line-icon-set","title":"Vista maestro (2 puntos)"},{"location":"proyecto/proyecto/#crear-los-componentes-de-la-interfaz","text":"La tabla: Arrastra una table view a la pantalla de \"personajes\" (o \"comics\", o lo que hayas elegido) Selecciona la tabla y en las propiedades crea un prototipo de celda incrementando el Prototype cells a 1. Selecciona el prototipo de celda reci\u00e9n creado (el table view cell ) y en las propiedades elige como style el valor Basic , para poder usar uno de los tipos predefinidos de celda y no tener que hacerlo t\u00fa. La barra de b\u00fasqueda: Arrastra un componente de tipo search bar a la pantalla y d\u00e9jalo justo arriba de la tabla. Nos falta fijar el autolayout : Selecciona barra y tabla manteniendo pulsada la tecla Cmd e inserta ambas en un stack view utilizando el primero de los botones de autolayout (parte inferior derecha del *storyboard) Haz que este stack view ocupe toda la pantalla. Lo m\u00e1s sencillo es ponerle 4 restricciones de distancia 0 a los bordes. Una vez hecho esto puedes poner en marcha la app para ver si la interfaz tiene buen aspecto. La tabla aparecer\u00e1 vac\u00eda, por supuesto.","title":"Crear los componentes de la interfaz"},{"location":"proyecto/proyecto/#gestionar-la-barra-de-busqueda","text":"La barra de b\u00fasqueda utiliza el patr\u00f3n delegaci\u00f3n para gestionar los eventos de escribir en ella, pulsar \"buscar\" en el teclado, etc. El objeto que act\u00fae como delegate de la barra de b\u00fasqueda debe implementar el protocolo UISearchBarDelegate . Puede ser cualquiera, aunque siguiendo la filosof\u00eda MVC (Monster View Controller) haremos que sea el view controller de la pantalla actual :). Vamos a crear este view controller : Crea una nueva clase de Cocoa Touch llamada ListaController y haz que sea una subclase de UIViewController As\u00edgnale ese controller a la pantalla de lista que has creado antes. Recuerda que esto se hace a trav\u00e9s del identity inspector . Ahora vamos a conectar el view controller con la barra de b\u00fasqueda: Selecciona la search bar (te ser\u00e1 m\u00e1s f\u00e1cil si lo haces en el \u00e1rbol de componentes) y en el connections inspector (panel de la derecha de Xcode, icono de m\u00e1s a la derecha) conecta el outlet delegate con el controller de esta pantalla. Recuerda que el controller est\u00e1 representado gr\u00e1ficamente con un icono de color amarillo que aparece en la parte superior de cada pantalla de la app en el storyboard . Pon en la cabecera ListaController que esta clase implementa el protocolo UISearchBarDelegate En el ListaController implementa el m\u00e9todo searchBarSearchButtonClicked(_) , que se llamar\u00e1 cuando se escriba algo en la barra y se pulse el bot\u00f3n del teclado \"buscar\". Para probar que funciona de momento basta que imprimas en la consola el texto escrito en la barra y quites el teclado on screen . 1 2 3 4 func searchBarSearchButtonClicked ( _ searchBar : UISearchBar ) { print ( \"Buscado: \\( searchBar . text ! ) \" ) searchBar . resignFirstResponder () } Ejecuta la app y comprueba que efectivamente funciona. Ahora tendr\u00e1s que poner c\u00f3digo propio para que cuando se pulse en el bot\u00f3n de buscar se haga la llamada a la API de Marvel. Por el momento lo m\u00e1s simple es mostrar los resultados con print . Puedes asign\u00e1rselos tambi\u00e9n a un array que sea una propiedad del controller , para que luego sean sencillos de mostrar en la tabla.","title":"Gestionar la barra de b\u00fasqueda"},{"location":"proyecto/proyecto/#mostrar-los-resultados-en-la-tabla","text":"Una vez conseguido esto, tendr\u00e1s que hacer que los resultados aparezcan en la tabla. Recuerda que necesitas un datasource para ella, y que para simplificar puedes hacer que sea el ListaController . A grandes rasgos esto implica: Que, como dec\u00edamos antes, el controller debe tener acceso a los datos, por ejemplo guard\u00e1ndolos en una propiedad que sea un array. Que tienes que conectar en el connections inspector el outlet datasource con el controller . Que el ListaController debe implementar el protocolo UITableViewDataSource . Hay que poner en la cabecera que esto es as\u00ed, y adem\u00e1s implementar los correspondientes m\u00e9todos en el c\u00f3digo del controller , uno para devolver el n\u00famero de filas en la tabla y otro para devolver una celda dado su indexPath . Cada vez que se haga una b\u00fasqueda y se a\u00f1adan datos al array tendr\u00e1s que decirle a iOS que vuelva a redibujar la tabla llamando a su m\u00e9todo reloadData . Cuidado, porque al ser una actualizaci\u00f3n de la interfaz debes asegurarte de que esto lo est\u00e1s haciendo desde el thread principal, algo como: 1 2 3 4 5 //sustituye self.vistaTabla por el outlet que hayas definido //para acceder a la tabla desde el controlador OperationQueue . main . addOperation () { self . vistaTabla . reloadData (); } Obtener la cola principal de operaciones expl\u00edcitamente es necesario si, como es lo m\u00e1s l\u00f3gico, colocas el c\u00f3digo anterior en el bloque que obtiene la respuesta del API de Marvel. Recuerda que para evitar bloqueos, Marvelous funciona de modo as\u00edncrono en un thread distinto al principal Una vez terminado todo esto, esta pantalla deber\u00eda ser casi totalmente funcional. Solo quedar\u00eda ver los detalles de cada item al hacer tap sobre \u00e9l. Opcionalmente (0,25 puntos extra) , puedes hacer que aparezca un spinner mientras se est\u00e1 procesando la petici\u00f3n, para que el usuario sepa que el sistema est\u00e1 esperando datos. Los spinners en iOS se denominan Activity Indicators . Puedes consultar la referencia de la clase UIActivityIndicator para ver la forma de uso, aunque es muy sencillo, b\u00e1sicamente debes hacer startAnimating para que empiece a girar y stopAnimating para pararlo. Es posible que el activity indicator se te quede detr\u00e1s de los otros elementos de interfaz y no se vea. Puedes usar el m\u00e9todo bringSubviewToFront que se llama desde la vista \"madre\" para pasar a una vista \"hija\" a \"primer plano\". Si estamos en el controller ser\u00eda algo como self.view bringSubview(toFront:self.miActivityIndicator) , ya que recuerda que self.view en un controller es la vista principal. Tendr\u00e1s que sustituir la referencia self.miActivityIndicator por la apropiada en tu caso. Adem\u00e1s de esto lleva cuidado tambi\u00e9n con el color, otro problema t\u00edpico es usar uno del mismo color que el fondo.","title":"Mostrar los resultados en la tabla"},{"location":"proyecto/proyecto/#vista-de-detalle-15-puntos","text":"La nueva pantalla mostrar\u00e1 los datos de un item al hacer tap . Como una vez en los detalles queremos poder volver atr\u00e1s al listado de forma sencilla, lo mejor es usar un navigation controller :","title":"Vista de detalle (1,5 puntos)"},{"location":"proyecto/proyecto/#el-navigation-controller","text":"En este apartado todav\u00eda no estamos implementando la vista de detalle, solo creando la jerarqu\u00eda de navegaci\u00f3n. Selecciona la pantalla de lista y elige la opci\u00f3n de men\u00fa Editor > Embed In > Navigation Controller . Aparecer\u00e1 un nuevo navigation controller que tiene como primer nivel de navegaci\u00f3n a la pantalla de lista de items. Fijate que en la parte superior de la pantalla de items habr\u00e1 aparecido un espacio reservado para el t\u00edtulo y los botones de navegaci\u00f3n. Esto puede haber \"trastocado\" en modo dise\u00f1o el resto de los elementos de la interfaz (aunque cuando se ejecute la app deber\u00edan seguir funcionando bien). Recuerda que puedes volverlos \"a su sitio\" en modo dise\u00f1o con el Update Frames del autolayout . Selecciona la nueva barra de t\u00edtulo de la vista de lista y en las propiedades pon como title el recurso que est\u00e1s mostrando (personajes, autores, comics,...).","title":"El navigation controller"},{"location":"proyecto/proyecto/#la-pantalla-de-detalles-del-item","text":"Esta ser\u00eda la que muestra todos los datos de un personaje, comic, creador,... junto a su imagen si es que la tiene. Si quieres usar una tabla est\u00e1tica para dise\u00f1ar esta pantalla debes usar como controller una clase que herede de UITableViewController","title":"La pantalla de detalles del item"},{"location":"proyecto/proyecto/#creacion-de-la-interfaz-y-conexion-con-la-pantalla-anterior","text":"Arrastra un \"view controller\" al storyboard En la pantalla anterior, haz ctrl+arrastrar entre la celda prototipo y la pantalla actual. Elige el tipo adecuado de segue . Implementa una clase DetalleViewController que herede de UIViewController y as\u00f3ciala a esta pantalla.","title":"Creaci\u00f3n de la interfaz y conexi\u00f3n con la pantalla anterior"},{"location":"proyecto/proyecto/#implementacion-de-la-funcionalidad","text":"Define en el DetalleViewController una propiedad del tipo de recurso que est\u00e9s mostrando ( RCCharacterObject , RCComicsObject , RCCreatorObject ,...) En el prepareForSegue de la pantalla de lista instancia esta propiedad para que contenga el objeto a mostrar. Para saber qu\u00e9 fila de la tabla se ha seleccionado puedes seleccionar la propiedad del objeto tabla llamada indexPathForSelectedRow , que almacena el indexPath de la fila seleccionada. La propiedad row de este index path es el n\u00famero de fila. Usa los componentes que consideres necesarios para mostrar los datos del objeto (no es necesario que sean todos, solo los que quieras, para probar que funciona). Tendr\u00e1s que crear un outlet por cada campo, y rellenar los campos en el viewDidLoad del controller . Puedes consultar la referencia de clases en la documentaci\u00f3n online de Marvelous para saber qu\u00e9 propiedades tiene cada objeto. La referencia est\u00e1 en Objective-C pero no es dif\u00edcil deducir qu\u00e9 es cada propiedad Entre otras cosas, en esta pantalla deber\u00edas mostrar la imagen del personaje, comic, creador o lo que sea que hayas elegido, a un tama\u00f1o relativamente peque\u00f1o. La carga de la imagen deber\u00edas hacerla en un hilo secundario, para no paralizar la interfaz de usuario si la imagen tarda en cargarse: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let colaBackground = OperationQueue () colaBackground . addOperation { if let thumb = personajes [ 0 ]. thumbnail { let url = \" \\( thumb . basePath ! ) /portrait_uncanny. \\( thumb . extension ! ) \" let urlHttps = url . replacingOccurrences ( of : \"http\" , with : \"https\" ) if let urlFinal = URL ( string : urlHttps ) { do { let datos = try Data ( contentsOf : urlFinal ) if let img = UIImage ( data : datos ) { OperationQueue . main . addOperation { self . miImagen . image = img } } } catch { } } } } Puedes consultar esta p\u00e1gina para ver el formato de las URL de las im\u00e1genes. B\u00e1sicamente se construyen con una trayectoria base seguidas de un \"modificador\" de aspecto y tama\u00f1o ( portrait_small , landscape_medium , ...) y la extensi\u00f3n del archivo. En el c\u00f3digo anterior se obtiene la URL de la imagen y luego se cambia el http: por https: . En iOS>=9 una app no puede hacer una petici\u00f3n a una URL web si no es con https: . Esto deber\u00eda cambiarse en la propia librer\u00eda Marvelous , pero podemos salir del paso con este peque\u00f1o parche .","title":"Implementaci\u00f3n de la funcionalidad"},{"location":"proyecto/proyecto/#imagen-a-tamano-completo-1-punto","text":"Implementa una nueva pantalla en la que se pueda ver solo la imagen a mayor tama\u00f1o. Haz que la transici\u00f3n se realice con un segue modal pulsando sobre alg\u00fan bot\u00f3n \"ver imagen ampliada\" (si tienes activadas las size classes el tipo equivalente es present modally ). En el API de Marvel, la URL de la imagen a tama\u00f1o completo se consigue simplemente concatenando las propiedades basePath y extension , y a\u00f1adiendo un punto entre ellas, de modo que ser\u00eda pr\u00e1cticamente igual al c\u00f3digo para cargar la imagen en la pantalla anterior pero sin poner el \"modificador\" (en el ejemplo era portrait-uncanny ). La pantalla debe tener alg\u00fan bot\u00f3n o similar para volver a la anterior.","title":"Imagen a tama\u00f1o completo (1 punto)"},{"location":"proyecto/proyecto/#vista-acerca-de-025-puntos","text":"Esta es la segunda de las pantallas del tab bar . Simplemente debe consistir en una imagen est\u00e1tica y un text view con informaci\u00f3n sobre la aplicaci\u00f3n.","title":"Vista \"Acerca de\" (0,25 puntos)"},{"location":"proyecto/proyecto/#apendice-creacion-de-la-plantilla-de-proyecto-desde-cero","text":"Esta secci\u00f3n est\u00e1 solo para que veas c\u00f3mo se ha creado la plantilla de proyecto, no es necesario que lo hagas si has usado la plantilla que est\u00e1 en moodle Por desgracia Xcode no integra ning\u00fan sistema de gesti\u00f3n de dependencias de librer\u00edas de terceros, as\u00ed que acudiremos a una herramienta que no es de Apple pero que se ha convertido en un est\u00e1ndar de facto en el mundo iOS: CocoaPods . Cocoapods es a la vez un repositorio de librer\u00edas y un gestor de dependencias para instalar autom\u00e1ticamente estas librer\u00edas en nuestros proyectos. Hay muchas librer\u00edas de terceros disponibles con este sistema, puedes buscarlas desde la p\u00e1gina de CocoaPods. Para instalar cocoapods , desde la terminal hacer 1 2 #Con --pre decimos que queremos instalar la \u00faltima versi\u00f3n, aunque sea RC sudo gem install cocoapods --pre Esto instala la herramienta desde un repositorio de Internet, as\u00ed que necesitar\u00e1s conectividad...y paciencia, seg\u00fan vaya la red. Si todo va bien se instalar\u00e1 un comando llamado pod . Ejec\u00fatalo desde la terminal para comprobar al menos que existe. Ahora debes seguir estos pasos: Crear un proyecto Xcode para la aplicaci\u00f3n. Ll\u00e1malo por ejemplo Marvel Con un editor de textos cualquiera, crear un fichero llamado Podfile en el directorio del proyecto (el que contiene el fichero .xcodeproj ). Este archivo debe contener la configuraci\u00f3n y las dependencias (o pods ) del proyecto 1 2 3 4 5 6 platform :ios, '11.0' use_frameworks! //SUSTITUYE 'Marvel' por el nombre de tu proyecto, si no se llama as\u00ed!!! target 'Marvel' do pod 'Marvelous' end Abre una terminal. Mu\u00e9vete hasta el directorio donde est\u00e1 el Podfile y desde \u00e9l ejecuta el comando pod install . Las dependencias de nuestro proyecto se bajar\u00e1n autom\u00e1ticamente y se crear\u00e1 en el directorio actual un Marvel.xcworkspace A partir de ahora para trabajar en el proyecto siempre abriremos el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Veremos que en Xcode se muestra nuestro proyecto y adem\u00e1s un proyecto adicional llamado Pods , que contiene las dependencias. Este \u00faltimo no lo tocaremos, pero es necesario que est\u00e9 ah\u00ed para que funcione el nuestro.","title":"Ap\u00e9ndice: creaci\u00f3n de la plantilla de proyecto desde cero"},{"location":"proyecto/proyecto/#uso-de-marvelous","text":"ANTES de empezar a escribir c\u00f3digo aseg\u00farate de hacer en Xcode un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Para poder hacer llamadas al API de Marvel necesitas un par de claves. Las puedes ver, una vez dado de alta y autentificado en Marvel, en https://developer.marvel.com/account El siguiente c\u00f3digo ya est\u00e1 metido en la plantilla, si te la has bajado. Solo es necesario poner en marcha el proyecto para probar si sale en la consola la lista de personajes. Para probar de manera sencilla la librer\u00eda Marvelous puedes poner este import en el ViewController 1 import Marvelous Y ahora copiar la siguiente funci\u00f3n en el view controller , quemuestran en la consola todos los personajes cuyo nombre comienza por una determinada cadena. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func mostrarPersonajes ( comienzanPor cadena : String ) { let marvelAPI = RCMarvelAPI () //PUEDES CAMBIAR ESTO PARA PONER TUS CLAVES marvelAPI . publicKey = \"a6927e7e15930110aade56ef90244f6d\" marvelAPI . privateKey = \"487b621fc3c0d6f128b468ba86c99c508f24d357\" let filtro = RCCharacterFilter () filtro . nameStartsWith = cadena marvelAPI . characters ( by : filtro ) { resultados , info , error in if let personajes = resultados as ! [ RCCharacterObject ]? { for personaje in personajes { print ( personaje . name ) } print ( \"Hay \\( personajes . count ) personajes\" ) } } } Puedes llamar a la funci\u00f3n anterior desde el viewDidLoad del view controller 1 2 3 4 5 override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view, typically from a nib. mostrarPersonajes ( comienzanPor : \"Spider\" ) }","title":"Uso de Marvelous"}]}