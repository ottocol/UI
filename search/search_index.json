{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Interfaz de usuario, bloque de iOS b\u00e1sico \u00b6 En este bloque de la asignatura vamos a ver una introducci\u00f3n al desarrollo de interfaces para aplicaciones iOS. Aunque ya hemos visto algunos conceptos b\u00e1sicos sobre interfaces en la asignatura de Tecnolog\u00edas de Desarrollo, aqu\u00ed profundizaremos un poco m\u00e1s sobre ellos y veremos detalles que no vimos antes, como nuevos componentes de interfaz (sliders, pickers ,...) o c\u00f3mo se hacen aplicaciones con varias \"pantallas\" (varios controladores). Completaremos este bloque con una introducci\u00f3n a las tablas , que son la forma est\u00e1ndar en la que podemos mostrar informaci\u00f3n en forma de listas y tambi\u00e9n autolayout , un mecanismo que nos permite adaptar autom\u00e1ticamente la interfaz al tama\u00f1o de la pantalla del dispositivo actual.","title":"Interfaz de usuario, bloque de iOS b\u00e1sico"},{"location":"#interfaz-de-usuario-bloque-de-ios-basico","text":"En este bloque de la asignatura vamos a ver una introducci\u00f3n al desarrollo de interfaces para aplicaciones iOS. Aunque ya hemos visto algunos conceptos b\u00e1sicos sobre interfaces en la asignatura de Tecnolog\u00edas de Desarrollo, aqu\u00ed profundizaremos un poco m\u00e1s sobre ellos y veremos detalles que no vimos antes, como nuevos componentes de interfaz (sliders, pickers ,...) o c\u00f3mo se hacen aplicaciones con varias \"pantallas\" (varios controladores). Completaremos este bloque con una introducci\u00f3n a las tablas , que son la forma est\u00e1ndar en la que podemos mostrar informaci\u00f3n en forma de listas y tambi\u00e9n autolayout , un mecanismo que nos permite adaptar autom\u00e1ticamente la interfaz al tama\u00f1o de la pantalla del dispositivo actual.","title":"Interfaz de usuario, bloque de iOS b\u00e1sico"},{"location":"SUMMARY/","text":"Contenidos \u00b6 View controllers Funciones de los view controllers Storyboards Segues NIBs Ejercicios Vistas. Componentes de la interfaz Interacci\u00f3n con la interfaz por c\u00f3digo Propiedades de una vista Algunos componentes de interfaz de usuario Ejercicios Autolayout El por qu\u00e9 de autolayout Manejo de restricciones con Xcode M\u00e1s sobre las restricciones Formular restricciones usando c\u00f3digo Ejercicios Tablas Introducci\u00f3n Tablas est\u00e1ticas Tablas din\u00e1micas Gesti\u00f3n de tablas Ejercicios Controladores contenedores Tab bar controllers Navigation controllers Proyecto","title":"Contenidos"},{"location":"SUMMARY/#contenidos","text":"View controllers Funciones de los view controllers Storyboards Segues NIBs Ejercicios Vistas. Componentes de la interfaz Interacci\u00f3n con la interfaz por c\u00f3digo Propiedades de una vista Algunos componentes de interfaz de usuario Ejercicios Autolayout El por qu\u00e9 de autolayout Manejo de restricciones con Xcode M\u00e1s sobre las restricciones Formular restricciones usando c\u00f3digo Ejercicios Tablas Introducci\u00f3n Tablas est\u00e1ticas Tablas din\u00e1micas Gesti\u00f3n de tablas Ejercicios Controladores contenedores Tab bar controllers Navigation controllers Proyecto","title":"Contenidos"},{"location":"1_controllers/apuntes/","text":"View Controllers \u00b6 View controllers . Funciones b\u00e1sicas \u00b6 Hay dos tipos b\u00e1sicos de controladores: los que muestran directamente contenido ( content controllers ) y los que contienen otros contenedores ( container controllers ). Estos \u00faltimos contienen a otros controladores. Lo que hace el contenedor es redimensionar y colocar la vista principal de sus hijos, pero cada uno de ellos es responsable de mostrar su propio contenido Otras tareas de los view controllers \u00b6 Adem\u00e1s de gestionar la jerarqu\u00eda de vistas, los controladores act\u00faan como el \u201cpegamento\u201d que relaciona la vista con el modelo. El controlador es el lugar t\u00edpico para poner el c\u00f3digo que reacciona a los eventos del usuario, como por ejemplo qu\u00e9 hacer cuando se pulsa un bot\u00f3n. Es nuestra responsabilidad como desarrolladores asegurarnos de que no colocamos demasiada l\u00f3gica en el c\u00f3digo del controller . La l\u00f3gica deber\u00eda ir en el modelo, no en el controller , que deber\u00eda contener el m\u00ednimo c\u00f3digo imprescindible para comunicar vista y modelo. Por otro lado, los controllers son los responsables de adaptar las dimensiones de los componentes de la interfaz a las dimensiones reales de la pantalla. Para ello se usan varios mecanismos: autolayout , size classes y traits , que veremos a nivel introductorio en las siguientes sesiones. Ciclo de vida de un controller \u00b6 Cada controlador va pasando por una serie de estados conforme se carga la aplicaci\u00f3n, se muestra la pantalla que este gestiona, se cambia de pantalla, etc. Hay tres m\u00e9todos principales en los que podemos colocar c\u00f3digo propio, seg\u00fan el momento en que queramos que se ejecute: viewDidLoad() : este m\u00e9todo ya lo hemos usado en nuestras aplicaciones. Se dispara cuando se carga la ra\u00edz de la jerarqu\u00eda de vistas del controlador. T\u00edpicamente se ejecutar\u00eda una sola vez en toda la aplicaci\u00f3n, y por ello se suele usar para inicializar propiedades del controlador. No obstante si el sistema anda bajo de memoria puede liberar la correspondiente al controlador y como resultado este m\u00e9todo podr\u00eda ejecutarse m\u00e1s de una vez. viewWillAppear() : se ejecuta inmediatamente antes de dibujar la vista. viewDidAppear() : se ejecuta cuando la vista ya se ha dibujado. \u00datil para colocar c\u00f3digo relativo por ejemplo a animaciones. Los m\u00e9todos anteriores y sus \u201ccomplementarios\u201d (con disappear en lugar de appear ) se recogen en el siguiente esquema Instanciar controladores y vistas \u00b6 Podemos hacerlo de varias formas. De m\u00e1s sencilla a m\u00e1s compleja (pero tambi\u00e9n m\u00e1s flexible) Gr\u00e1ficamente, con storyboards : tanto las vistas como el controlador est\u00e1n en el storyboard Gr\u00e1ficamente, con .nib : en cada archivo nib guardamos una pantalla (con su jerarqu\u00eda de vistas), pero no el controlador, que se crea por c\u00f3digo Totalmente por c\u00f3digo : tenemos que instanciar el controlador y en su m\u00e9todo loadView crear la jerarqu\u00eda de vistas que queremos que contenga ( UIView , UIButton , lo que sea) y asignar la ra\u00edz de la jerarqu\u00eda de vistas a self.view . Dado el tiempo disponible, solo vamos a ver la primera opci\u00f3n con m\u00e1s detalle. En general los storyboards van a ser suficientes para aplicaciones no demasiado complejas. Navegaci\u00f3n con Storyboards \u00b6 Los storyboards son la forma recomendada por Apple de crear interfaces de usuario. Un storyboard contiene la representaci\u00f3n gr\u00e1fica de las \u201cpantallas\u201d (los controladores) que componen nuestra aplicaci\u00f3n y de las relaciones entre ellas. Adem\u00e1s el sistema se encarga autom\u00e1ticamente de moverse por las pantallas cuando sucedan determinados eventos, instanciando los controladores y las vistas autom\u00e1ticamente. El controller inicial \u00b6 En cada momento habr\u00e1 un view controller inicial que es el que se muestra cuando se carga la aplicaci\u00f3n. Se distingue visualmente porque tiene una flecha apuntando a \u00e9l desde la izquierda: Para convertir un view controller en inicial , teni\u00e9ndolo seleccionado ir al icono de propiedades del \u00e1rea de Utilities y marcar sobre el checkbox Is initial view controller Tambi\u00e9n podemos arrastrar la flecha que indica que un controlador es el inicial desde el actual hasta el que queremos convertir en inicial. El controller de cada pantalla \u00b6 Simplificando, cada pantalla de nuestra app est\u00e1 controlada por una clase descendiente de la clase de UIKit UIViewController . Como ya hemos visto unas cuantas veces, la pantalla inicial de cada app est\u00e1 asociada a la clase ViewController de la plantilla. Puedes ver esto en Xcode, seleccionando con el rat\u00f3n el view controller y yendo al icono del Identity inspector en el panel de la derecha: . Para seleccionar el view controller con el rat\u00f3n pulsa el icono del c\u00edrculo amarillo con un cuadrado dentro que aparece en la barra de su parte superior. Otra opci\u00f3n es seleccionarlo en el panel que aparece a la izquierda del storyboard con el \u00e1rbol de componentes Podemos a\u00f1adir nuevas pantallas a nuestra app arrastrando al storyboard un componente de tipo View Controller del panel de componentes de UI. Por defecto, estos nuevos view controller estar\u00e1n asociados a clases propias de iOS, y si queremos personalizar su comportamiento tendremos que crear una clase propia que herede de UIViewController e implemente los m\u00e9todos b\u00e1sicos de gesti\u00f3n del ciclo de vida. En Xcode hay una plantilla para ello. Hay que: ir al men\u00fa File > New > File... En la primera pantalla del asistente que aparecer\u00e1 seleccionar Cocoa Touch Class , pulsar Next Poner un nombre a nuestra clase, por ejemplo ViewControllerSecundario y en Subclass of poner UIViewController , ya que necesitamos que herede de esta clase. Dejar desmarcada la casilla also create .XIB File . Pulsar Next Finalmente nos dejar\u00e1 elegir d\u00f3nde guardar f\u00edsicamente el archivo swift, podemos dejarlo por defecto y pulsar Create Si todo va bien ver\u00e1s que entre los archivos del proyecto aparece la nueva clase creada y que tiene la estructura tipica de un view controller (tiene por ejemplo un viewDidLoad ). Ya solo nos queda asociar la clase creada a la \"pantalla\" del storyboard . Recordemos que eso se hace en el Identity inspector del panel de la derecha. Segues \u00b6 Son las transiciones entre los controllers . Podemos crear un segue visualmente con Ctrl+Arrastrar entre un elemento cualquiera de un view controller (por ejemplo un bot\u00f3n), que ser\u00e1 el de controller de origen, y el controller destino. Se nos dar\u00e1 opci\u00f3n a elegir el tipo de segue en un men\u00fa contextual. Tipos b\u00e1sicos de segue \u00b6 Como vemos en el men\u00fa contextual hay cuatro tipos de segue . Dos de ellos son mostrar ( show ) y otros dos presentar ( present ). Adem\u00e1s podemos programar nuestro propio tipo de segue con custom . Show es la forma recomendada habitualmente, ya que permite que el controlador actual \u201cdecida\u201d c\u00f3mo mostrar f\u00edsicamente el nuevo. Por ejemplo si el controlador actual \u201cocupa\u201d toda la pantalla, el nuevo tambi\u00e9n lo har\u00e1, pero si por ejemplo es un tab bar controller solo cambiar\u00e1 la parte de la pantalla que muestra contenido, no la barra de herramientas Present quiere decir que el nuevo controller se mostrar\u00e1 de forma modal, de manera similar a cuando en un interfaz gr\u00e1fico se muestra por ejemplo un cuadro de di\u00e1logo modal. No obstante esto no quiere decir que el controller antiguo se siga viendo \u201cpor debajo\u201d, ya que en dispositivos con tama\u00f1o de pantalla limitado el nuevo ocupar\u00e1 toda la pantalla. Como vemos en el men\u00fa contextual, en el caso del show se distingue adem\u00e1s entre Show \u201ca secas\u201d y Show detail . El primero es el indicado cuando el nuevo controller va a sustituir completamente al anterior y el segundo cuando el nuevo es \u201csecundario\u201d con respecto al anterior (como en el ejemplo que pon\u00edamos del tab bar ). En el caso del present , se distingue entre Present Modally y Present As Popover . El primero ser\u00eda lo que todo el mundo entiende por \u201cmodal\u201d: el nuevo controller se pone \u201cencima\u201d del anterior. El segundo es el t\u00edpico popover que aparece en el iPad. En realidad la forma concreta de mostrar exactamente el nuevo controlador la decide iOS dependiendo de las dimensiones actuales del dispositivo. Por ejemplo en un iPhone SE en vertical no aparecer\u00e1 un popover aunque lo especifiquemos, la que la pantalla es muy peque\u00f1a para ello. Estilos de presentaci\u00f3n y de transici\u00f3n \u00b6 Podemos usar diversos estilos a la hora de presentar de forma modal un controller . Por ejemplo podemos indicar que el nuevo controlador debe ocupar toda la pantalla, o bien solo el alto dejando una zona a los lados, o bien un recuadro central como un cuadro de di\u00e1logo\u2026 Estos estilos se definen en una propiedad del controller a presentar, y no del segue . En Xcode podemos cambiarlos con la propiedad Presentation en el attribute inspector del controller . En Swift especificamos el estilo dando valores a la propiedad modalPresentationStyle del controller que vamos a presentar. Por otro lado, tambi\u00e9n podemos especificar una animaci\u00f3n para la transici\u00f3n entre el controller actual y el siguiente. De nuevo es una propiedad del controller destino, no del segue . En Xcode se controla gr\u00e1ficamente con la propiedad Transition style del inspector de atributos . En Swift con la propiedad modalTransitionStyle del controller a presentar. Pasar datos de un controller a otro en un segue \u00b6 Cuando se va a saltar de un controller a otro a trav\u00e9s de un segue , se llama al m\u00e9todo prepare(for:sender:) del controller origen. Podemos sobreescribir este m\u00e9todo para pasarle datos al controller destino. El primer par\u00e1metro va a instanciarse al segue y a partir de este podemos obtener una referencia al destino. Por ejemplo supongamos que tenemos dos controller conectados por un segue , y este se dispara con un bot\u00f3n en el primero. Supongamos que el primer controller es un objeto de la clase ViewController , mientras que el segundo es de la clase ViewControllerSecundario . En el c\u00f3digo de ViewControllerSecundario podr\u00eda haber algo como: class ViewControllerSecundario : UIViewController { var mensaje = \"\" override func viewDidLoad () { super . viewDidLoad () print ( self . mensaje ) } } Es decir, imprimimos un mensaje cuando se carga la pantalla (lo normal ser\u00eda mostrarlo en un label o similar, pero para los prop\u00f3sitos de este ejemplo nos basta con que salga en la consola). Podemos acceder a esta propiedad texto desde el controller anterior sobreescribiendo el m\u00e9todo prepare(for:sender:) override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if ( segue . identifier == \"siguiente\" ) { if let vc2 = segue . destination as ? ViewControllerSecundario { vc2 . mensaje = \"Bienvenidos a la pantalla 2\" } } } Segues que vuelven atr\u00e1s ( unwind segues ) \u00b6 Los segues que vuelven atr\u00e1s se llaman unwind segues y se crean de forma distinta a los segues convencionales, ya que la \"parte principal\" del segue se crea en el controller destino, y no en el origen. Esto nos permite \"deshacer\" por ejemplo varias transiciones a la vez, volviendo varias pantallas atr\u00e1s. En el controller destino de la vuelta debemos implementar lo que se llama un unwind action , un m\u00e9todo que puede tener el nombre que deseemos pero debe tener una signatura espec\u00edfica: Est\u00e1 marcada con un @IBAction Tiene como \u00fanico par\u00e1metro un UIStoryboardSegue , que es el segue que se est\u00e1 usando para volver atr\u00e1s. Por ejemplo @IBAction func miUnwind ( segue : UIStoryboardSegue ) { print ( \"Volviendo atr\u00e1s por \\( segue . identifier ) ...\" ) } Ahora en la pantalla que dispara el unwind debemos conectar usando Ctrl+Arrastrar el elemento de interfaz que produce la vuelta atr\u00e1s con el icono de Exit que aparece en la parte de arriba. Si intentamos hacer esta operaci\u00f3n de Ctrl+Arrastrar sin haber implementado el m\u00e9todo anterior, veremos que no tiene efecto En el m\u00e9todo del unwinding , n\u00f3tese que podemos usar el par\u00e1metro, que es el segue , para obtener el destination , que ahora ser\u00e1 el controller al que volvemos. Finalmente, decir que cuando se produce un unwind , el controlador desde el que se vuelve tambi\u00e9n recibe una llamada a prepare(for:sender:) , m\u00e9todo que podemos sobreescribir si queremos aprovechar para realizar alguna operaci\u00f3n antes de volver.","title":"View Controllers"},{"location":"1_controllers/apuntes/#view-controllers","text":"","title":"View Controllers"},{"location":"1_controllers/apuntes/#view-controllers-funciones-basicas","text":"Hay dos tipos b\u00e1sicos de controladores: los que muestran directamente contenido ( content controllers ) y los que contienen otros contenedores ( container controllers ). Estos \u00faltimos contienen a otros controladores. Lo que hace el contenedor es redimensionar y colocar la vista principal de sus hijos, pero cada uno de ellos es responsable de mostrar su propio contenido","title":"View controllers. Funciones b\u00e1sicas"},{"location":"1_controllers/apuntes/#otras-tareas-de-los-view-controllers","text":"Adem\u00e1s de gestionar la jerarqu\u00eda de vistas, los controladores act\u00faan como el \u201cpegamento\u201d que relaciona la vista con el modelo. El controlador es el lugar t\u00edpico para poner el c\u00f3digo que reacciona a los eventos del usuario, como por ejemplo qu\u00e9 hacer cuando se pulsa un bot\u00f3n. Es nuestra responsabilidad como desarrolladores asegurarnos de que no colocamos demasiada l\u00f3gica en el c\u00f3digo del controller . La l\u00f3gica deber\u00eda ir en el modelo, no en el controller , que deber\u00eda contener el m\u00ednimo c\u00f3digo imprescindible para comunicar vista y modelo. Por otro lado, los controllers son los responsables de adaptar las dimensiones de los componentes de la interfaz a las dimensiones reales de la pantalla. Para ello se usan varios mecanismos: autolayout , size classes y traits , que veremos a nivel introductorio en las siguientes sesiones.","title":"Otras tareas de los view controllers"},{"location":"1_controllers/apuntes/#ciclo-de-vida-de-un-controller","text":"Cada controlador va pasando por una serie de estados conforme se carga la aplicaci\u00f3n, se muestra la pantalla que este gestiona, se cambia de pantalla, etc. Hay tres m\u00e9todos principales en los que podemos colocar c\u00f3digo propio, seg\u00fan el momento en que queramos que se ejecute: viewDidLoad() : este m\u00e9todo ya lo hemos usado en nuestras aplicaciones. Se dispara cuando se carga la ra\u00edz de la jerarqu\u00eda de vistas del controlador. T\u00edpicamente se ejecutar\u00eda una sola vez en toda la aplicaci\u00f3n, y por ello se suele usar para inicializar propiedades del controlador. No obstante si el sistema anda bajo de memoria puede liberar la correspondiente al controlador y como resultado este m\u00e9todo podr\u00eda ejecutarse m\u00e1s de una vez. viewWillAppear() : se ejecuta inmediatamente antes de dibujar la vista. viewDidAppear() : se ejecuta cuando la vista ya se ha dibujado. \u00datil para colocar c\u00f3digo relativo por ejemplo a animaciones. Los m\u00e9todos anteriores y sus \u201ccomplementarios\u201d (con disappear en lugar de appear ) se recogen en el siguiente esquema","title":"Ciclo de vida de un controller"},{"location":"1_controllers/apuntes/#instanciar-controladores-y-vistas","text":"Podemos hacerlo de varias formas. De m\u00e1s sencilla a m\u00e1s compleja (pero tambi\u00e9n m\u00e1s flexible) Gr\u00e1ficamente, con storyboards : tanto las vistas como el controlador est\u00e1n en el storyboard Gr\u00e1ficamente, con .nib : en cada archivo nib guardamos una pantalla (con su jerarqu\u00eda de vistas), pero no el controlador, que se crea por c\u00f3digo Totalmente por c\u00f3digo : tenemos que instanciar el controlador y en su m\u00e9todo loadView crear la jerarqu\u00eda de vistas que queremos que contenga ( UIView , UIButton , lo que sea) y asignar la ra\u00edz de la jerarqu\u00eda de vistas a self.view . Dado el tiempo disponible, solo vamos a ver la primera opci\u00f3n con m\u00e1s detalle. En general los storyboards van a ser suficientes para aplicaciones no demasiado complejas.","title":"Instanciar controladores y vistas"},{"location":"1_controllers/apuntes/#navegacion-con-storyboards","text":"Los storyboards son la forma recomendada por Apple de crear interfaces de usuario. Un storyboard contiene la representaci\u00f3n gr\u00e1fica de las \u201cpantallas\u201d (los controladores) que componen nuestra aplicaci\u00f3n y de las relaciones entre ellas. Adem\u00e1s el sistema se encarga autom\u00e1ticamente de moverse por las pantallas cuando sucedan determinados eventos, instanciando los controladores y las vistas autom\u00e1ticamente.","title":"Navegaci\u00f3n con Storyboards"},{"location":"1_controllers/apuntes/#el-controller-inicial","text":"En cada momento habr\u00e1 un view controller inicial que es el que se muestra cuando se carga la aplicaci\u00f3n. Se distingue visualmente porque tiene una flecha apuntando a \u00e9l desde la izquierda: Para convertir un view controller en inicial , teni\u00e9ndolo seleccionado ir al icono de propiedades del \u00e1rea de Utilities y marcar sobre el checkbox Is initial view controller Tambi\u00e9n podemos arrastrar la flecha que indica que un controlador es el inicial desde el actual hasta el que queremos convertir en inicial.","title":"El controller inicial"},{"location":"1_controllers/apuntes/#el-controller-de-cada-pantalla","text":"Simplificando, cada pantalla de nuestra app est\u00e1 controlada por una clase descendiente de la clase de UIKit UIViewController . Como ya hemos visto unas cuantas veces, la pantalla inicial de cada app est\u00e1 asociada a la clase ViewController de la plantilla. Puedes ver esto en Xcode, seleccionando con el rat\u00f3n el view controller y yendo al icono del Identity inspector en el panel de la derecha: . Para seleccionar el view controller con el rat\u00f3n pulsa el icono del c\u00edrculo amarillo con un cuadrado dentro que aparece en la barra de su parte superior. Otra opci\u00f3n es seleccionarlo en el panel que aparece a la izquierda del storyboard con el \u00e1rbol de componentes Podemos a\u00f1adir nuevas pantallas a nuestra app arrastrando al storyboard un componente de tipo View Controller del panel de componentes de UI. Por defecto, estos nuevos view controller estar\u00e1n asociados a clases propias de iOS, y si queremos personalizar su comportamiento tendremos que crear una clase propia que herede de UIViewController e implemente los m\u00e9todos b\u00e1sicos de gesti\u00f3n del ciclo de vida. En Xcode hay una plantilla para ello. Hay que: ir al men\u00fa File > New > File... En la primera pantalla del asistente que aparecer\u00e1 seleccionar Cocoa Touch Class , pulsar Next Poner un nombre a nuestra clase, por ejemplo ViewControllerSecundario y en Subclass of poner UIViewController , ya que necesitamos que herede de esta clase. Dejar desmarcada la casilla also create .XIB File . Pulsar Next Finalmente nos dejar\u00e1 elegir d\u00f3nde guardar f\u00edsicamente el archivo swift, podemos dejarlo por defecto y pulsar Create Si todo va bien ver\u00e1s que entre los archivos del proyecto aparece la nueva clase creada y que tiene la estructura tipica de un view controller (tiene por ejemplo un viewDidLoad ). Ya solo nos queda asociar la clase creada a la \"pantalla\" del storyboard . Recordemos que eso se hace en el Identity inspector del panel de la derecha.","title":"El controller de cada pantalla"},{"location":"1_controllers/apuntes/#segues","text":"Son las transiciones entre los controllers . Podemos crear un segue visualmente con Ctrl+Arrastrar entre un elemento cualquiera de un view controller (por ejemplo un bot\u00f3n), que ser\u00e1 el de controller de origen, y el controller destino. Se nos dar\u00e1 opci\u00f3n a elegir el tipo de segue en un men\u00fa contextual.","title":"Segues"},{"location":"1_controllers/apuntes/#tipos-basicos-de-segue","text":"Como vemos en el men\u00fa contextual hay cuatro tipos de segue . Dos de ellos son mostrar ( show ) y otros dos presentar ( present ). Adem\u00e1s podemos programar nuestro propio tipo de segue con custom . Show es la forma recomendada habitualmente, ya que permite que el controlador actual \u201cdecida\u201d c\u00f3mo mostrar f\u00edsicamente el nuevo. Por ejemplo si el controlador actual \u201cocupa\u201d toda la pantalla, el nuevo tambi\u00e9n lo har\u00e1, pero si por ejemplo es un tab bar controller solo cambiar\u00e1 la parte de la pantalla que muestra contenido, no la barra de herramientas Present quiere decir que el nuevo controller se mostrar\u00e1 de forma modal, de manera similar a cuando en un interfaz gr\u00e1fico se muestra por ejemplo un cuadro de di\u00e1logo modal. No obstante esto no quiere decir que el controller antiguo se siga viendo \u201cpor debajo\u201d, ya que en dispositivos con tama\u00f1o de pantalla limitado el nuevo ocupar\u00e1 toda la pantalla. Como vemos en el men\u00fa contextual, en el caso del show se distingue adem\u00e1s entre Show \u201ca secas\u201d y Show detail . El primero es el indicado cuando el nuevo controller va a sustituir completamente al anterior y el segundo cuando el nuevo es \u201csecundario\u201d con respecto al anterior (como en el ejemplo que pon\u00edamos del tab bar ). En el caso del present , se distingue entre Present Modally y Present As Popover . El primero ser\u00eda lo que todo el mundo entiende por \u201cmodal\u201d: el nuevo controller se pone \u201cencima\u201d del anterior. El segundo es el t\u00edpico popover que aparece en el iPad. En realidad la forma concreta de mostrar exactamente el nuevo controlador la decide iOS dependiendo de las dimensiones actuales del dispositivo. Por ejemplo en un iPhone SE en vertical no aparecer\u00e1 un popover aunque lo especifiquemos, la que la pantalla es muy peque\u00f1a para ello.","title":"Tipos b\u00e1sicos de segue"},{"location":"1_controllers/apuntes/#estilos-de-presentacion-y-de-transicion","text":"Podemos usar diversos estilos a la hora de presentar de forma modal un controller . Por ejemplo podemos indicar que el nuevo controlador debe ocupar toda la pantalla, o bien solo el alto dejando una zona a los lados, o bien un recuadro central como un cuadro de di\u00e1logo\u2026 Estos estilos se definen en una propiedad del controller a presentar, y no del segue . En Xcode podemos cambiarlos con la propiedad Presentation en el attribute inspector del controller . En Swift especificamos el estilo dando valores a la propiedad modalPresentationStyle del controller que vamos a presentar. Por otro lado, tambi\u00e9n podemos especificar una animaci\u00f3n para la transici\u00f3n entre el controller actual y el siguiente. De nuevo es una propiedad del controller destino, no del segue . En Xcode se controla gr\u00e1ficamente con la propiedad Transition style del inspector de atributos . En Swift con la propiedad modalTransitionStyle del controller a presentar.","title":"Estilos de presentaci\u00f3n y de transici\u00f3n"},{"location":"1_controllers/apuntes/#pasar-datos-de-un-controller-a-otro-en-un-segue","text":"Cuando se va a saltar de un controller a otro a trav\u00e9s de un segue , se llama al m\u00e9todo prepare(for:sender:) del controller origen. Podemos sobreescribir este m\u00e9todo para pasarle datos al controller destino. El primer par\u00e1metro va a instanciarse al segue y a partir de este podemos obtener una referencia al destino. Por ejemplo supongamos que tenemos dos controller conectados por un segue , y este se dispara con un bot\u00f3n en el primero. Supongamos que el primer controller es un objeto de la clase ViewController , mientras que el segundo es de la clase ViewControllerSecundario . En el c\u00f3digo de ViewControllerSecundario podr\u00eda haber algo como: class ViewControllerSecundario : UIViewController { var mensaje = \"\" override func viewDidLoad () { super . viewDidLoad () print ( self . mensaje ) } } Es decir, imprimimos un mensaje cuando se carga la pantalla (lo normal ser\u00eda mostrarlo en un label o similar, pero para los prop\u00f3sitos de este ejemplo nos basta con que salga en la consola). Podemos acceder a esta propiedad texto desde el controller anterior sobreescribiendo el m\u00e9todo prepare(for:sender:) override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { if ( segue . identifier == \"siguiente\" ) { if let vc2 = segue . destination as ? ViewControllerSecundario { vc2 . mensaje = \"Bienvenidos a la pantalla 2\" } } }","title":"Pasar datos de un controller a otro en un segue"},{"location":"1_controllers/apuntes/#segues-que-vuelven-atras-unwind-segues","text":"Los segues que vuelven atr\u00e1s se llaman unwind segues y se crean de forma distinta a los segues convencionales, ya que la \"parte principal\" del segue se crea en el controller destino, y no en el origen. Esto nos permite \"deshacer\" por ejemplo varias transiciones a la vez, volviendo varias pantallas atr\u00e1s. En el controller destino de la vuelta debemos implementar lo que se llama un unwind action , un m\u00e9todo que puede tener el nombre que deseemos pero debe tener una signatura espec\u00edfica: Est\u00e1 marcada con un @IBAction Tiene como \u00fanico par\u00e1metro un UIStoryboardSegue , que es el segue que se est\u00e1 usando para volver atr\u00e1s. Por ejemplo @IBAction func miUnwind ( segue : UIStoryboardSegue ) { print ( \"Volviendo atr\u00e1s por \\( segue . identifier ) ...\" ) } Ahora en la pantalla que dispara el unwind debemos conectar usando Ctrl+Arrastrar el elemento de interfaz que produce la vuelta atr\u00e1s con el icono de Exit que aparece en la parte de arriba. Si intentamos hacer esta operaci\u00f3n de Ctrl+Arrastrar sin haber implementado el m\u00e9todo anterior, veremos que no tiene efecto En el m\u00e9todo del unwinding , n\u00f3tese que podemos usar el par\u00e1metro, que es el segue , para obtener el destination , que ahora ser\u00e1 el controller al que volvemos. Finalmente, decir que cuando se produce un unwind , el controlador desde el que se vuelve tambi\u00e9n recibe una llamada a prepare(for:sender:) , m\u00e9todo que podemos sobreescribir si queremos aprovechar para realizar alguna operaci\u00f3n antes de volver.","title":"Segues que vuelven atr\u00e1s (unwind segues)"},{"location":"1_controllers/ejercicios/","text":"Ejercicio de view controllers (1,25 puntos) \u00b6 Vamos a hacer una aplicaci\u00f3n que vamos a llamar \u201cPioneras\u201d, y que nos dar\u00e1 datos de algunas mujeres pioneras de la inform\u00e1tica. La aplicaci\u00f3n tendr\u00e1 una pantalla principal en la que aparecer\u00e1n sus im\u00e1genes, y haciendo tap sobre cada una podremos ir a las pantallas secundarias donde se nos dar\u00e1 m\u00e1s informaci\u00f3n. Al crear el proyecto asegur\u00e1os de estar usando git ya que habr\u00e1 que guardar y marcar el estado con un commit especial en un momento intermedio. No es necesario subir el repositorio a Github, con tenerlo en local nos valdr\u00eda Realizar la estructura b\u00e1sica de la aplicaci\u00f3n (0,5 puntos) \u00b6 En este archivo tenemos las im\u00e1genes de las tres pioneras: Ada Lovelace, Grace Hopper y Barbara Liskov, que como siempre arrastraremos al Assets.xcassets . Tambi\u00e9n tenemos los textos sobre ellas que se mostrar\u00e1n en las pantallas secundarias. Crea tres botones en la pantalla principal, y para cada uno de ellos en lugar de texto vamos a usar como imagen de fondo la de cada mujer. Al final cada bot\u00f3n deber\u00eda ocupar todo el ancho de la pantalla y m\u00e1s o menos un tercio del alto. Importante: no es necesario que la interfaz sea perfecta (todos los botones exactamente del mismo alto, etc). De hecho si la pruebas en un dispositivo de tama\u00f1o de pantalla distinto al que est\u00e1s usando ahora mismo en Xcode ver\u00e1s que se ve \u201cfatal\u201d. Para hacer que todos los botones tengan el mismo alto y que se adapten bien a la pantalla usaremos un mecanismo que todav\u00eda no hemos visto denominado autolayout . Por el momento vamos a ignorar este tema Arrastra un nuevo \u201cview controller\u201d al storyboard (una \u201cpantalla\u201d nueva), que ser\u00e1 el que aparezca cuando se pulse en el primero de los botones (el de Ada Lovelace). Inserta un campo de texto de varias l\u00edneas ( text view ) y copia en \u00e9l el contenido de lovelace.txt Ahora establece el segue entre las dos pantallas : haz Ctrl+Arrastrar desde el primero de los botones con la imagen de Ada Lovelace hasta la segunda pantalla. Ejecuta el proyecto para comprobar que funciona lo que has hecho, aunque todav\u00eda no puede volver atr\u00e1s desde la pantalla secundaria Implementa la opci\u00f3n de volver atr\u00e1s de la secundaria a la principal Crea un bot\u00f3n \u201catr\u00e1s\u201d en la pantalla secundaria y col\u00f3calo en la parte de arriba (para que no lo tape el teclado on-screen si aparece) En el controller destino crea un m\u00e9todo para que funcione el unwinding (no hace falta que haga nada, solo que exista) @IBAction func retornoDeSecundaria ( segue : UIStoryboardSegue ) { } Con Ctrl+Arrastrar conecta el bot\u00f3n \u201catr\u00e1s\u201d con el icono de \u201cExit\u201d de la parte superior del controller Ejecuta el proyecto y comprueba que puedes volver atr\u00e1s desde la pantalla secundaria 6. Repite lo que has hecho en el caso de Ada Lovelace para las otras dos mujeres, creando las pantallas secundarias y la navegaci\u00f3n adelante y atr\u00e1s. Asegur\u00e1os de guardar el estado actual del proyecto con un commit cuyo comentario sea \u201cversion 1\u201d. Comunicar un controller con otro (0,75 punto) \u00b6 Es un poco redundante tener tantas pantallas secundarias cuando en realidad lo \u00fanico que cambia es el texto a mostrar. Valdr\u00eda con una sola secundaria en la que cambi\u00e1ramos din\u00e1micamente dicho texto. Vamos a implementarlo as\u00ed. Ahora pod\u00e9is eliminar los segues y las pantallas secundarias, es mejor crearlos de nuevo. Crear la nueva interfaz \u00b6 Crea de nuevo una pantalla secundaria con un campo de texto de varias l\u00edneas Con Ctrl+arrastrar podemos crear un segue desde cada uno de los botones hasta la pantalla. Habr\u00e1n tres segues que lleguen a la misma, no deber\u00eda ser problema. A\u00f1\u00e1dele a la pantalla el bot\u00f3n de \u201catr\u00e1s\u201d y con\u00e9ctalo con el icono de \u201cexit\u201d. El c\u00f3digo necesario para el unwinding (m\u00e9todo retornoDeSecundaria ) ya deber\u00eda estar en el ViewController Comprueba que la navegaci\u00f3n funciona correctamente yendo adelante y atr\u00e1s Crear un controlador personalizado para la pantalla secundaria \u00b6 Si en la parte derecha de la pantalla miras el identity inspector ver\u00e1s que el controlador de la pantalla secundaria es un tipo propio de Cocoa, el UIViewController . Vamos a cambiarlo por uno propio Crea una nueva clase de Cocoa Touch, (File> New > File\u2026, plantilla \u201ccocoa touch class\u201d). En la segunda pantalla del asistente dale a la clase el nombre SecundarioViewController y haz que sea una subclase de UIViewController . Deja sin marcar la opci\u00f3n de crear el .XIB En el storyboard , selecciona el controller de la pantalla secundaria (es mejor que lo hagas pulsando en el primero de los iconos que aparecen en la parte superior) Una vez seleccionado, ve al identity inspector en el \u00e1rea de Utilities y en el apartado de Custom class selecciona como clase la que has creado, SecundarioViewController A\u00f1adirle un outlet al controlador secundario \u00b6 Tienes que a\u00f1adir un outlet al campo de texto para que su contenido se pueda cambiar desde el controlador secundario. Hazlo como habitualmente, con ctrl+arrastrar entre el campo y el SecundarioViewController , en el assistant editor . Hacer que el texto cambie seg\u00fan el bot\u00f3n pulsado \u00b6 Lo primero es a\u00f1adir f\u00edsicamente los ficheros *.txt con los textos al proyecto para que se puedan cargar din\u00e1micamente por c\u00f3digo. Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona Add files to Pioneras . Selecciona los tres .txt , que se a\u00f1adir\u00e1n al proyecto Otra opci\u00f3n ser\u00eda a\u00f1adir los ficheros a la carpeta Assets.xcassets . Si quieres hacerlo as\u00ed, clica en esa carpeta y con el bot\u00f3n + de la parte inferior crea un nuevo asset de tipo Data Set . Por defecto se llama data . C\u00e1mbiale el nombre por lovelace y arrastra el archivo lovelace.txt . Repite la misma operaci\u00f3n de crear asset , cambiar nombre y arrastrar archivo para las otras dos \"pioneras\". Para que le podamos decir al controlador secundario qu\u00e9 fichero tiene que abrir, debes crear una propiedad en el SecundarioViewController llamada nomFich de tipo String Para establecer una asociaci\u00f3n sencilla entre cada segue y los datos a mostrar puedes usar el identificador del segue . Haz clic sobre \u00e9l y en el Attributes inspector cambia su identifier , respectivamente por lovelace , hopper y liskov ahora en la clase ViewController , que es el controlador de la pantalla principal, puedes implementar el prepare(for:,sender:) override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { //obtenemos el controller destino y forzamos la conversi\u00f3n al tipo adecuado let controller = segue . destination as ! SecundarioViewController //fijamosla propiedad \"nomFich\" al identificador del segue controller . nomFich = segue . identifier } Finalmente, en el viewDidLoad() del SecundarioViewController puedes acceder a la propiedad self.nomFich , cargar el texto del fichero y mostrarlo en el campo de texto. Tendr\u00e1s que escribir el c\u00f3digo t\u00fa mismo . Si no has usado el assets.xcassets puedes hacer esto: Primero usar Bundle.main.path(forResource:, ofType:) , que devuelve la trayectoria completa para acceder a un recurso incluido en el proyecto sabiendo su nombre y su tipo (en el tipo pon solo \u201ctxt\u201d, sin el punto). Una vez obtenida la trayectoria, puedes leer el contenido del archivo como una cadena con el constructor de String(contentsOfFile:,encoding:) . Donde el primer par\u00e1metro es la trayectoria y el segundo el juego de caracteres (en nuestro caso el valor enumerado String.Encoding.utf8 ). CUIDADO, este m\u00e9todo est\u00e1 marcado con throws , as\u00ed que tendr\u00e1s que actuar en consecuencia. (usar do..catch o cualquier otra alternativa que veas razonable) Si has usado el assets.xcassets puedes cargar los datos como sigue: //CAMBIA nombre_del_asset por el que proceda var texto = \"\" if let data = NSDataAsset ( name : \"nombre_del_asset\" )?. data { texto = String ( data : data , encoding : . utf8 ) }","title":"Ejercicio de *view controllers* (1,25 puntos)"},{"location":"1_controllers/ejercicios/#ejercicio-de-view-controllers-125-puntos","text":"Vamos a hacer una aplicaci\u00f3n que vamos a llamar \u201cPioneras\u201d, y que nos dar\u00e1 datos de algunas mujeres pioneras de la inform\u00e1tica. La aplicaci\u00f3n tendr\u00e1 una pantalla principal en la que aparecer\u00e1n sus im\u00e1genes, y haciendo tap sobre cada una podremos ir a las pantallas secundarias donde se nos dar\u00e1 m\u00e1s informaci\u00f3n. Al crear el proyecto asegur\u00e1os de estar usando git ya que habr\u00e1 que guardar y marcar el estado con un commit especial en un momento intermedio. No es necesario subir el repositorio a Github, con tenerlo en local nos valdr\u00eda","title":"Ejercicio de view controllers (1,25 puntos)"},{"location":"1_controllers/ejercicios/#realizar-la-estructura-basica-de-la-aplicacion-05-puntos","text":"En este archivo tenemos las im\u00e1genes de las tres pioneras: Ada Lovelace, Grace Hopper y Barbara Liskov, que como siempre arrastraremos al Assets.xcassets . Tambi\u00e9n tenemos los textos sobre ellas que se mostrar\u00e1n en las pantallas secundarias. Crea tres botones en la pantalla principal, y para cada uno de ellos en lugar de texto vamos a usar como imagen de fondo la de cada mujer. Al final cada bot\u00f3n deber\u00eda ocupar todo el ancho de la pantalla y m\u00e1s o menos un tercio del alto. Importante: no es necesario que la interfaz sea perfecta (todos los botones exactamente del mismo alto, etc). De hecho si la pruebas en un dispositivo de tama\u00f1o de pantalla distinto al que est\u00e1s usando ahora mismo en Xcode ver\u00e1s que se ve \u201cfatal\u201d. Para hacer que todos los botones tengan el mismo alto y que se adapten bien a la pantalla usaremos un mecanismo que todav\u00eda no hemos visto denominado autolayout . Por el momento vamos a ignorar este tema Arrastra un nuevo \u201cview controller\u201d al storyboard (una \u201cpantalla\u201d nueva), que ser\u00e1 el que aparezca cuando se pulse en el primero de los botones (el de Ada Lovelace). Inserta un campo de texto de varias l\u00edneas ( text view ) y copia en \u00e9l el contenido de lovelace.txt Ahora establece el segue entre las dos pantallas : haz Ctrl+Arrastrar desde el primero de los botones con la imagen de Ada Lovelace hasta la segunda pantalla. Ejecuta el proyecto para comprobar que funciona lo que has hecho, aunque todav\u00eda no puede volver atr\u00e1s desde la pantalla secundaria Implementa la opci\u00f3n de volver atr\u00e1s de la secundaria a la principal Crea un bot\u00f3n \u201catr\u00e1s\u201d en la pantalla secundaria y col\u00f3calo en la parte de arriba (para que no lo tape el teclado on-screen si aparece) En el controller destino crea un m\u00e9todo para que funcione el unwinding (no hace falta que haga nada, solo que exista) @IBAction func retornoDeSecundaria ( segue : UIStoryboardSegue ) { } Con Ctrl+Arrastrar conecta el bot\u00f3n \u201catr\u00e1s\u201d con el icono de \u201cExit\u201d de la parte superior del controller Ejecuta el proyecto y comprueba que puedes volver atr\u00e1s desde la pantalla secundaria 6. Repite lo que has hecho en el caso de Ada Lovelace para las otras dos mujeres, creando las pantallas secundarias y la navegaci\u00f3n adelante y atr\u00e1s. Asegur\u00e1os de guardar el estado actual del proyecto con un commit cuyo comentario sea \u201cversion 1\u201d.","title":"Realizar la estructura b\u00e1sica de la aplicaci\u00f3n (0,5 puntos)"},{"location":"1_controllers/ejercicios/#comunicar-un-controller-con-otro-075-punto","text":"Es un poco redundante tener tantas pantallas secundarias cuando en realidad lo \u00fanico que cambia es el texto a mostrar. Valdr\u00eda con una sola secundaria en la que cambi\u00e1ramos din\u00e1micamente dicho texto. Vamos a implementarlo as\u00ed. Ahora pod\u00e9is eliminar los segues y las pantallas secundarias, es mejor crearlos de nuevo.","title":"Comunicar un controller con otro (0,75 punto)"},{"location":"1_controllers/ejercicios/#crear-la-nueva-interfaz","text":"Crea de nuevo una pantalla secundaria con un campo de texto de varias l\u00edneas Con Ctrl+arrastrar podemos crear un segue desde cada uno de los botones hasta la pantalla. Habr\u00e1n tres segues que lleguen a la misma, no deber\u00eda ser problema. A\u00f1\u00e1dele a la pantalla el bot\u00f3n de \u201catr\u00e1s\u201d y con\u00e9ctalo con el icono de \u201cexit\u201d. El c\u00f3digo necesario para el unwinding (m\u00e9todo retornoDeSecundaria ) ya deber\u00eda estar en el ViewController Comprueba que la navegaci\u00f3n funciona correctamente yendo adelante y atr\u00e1s","title":"Crear la nueva interfaz"},{"location":"1_controllers/ejercicios/#crear-un-controlador-personalizado-para-la-pantalla-secundaria","text":"Si en la parte derecha de la pantalla miras el identity inspector ver\u00e1s que el controlador de la pantalla secundaria es un tipo propio de Cocoa, el UIViewController . Vamos a cambiarlo por uno propio Crea una nueva clase de Cocoa Touch, (File> New > File\u2026, plantilla \u201ccocoa touch class\u201d). En la segunda pantalla del asistente dale a la clase el nombre SecundarioViewController y haz que sea una subclase de UIViewController . Deja sin marcar la opci\u00f3n de crear el .XIB En el storyboard , selecciona el controller de la pantalla secundaria (es mejor que lo hagas pulsando en el primero de los iconos que aparecen en la parte superior) Una vez seleccionado, ve al identity inspector en el \u00e1rea de Utilities y en el apartado de Custom class selecciona como clase la que has creado, SecundarioViewController","title":"Crear un controlador personalizado para la pantalla secundaria"},{"location":"1_controllers/ejercicios/#anadirle-un-outlet-al-controlador-secundario","text":"Tienes que a\u00f1adir un outlet al campo de texto para que su contenido se pueda cambiar desde el controlador secundario. Hazlo como habitualmente, con ctrl+arrastrar entre el campo y el SecundarioViewController , en el assistant editor .","title":"A\u00f1adirle un outlet al controlador secundario"},{"location":"1_controllers/ejercicios/#hacer-que-el-texto-cambie-segun-el-boton-pulsado","text":"Lo primero es a\u00f1adir f\u00edsicamente los ficheros *.txt con los textos al proyecto para que se puedan cargar din\u00e1micamente por c\u00f3digo. Pulsa con el bot\u00f3n derecho sobre el proyecto y selecciona Add files to Pioneras . Selecciona los tres .txt , que se a\u00f1adir\u00e1n al proyecto Otra opci\u00f3n ser\u00eda a\u00f1adir los ficheros a la carpeta Assets.xcassets . Si quieres hacerlo as\u00ed, clica en esa carpeta y con el bot\u00f3n + de la parte inferior crea un nuevo asset de tipo Data Set . Por defecto se llama data . C\u00e1mbiale el nombre por lovelace y arrastra el archivo lovelace.txt . Repite la misma operaci\u00f3n de crear asset , cambiar nombre y arrastrar archivo para las otras dos \"pioneras\". Para que le podamos decir al controlador secundario qu\u00e9 fichero tiene que abrir, debes crear una propiedad en el SecundarioViewController llamada nomFich de tipo String Para establecer una asociaci\u00f3n sencilla entre cada segue y los datos a mostrar puedes usar el identificador del segue . Haz clic sobre \u00e9l y en el Attributes inspector cambia su identifier , respectivamente por lovelace , hopper y liskov ahora en la clase ViewController , que es el controlador de la pantalla principal, puedes implementar el prepare(for:,sender:) override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { //obtenemos el controller destino y forzamos la conversi\u00f3n al tipo adecuado let controller = segue . destination as ! SecundarioViewController //fijamosla propiedad \"nomFich\" al identificador del segue controller . nomFich = segue . identifier } Finalmente, en el viewDidLoad() del SecundarioViewController puedes acceder a la propiedad self.nomFich , cargar el texto del fichero y mostrarlo en el campo de texto. Tendr\u00e1s que escribir el c\u00f3digo t\u00fa mismo . Si no has usado el assets.xcassets puedes hacer esto: Primero usar Bundle.main.path(forResource:, ofType:) , que devuelve la trayectoria completa para acceder a un recurso incluido en el proyecto sabiendo su nombre y su tipo (en el tipo pon solo \u201ctxt\u201d, sin el punto). Una vez obtenida la trayectoria, puedes leer el contenido del archivo como una cadena con el constructor de String(contentsOfFile:,encoding:) . Donde el primer par\u00e1metro es la trayectoria y el segundo el juego de caracteres (en nuestro caso el valor enumerado String.Encoding.utf8 ). CUIDADO, este m\u00e9todo est\u00e1 marcado con throws , as\u00ed que tendr\u00e1s que actuar en consecuencia. (usar do..catch o cualquier otra alternativa que veas razonable) Si has usado el assets.xcassets puedes cargar los datos como sigue: //CAMBIA nombre_del_asset por el que proceda var texto = \"\" if let data = NSDataAsset ( name : \"nombre_del_asset\" )?. data { texto = String ( data : data , encoding : . utf8 ) }","title":"Hacer que el texto cambie seg\u00fan el bot\u00f3n pulsado"},{"location":"2_vistas/apuntes/","text":"Vistas \u00b6 Como ya hemos visto, todas las aplicaciones iOS que usan la librer\u00eda UIKit siguen el paradigma modelo/vista/controlador. En esta sesi\u00f3n vamos a ver las vistas, es decir, los componentes de interfaz de usuario de nuestra aplicaci\u00f3n. Primero veremos algunos de los componentes m\u00e1s usados de UIKit y luego c\u00f3mo gestionar las propiedades comunes a todos los componentes (tama\u00f1o, posici\u00f3n, etc) con c\u00f3digo Swift. Componentes de interfaz de usuario \u00b6 A lo largo de los ejemplos que hemos ido haciendo en las sesiones anteriores ya hemos probado unos cuantos de los controles b\u00e1sicos de interfaz de usuario que nos proporciona iOS: botones, etiquetas, im\u00e1genes, \u2026 Vamos a ver aqu\u00ed algunas de las caracter\u00edsticas de los controles, aunque solo vamos a dar unas pinceladas, ya que una descripci\u00f3n exhaustiva de cada propiedad ser\u00eda imposible y tediosa. Se os recomienda consultar la documentaci\u00f3n de Apple, en concreto hay dos tipos de documentaci\u00f3n que os pueden resultar \u00fatiles: Desde el punto de vista del dise\u00f1o y la usabilidad, la parte de las Human Interface Guidelines dedicada a los componentes de UI . Desde el punto de vista de desarrollo pod\u00e9is consultar el apartado \"views and controls\" de la documentaci\u00f3n de UIKit , con la referencia del API y la forma de usar cada componente en nuestro c\u00f3digo. Aunque aqu\u00ed hablemos de controles indistintamente para referirnos a las etiquetas, botones, \u2026 en realidad este t\u00e9rmino tiene un significado m\u00e1s preciso en iOS. La clase UIControl es de la que heredan los controles m\u00e1s \u201cinteractivos\u201d como los botones, mientras que las etiquetas lo hacen de UIView (no obstante todos los UIControl son tambi\u00e9n vistas ya que a su vez esta clase hereda de UIView ). Campos de texto \u00b6 Un campo de texto nos proporciona un espacio donde el usuario puede introducir y editar texto. Se define en la clase UITextField , y pertenece a un grupo de vistas denominados controles, junto a otros componentes como por ejemplo los botones. Esto es as\u00ed porque permiten al usuario interactuar con la aplicaci\u00f3n. No heredan directamente de UIView , sino de su subclase UIControl , que incorpora los m\u00e9todos para tratar eventos de la interfaz mediante el patr\u00f3n target-action como hemos visto anteriormente. target-action es el nombre gen\u00e9rico que se da en iOS a la idea de vincular un componente de UI con un manejador de evento. Ya hemos visto c\u00f3mo se hace en Xcode (arrastrar+Ctrl desde el componente en el storyboard hasta el c\u00f3digo del controller ). Tambi\u00e9n se puede hacer en c\u00f3digo Swift, aunque no lo veremos aqu\u00ed. Sus propiedades se pueden encontrar en la secci\u00f3n Text Field del inspector de atributos. Podremos especificar un texto por defecto ( Text ), o bien un texto a mostrar sombreado en caso de que el usuario no haya introducido nada ( Placeholder Text ). Esto ser\u00e1 \u00fatil por ejemplo para dar una pista al usuario sobre lo que debe introducir en dicho campo. Si nos fijamos en el inspector de conexiones del campos de texto, veremos la lista de eventos que podemos conectar a nuestras acciones. Esta lista de eventos es com\u00fan para cualquier control. En el caso de un campo de texto por ejemplo nos puede interesar el evento Value Changed . Teclado en pantalla \u00b6 Cuando un campo de texto adquiere el foco porque el usuario hace tap sobre \u00e9l, autom\u00e1ticamente aparece el teclado software on screen . El problema es que no desaparece por defecto. Tenemos que quitarlo de pantalla con c\u00f3digo Swift. En concreto, tenemos que escribir un action que responda al evento Did end on exit del campo de texto. Cuando crees el action indica en el men\u00fa popup que el type debe ser UITextField . Esta opci\u00f3n es el par\u00e1metro que se le pasar\u00e1 al action y representa el objeto que ha disparado el evento, en nuestro caso el campo de texto. Si lo pasamos como AnyObject no tendremos acceso a los m\u00e9todos del API de UITextField (salvo que hici\u00e9ramos una conversi\u00f3n con as ) En teor\u00eda dentro de este action debemos hacer que el campo deje de ser el objeto que hace de first responder para que el teclado deje de mostrarse El first responder es el objeto que recibe en primer lugar ciertas clases de eventos, por ejemplo los de teclado o movimiento. Cuando hacemos tap sobre un campo de texto, iOS hace que este pase a ser el first responder , y esto es lo que hace que autom\u00e1ticamente aparezca el teclado onscreen . @IBAction func introPulsado ( _ sender : UITextField ) { sender . resignFirstResponder () } Aunque en muchas fuentes (libros, tutoriales en web, \u2026) aparece el m\u00e9todo del resignFirstResponder , curiosamente parece bastar con tener un action que responda al Did end on exit , aunque no haga nada para ocultar el teclado.* Por desgracia, no todos los tipos de teclado en pantalla tienen un bot\u00f3n de \u201cintro\u201d y por tanto no disparan el evento Did end on exit , por ejemplo el teclado num\u00e9rico no lo hace. En ese caso hay que usar una soluci\u00f3n algo m\u00e1s rebuscada. Por ejemplo, es muy t\u00edpico que al pulsar sobre cualquier parte de la pantalla que no sea el campo el teclado se oculte. Esto podemos conseguirlo detectando el evento de toque sobre la vista. Si un evento no se procesa en los componentes de la vista va \u201csubiendo\u201d en la jerarqu\u00eda hasta llegar al view controller , por lo que en \u00e9l podr\u00edamos hacer esto (no es necesario crear un action , ya que el evento no va a ir directamente al controller , solo escribir el c\u00f3digo): override func touchesEnded ( _ touches : Set < UITouch >, with : UIEvent ?) { print ( \"\u00a1touch en la pantalla!\" ) //Necesitamos un outlet para acceder al campo de texto. //Aqu\u00ed suponemos que lo hemos llamado \"campoDeTexto\" self . campoDeTexto . resignFirstResponder () } Botones \u00b6 Al igual que los campos de texto, los botones son otro tipo de control (heredan de UIControl ). Se definen en la clase UIButton , que puede ser inicializada de la misma forma que el resto de vistas. Si nos fijamos en el inspector de atributos de un bot\u00f3n (en la secci\u00f3n Button ), vemos que podemos elegir el tipo de bot\u00f3n (atributo Type ). Podemos seleccionar una serie de estilos prefedinidos para los botones, o bien darle un estilo propio ( Custom ). El texto que aparece en el bot\u00f3n se especifica en la propiedad Title , y podemos configurar tambi\u00e9n su color, sombreado, o a\u00f1adir una imagen como icono. En el inspector de conexiones, el evento que utilizaremos m\u00e1s com\u00fanmente en los botones es Touch Up Inside , que se producir\u00e1 cuando levantemos el dedo tras pulsar dentro del bot\u00f3n. Este ser\u00e1 el momento en el que se realizar\u00e1 la acci\u00f3n asociada al bot\u00f3n. Alertas y action sheets \u00b6 Son cuadros de di\u00e1logo modales que se usan para informar al usuario de eventos importantes. No se crean gr\u00e1ficamente en Xcode sino por c\u00f3digo Pueden simplemente informar de algo o adem\u00e1s pedir al usuario que elija uno entre varios cursos de acci\u00f3n. Vamos a ver primero c\u00f3mo crear una alerta . En realidad el API para alertas y action sheets es el mismo, solo se diferencian en una constante que se le pasa al inicializador. Luego veremos las diferencias en cuanto a su significado de cara al usuario. Por ejemplo veamos c\u00f3mo se mostrar\u00eda una alerta con dos opciones //El alert en s\u00ed. Vemos que el preferredStyle es .alert let alert = UIAlertController ( title : \"\u00a1Elige!\" , message : \"Tienes que elegir uno de estos dos\" , preferredStyle : . alert ) //cada opci\u00f3n es un UIAlertAction let susto = UIAlertAction ( title : \"Susto\" , style : . cancel ) { action in print ( \"BU!!! haber elegido muerte!\" ) } let muerte = UIAlertAction ( title : \"Muerte\" , style : . default ) { action in print ( \"Aqu\u00ed se acaba todo\" ) } //A\u00f1adimos las opciones al cuadro de di\u00e1logo alert . addAction ( susto ) alert . addAction ( muerte ) //Mostramos el alert con present, como se hace con cualquier controller self . present ( alert , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del alert\" ) } Podemos tener el n\u00famero de botones que queramos. No obstante, las \u201ciOS Human Interface Guidelines\u201d recomiendan como m\u00e1ximo dos , y en caso que necesitemos m\u00e1s usar un \u201cAction Sheet\u201d . Por otro lado un action sheet es un cuadro de di\u00e1logo que se usa para dar alternativas al usuario cuando ha realizado una acci\u00f3n. Por ejemplo supongamos un gestor de email en el que el usuario ha hecho tap sobre un mensaje. Podr\u00eda aparecer la siguiente action sheet El API es exactamente el mismo, solo que en el inicializador de UIAlertController se pasa como par\u00e1metro preferredStyle el valor actionSheet . let actionSheet = UIAlertController ( title : \"Opciones\" , message : \"Seleccione la opci\u00f3n\" , preferredStyle : . actionSheet ) let archivar = UIAlertAction ( title : \"Archivar\" , style : . default ){ action in print ( \"Aqu\u00ed se archivar\u00eda el mensaje\" ) } let eliminar = UIAlertAction ( title : \"Eliminar\" , style : . destructive ) { action in print ( \"Aqu\u00ed se eliminar\u00eda el mensaje\" ) } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in print ( \"Aqu\u00ed no se har\u00eda nada\" ) } actionSheet . addAction ( archivar ) actionSheet . addAction ( eliminar ) actionSheet . addAction ( cancelar ) self . present ( actionSheet , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del action sheet\" ) } Pickers \u00b6 Nos permiten elegir uno de entre una lista de valores, usando la met\u00e1fora visual de la t\u00edpica rueda que se gira para seleccionar el valor deseado. En el API se corresponden con la clase UIPickerView . En Xcode, el componente a arrastrar al storyboard es el \"Picker View\" Comparados con la mayor\u00eda de los otros controles son bastante m\u00e1s complejos, ya que un picker necesita de la ayuda de dos delegates (dos objetos que sean conformes a ciertos protocolos): Un delegate (protocolo UIPickerViewDelegate ): gestiona el comportamiento general del picker Un datasource (protocolo UIPickerViewDataSource ): gestiona el \"modelo de datos\": cu\u00e1ntas filas y columnas tiene Estos dos protocolos heredan de NSObjectProtocol , con lo que los objetos conformes a ellos deben ser conformes tambi\u00e9n a este \u00faltimo (esto se puede conseguir de modo sencillo haciendo que la clase herede de NSObject , ya que esta clase es conforme a este protocolo). Por ejemplo supongamos una clase GestorPicker que para hacer el c\u00f3digo m\u00e1s compacto va a hacer tanto de delegate como de datasource : import UIKit class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] //METODOS DE UIPickerViewDatasource //n\u00famero de \"columnas\" del Picker func numberOfComponents ( in pickerView : UIPickerView ) -> Int { return 1 } //n\u00famero de \"filas\" func pickerView ( _ pickerView : UIPickerView , numberOfRowsInComponent component : Int ) -> Int { return lista . count } //METODOS DE UIPickerViewDelegate func pickerView ( _ pickerView : UIPickerView , titleForRow row : Int , forComponent component : Int ) -> String ? { return lista [ row ] } } En el view controller de la pantalla con el picker definir\u00edamos una instancia de GestorPicker let gestorPicker = GestorPicker () Crear\u00edamos un outlet que represente al picker con Ctrl+Arrastrar, que generar\u00eda algo as\u00ed en el c\u00f3digo @IBOutlet weak var miPicker : UIPickerView ! Y finalmente dentro del viewDidLoad \"enlazar\u00edamos\" el picker con su datasource y su delegate asign\u00e1ndolos a sus propiedades del mismo nombre. Recordemos que datasource y delegate en este caso son el mismo objeto. self . miPicker . delegate = self . gestorPicker self . miPicker . dataSource = self . gestorPicker Los m\u00e9todos anteriores nos permiten pintar el picker , pero adem\u00e1s nos interesar\u00e1 saber qu\u00e9 opci\u00f3n est\u00e1 seleccionada. En cualquier momento podemos obtener el n\u00famero de fila seleccionado en el picker con //Cambiar el 0 por la \"columna\" que queramos self . miPicker . selectedRow ( inComponent : 0 ) Adem\u00e1s si nos interesa podemos ser avisados en el momento en que el usuario seleccione una opci\u00f3n. Cuando se produzca ese evento, el objeto que act\u00fae de delegate del picker recibir\u00e1 una llamada a su m\u00e9todo pickerView(_:,didSelectRow:,inComponent:) : class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] ... func pickerView ( _ pickerView : UIPickerView , didSelectRow row : Int , inComponent component : Int ) { print ( \"Seleccionada fila: \\( row ) , dato: \\( lista [ row ] ) \" ) } ... } Otros controles ( sliders , switches , date pickers ) \u00b6 Estos controles son muy heterog\u00e9neos, pero todos tienen en com\u00fan que tienen un valor asociado y que este valor puede cambiar debido a las acciones del usuario. El tipo del valor y la(s) propiedade(s) para acceder a \u00e9l ser\u00e1n muy distintas seg\u00fan el tipo de control, por ejemplo: Un UISwitch es booleano y se sabe si est\u00e1 a \"on\" con isOn Un UISlider tiene un valor Float y se accede a \u00e9l con la propiedad value Un UIDatePicker tiene una fecha y se accede a ella con la propiedad date Pero en todos se usa la misma idea, implementar un action vinculado al evento de cambio del valor de modo que en su c\u00f3digo podamos acceder al valor actual. Por ejemplo para un slider tendr\u00edamos algo como //Este m\u00e9todo se ha creado con el \"assistant editor\" y Ctrl+Arrastrar //de la ventana del storyboard al editor con el c\u00f3digo del view controller //Elegimos Connection \"action\" y type \"UISlider\" @IBAction func cambiaSlider ( _ sender : UISlider ) { print ( \"El valor es: \\( sender . value ) \" ) } Es importante que al crear el action , si lo hacemos gr\u00e1ficamente con Ctrl+Arrastrar, en el popup de opciones elijamos como tipo UISlider (o en general, el tipo del control en cuesti\u00f3n). As\u00ed el par\u00e1metro sender que representa el objeto que ha generado el evento tendr\u00e1 el tipo adecuado y no necesitaremos hacer un cast para acceder a la propiedad deseada, como pasar\u00eda si lo dejamos con tipo Any . Vistas en Swift \u00b6 En la asignatura de Tecnolog\u00edas de Desarrollo hemos creado componentes de interfaz de usuario (vistas) arrastr\u00e1ndolos al storyboard . Vamos a ver aqu\u00ed c\u00f3mo crearlos desde Swift y cambiar sus propiedades, que son las mismas que tenemos en Xcode. Las vistas y el controller \u00b6 Cada vista est\u00e1 \u00edntimamente ligadas a un determinado controller . Podemos decir que un controller \"posee\" directamente una determinada vista, que es su vista principal, y esta a su vez puede contener subvistas. Toda esta jerarqu\u00eda de vistas forman lo que el usuario percibe como una \"pantalla\" de nuestra app . La vista \"principal\" de un controller es su propiedad view . El sitio indicado para manipular esta view es el m\u00e9todo viewDidLoad del controller en cuesti\u00f3n. Este m\u00e9todo se ejecuta una vez se ha cargado la vista y por tanto ya se han inicializado todos los componentes que hemos creado visualmente desde Xcode. En la plantilla creada por Xcode veremos que este m\u00e9todo llama al de la clase base, al final del m\u00e9todo podemos a\u00f1adir nuestro c\u00f3digo, por ejemplo para cambiar el color de fondo: override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. //aqu\u00ed \"view\" ya estar\u00e1 inicializada, podemos cambiar sus propiedades self . view . backgroundColor = UIColor . green } Otra opci\u00f3n es sobreescribir el m\u00e9todo loadView() del controller , a diferencia del anterior, si existe este m\u00e9todo se convierte en el responsable de cargar la vista principal, y se ignorar\u00e1 por tanto todo lo que se haya definido visualmente en el storyboard . override func loadView () { //Somos responsables de crear \"view\". //Aqu\u00ed le damos el tama\u00f1o de la pantalla del dispositivo //En un momento detallaremos el uso de la propiedad \"frame\" self . view = UIView ( frame : UIScreen . main . bounds ) self . view . backgroundColor = UIColor . green } Jerarqu\u00eda de vistas \u00b6 Las vistas nos proporcionan una serie de m\u00e9todos para consultar y modificar la jerarqu\u00eda. El m\u00e9todo b\u00e1sico que necesitaremos es addSubview , que nos permitir\u00e1 a\u00f1adir una subvista a una vista determinada, que se convertir\u00e1 en su vista \"madre\" o supervista : var label = UILabel () label . text = \"Soy una etiqueta\" //suponiendo que \"vista\" ya est\u00e9 definida, ahora ser\u00e1 la supervista de \"label\" vista . addSubView ( label ) Podemos eliminar una vista llamando a su m\u00e9todo removeFromSuperview() . Podemos tambi\u00e9n consultar la jerarqu\u00eda con los siguientes m\u00e9todos: superview : Nos da la vista padre de la vista destinataria del mensaje. subviews : Nos da la lista de subvistas de una vista dada. isDescendantOfView: Comprueba si una vista es descendiente de otra. Como vemos, una vista tiene una lista de vistas hijas. Cada vista hija tiene un \u00edndice, que determinar\u00e1 el orden en el que se dibujan. El \u00edndice 0 es el m\u00e1s cercano al observador, y por lo tanto tapar\u00e1 a los \u00edndices superiores. Podemos insertar una vista en un \u00edndice determinado de la lista de subvistas con insertSubview(_:,at:) . Puede que tengamos una jerarqu\u00eda compleja y necesitemos acceder desde el c\u00f3digo a una determinada vista por ejemplo para inicializar su valor. Una opci\u00f3n es hacer un outlet para cada vista que queramos modificar, pero esto podr\u00eda sobrecargar nuestro objeto de outlets . Tambi\u00e9n puede ser complejo y poco fiable el buscar la vista en la jerarqu\u00eda. En estos casos, lo m\u00e1s sencillo es darle a las vistas que buscamos una etiqueta ( tag ) mediante la propiedad Tag del inspector de atributos (debe ser un valor entero), o asignando la propiedad tag de forma program\u00e1tica. Podremos localizar en nuestro c\u00f3digo una vista a partir de su etiqueta mediante viewWithTag . Llamando a este m\u00e9todo sobre una vista, buscar\u00e1 entre todas las subvistas aquella con la etiqueta indicada: texto = self . window . viewWithTag ( tag : 1 ) La jerarqu\u00eda de vistas de una pantalla determinada de nuestra aplicaci\u00f3n puede llegar a ser muy compleja. Es por eso que en Xcode hay una opci\u00f3n que nos permite mostrar un \u201cdespiece\u201d visual en 3D de las vistas que componen la pantalla actual. Dicha opci\u00f3n est\u00e1 disponible en Debug > View Debugging .En modo texto podemos usar la propiedad recursiveDescription para imprimir la descripci\u00f3n textual de las vistas que contiene una vista dada. Propiedades de una vista \u00b6 A continuaci\u00f3n vamos a repasar las propiedades b\u00e1sicas de las vistas, que podremos modificar tanto desde Xcode como de forma program\u00e1tica. Disposici\u00f3n \u00b6 Entre las propiedades m\u00e1s importantes en las vistas encontramos aquellas referentes a su disposici\u00f3n en pantalla. Hemos visto que tanto cuando creamos la vista con Xcode como cuando la inicializamos de forma program\u00e1tica hay que especificar el marco ( frame ) que ocupar\u00e1 la vista en la pantalla. Cuando se crea de forma visual, el marco se puede definir pulsando con el rat\u00f3n sobre los m\u00e1rgenes de la vista y arrastrando para as\u00ed mover sus l\u00edmites. En el c\u00f3digo estos l\u00edmites se especifican mediante el tipo CGRect , en el que se especifica posici\u00f3n (x,y) de inicio, y el ancho y el alto que ocupa la vista. Estos datos se especifican en el sistema de coordenadas de la supervista. var vista = UIView ( frame : CGRect ( x : 0 , y : 0 , width : 100 , height : 100 )) El sistema de coordenadas tiene su origen en la esquina superior izquierda. Las coordenadas no se dan en pixels , sino en puntos , una medida que nos permite independizarnos de la resoluci\u00f3n en pixels de la pantalla. Las coordenadas en puntos son reales, no enteras. Pod\u00e9is consultar una tabla muy completa con muchos m\u00e1s datos. Otros frameworks de iOS definen sistemas de coordenadas distintos. Los de gr\u00e1ficos (Core Graphics y OpenGL ES) ponen el origen en la esquina inferior izquierda con el eje Y apuntando hacia arriba. Algunos ejemplos de c\u00f3mo obtener la posici\u00f3n y dimensiones de una vista: // Limites en coordenadas locales // Su origen siempre es (0,0) CGRect areaLocal = vista . bounds // Posici\u00f3n del centro de la vista en coordenadas de su supervista CGPoint centro = vista . center // Marco en coordenadas de la supervista CGRect marco = vista . frame N\u00f3tese que a partir de bounds y center podemos calcular frame , aunque nos lo da directamente el sistema Aqu\u00ed estamos usando tama\u00f1os fijos para las coordenadas de CGRect . Sin embargo, en la mayor\u00eda de ocasiones nos interesa que el tama\u00f1o de las vistas no sea fijo sino que se adapte al \u00e1rea disponible. De esta forma nuestra interfaz podr\u00eda adaptarse de forma sencilla a distintas orientaciones del dispositivo (horizontal o vertical) o a distintas resoluciones de la pantalla. Esto lo podemos conseguir mediante el uso del autolayout , que calcula de manera autom\u00e1tica el frame de cada vista bas\u00e1ndose en un conjunto de restricciones. Veremos esta tecnolog\u00eda en sesiones posteriores. Transformaciones \u00b6 Podemos tambi\u00e9n aplicar una transformaci\u00f3n a las vistas, mediante su propiedad transform . Por defecto las vistas tienen aplicada la transformaci\u00f3n identidad CGAffineTransform.identity . La transformaci\u00f3n se define mediante una matriz de transformaci\u00f3n 2D de dimensi\u00f3n 3x3. Podemos crear transformaciones sencillas (rotaciones, traslaciones o escalados \u201cpuros\u201d con las funciones CGAffineTransform(rotationAngle:) , CGAffineTransform(translationX:,y:) y CGAffineTransform(scaleX:,y:) . Si nuestra vista tiene aplicada una transformaci\u00f3n diferente a la identidad, su propiedad frame no ser\u00e1 significativa. En este caso s\u00f3lo deberemos utilizar center y bounds . Otras propiedades \u00b6 En las vistas encontramos otras propiedades que nos permiten determinar su color o su opacidad. En primer lugar tenemos backgroundColor , con la que podemos fijar el color de fondo de una vista. En el inspector de atributos (secci\u00f3n View ) podemos verlo como propiedad Background . El color de fondo puede ser transparente, o puede utilizarse como fondo un determinado patr\u00f3n basado en una imagen. De forma program\u00e1tica, el color se especifica mediante un objeto de clase UIColor . En esta clase podemos crear un color personalizado a partir de sus componentes (rojo, verde, azul, alpha), como en UIColor(red:,green:,blue:,alpha:) o con una constante predefinida (por ejemplo, UIColor.green ) Por otro lado, tambi\u00e9n podemos hacer que una vista tenga un cierto grado de transparencia, o est\u00e9 oculta. A diferencia de backgroundColor , que s\u00f3lo afecta al fondo de la vista, con la propiedad alpha , de tipo CGFloat , podemos controlar el nivel de transparencia de la vista completa con todo su contenido y sus subvistas. Si una vista no tiene transparencia, podemos poner su propiedad opaque a true para as\u00ed optimizar la forma de dibujarla. Esta propiedad s\u00f3lo debe establecerse a true si la vista llena todo su contendo y no deja ver nada del fondo. De no ser as\u00ed, el resultado es impredecible. Debemos llevar cuidado con esto, ya que por defecto dicha propiedad es true . Por \u00faltimo, tambi\u00e9n podemos ocultar una vista con la propiedad isHidden . Cuando hagamos que una vista se oculte, aunque seguir\u00e1 ocupando su correspondiente espacio en pantalla, no ser\u00e1 visible ni recibir\u00e1 eventos.","title":"Vistas"},{"location":"2_vistas/apuntes/#vistas","text":"Como ya hemos visto, todas las aplicaciones iOS que usan la librer\u00eda UIKit siguen el paradigma modelo/vista/controlador. En esta sesi\u00f3n vamos a ver las vistas, es decir, los componentes de interfaz de usuario de nuestra aplicaci\u00f3n. Primero veremos algunos de los componentes m\u00e1s usados de UIKit y luego c\u00f3mo gestionar las propiedades comunes a todos los componentes (tama\u00f1o, posici\u00f3n, etc) con c\u00f3digo Swift.","title":"Vistas"},{"location":"2_vistas/apuntes/#componentes-de-interfaz-de-usuario","text":"A lo largo de los ejemplos que hemos ido haciendo en las sesiones anteriores ya hemos probado unos cuantos de los controles b\u00e1sicos de interfaz de usuario que nos proporciona iOS: botones, etiquetas, im\u00e1genes, \u2026 Vamos a ver aqu\u00ed algunas de las caracter\u00edsticas de los controles, aunque solo vamos a dar unas pinceladas, ya que una descripci\u00f3n exhaustiva de cada propiedad ser\u00eda imposible y tediosa. Se os recomienda consultar la documentaci\u00f3n de Apple, en concreto hay dos tipos de documentaci\u00f3n que os pueden resultar \u00fatiles: Desde el punto de vista del dise\u00f1o y la usabilidad, la parte de las Human Interface Guidelines dedicada a los componentes de UI . Desde el punto de vista de desarrollo pod\u00e9is consultar el apartado \"views and controls\" de la documentaci\u00f3n de UIKit , con la referencia del API y la forma de usar cada componente en nuestro c\u00f3digo. Aunque aqu\u00ed hablemos de controles indistintamente para referirnos a las etiquetas, botones, \u2026 en realidad este t\u00e9rmino tiene un significado m\u00e1s preciso en iOS. La clase UIControl es de la que heredan los controles m\u00e1s \u201cinteractivos\u201d como los botones, mientras que las etiquetas lo hacen de UIView (no obstante todos los UIControl son tambi\u00e9n vistas ya que a su vez esta clase hereda de UIView ).","title":"Componentes de interfaz de usuario"},{"location":"2_vistas/apuntes/#campos-de-texto","text":"Un campo de texto nos proporciona un espacio donde el usuario puede introducir y editar texto. Se define en la clase UITextField , y pertenece a un grupo de vistas denominados controles, junto a otros componentes como por ejemplo los botones. Esto es as\u00ed porque permiten al usuario interactuar con la aplicaci\u00f3n. No heredan directamente de UIView , sino de su subclase UIControl , que incorpora los m\u00e9todos para tratar eventos de la interfaz mediante el patr\u00f3n target-action como hemos visto anteriormente. target-action es el nombre gen\u00e9rico que se da en iOS a la idea de vincular un componente de UI con un manejador de evento. Ya hemos visto c\u00f3mo se hace en Xcode (arrastrar+Ctrl desde el componente en el storyboard hasta el c\u00f3digo del controller ). Tambi\u00e9n se puede hacer en c\u00f3digo Swift, aunque no lo veremos aqu\u00ed. Sus propiedades se pueden encontrar en la secci\u00f3n Text Field del inspector de atributos. Podremos especificar un texto por defecto ( Text ), o bien un texto a mostrar sombreado en caso de que el usuario no haya introducido nada ( Placeholder Text ). Esto ser\u00e1 \u00fatil por ejemplo para dar una pista al usuario sobre lo que debe introducir en dicho campo. Si nos fijamos en el inspector de conexiones del campos de texto, veremos la lista de eventos que podemos conectar a nuestras acciones. Esta lista de eventos es com\u00fan para cualquier control. En el caso de un campo de texto por ejemplo nos puede interesar el evento Value Changed .","title":"Campos de texto"},{"location":"2_vistas/apuntes/#botones","text":"Al igual que los campos de texto, los botones son otro tipo de control (heredan de UIControl ). Se definen en la clase UIButton , que puede ser inicializada de la misma forma que el resto de vistas. Si nos fijamos en el inspector de atributos de un bot\u00f3n (en la secci\u00f3n Button ), vemos que podemos elegir el tipo de bot\u00f3n (atributo Type ). Podemos seleccionar una serie de estilos prefedinidos para los botones, o bien darle un estilo propio ( Custom ). El texto que aparece en el bot\u00f3n se especifica en la propiedad Title , y podemos configurar tambi\u00e9n su color, sombreado, o a\u00f1adir una imagen como icono. En el inspector de conexiones, el evento que utilizaremos m\u00e1s com\u00fanmente en los botones es Touch Up Inside , que se producir\u00e1 cuando levantemos el dedo tras pulsar dentro del bot\u00f3n. Este ser\u00e1 el momento en el que se realizar\u00e1 la acci\u00f3n asociada al bot\u00f3n.","title":"Botones"},{"location":"2_vistas/apuntes/#alertas-y-action-sheets","text":"Son cuadros de di\u00e1logo modales que se usan para informar al usuario de eventos importantes. No se crean gr\u00e1ficamente en Xcode sino por c\u00f3digo Pueden simplemente informar de algo o adem\u00e1s pedir al usuario que elija uno entre varios cursos de acci\u00f3n. Vamos a ver primero c\u00f3mo crear una alerta . En realidad el API para alertas y action sheets es el mismo, solo se diferencian en una constante que se le pasa al inicializador. Luego veremos las diferencias en cuanto a su significado de cara al usuario. Por ejemplo veamos c\u00f3mo se mostrar\u00eda una alerta con dos opciones //El alert en s\u00ed. Vemos que el preferredStyle es .alert let alert = UIAlertController ( title : \"\u00a1Elige!\" , message : \"Tienes que elegir uno de estos dos\" , preferredStyle : . alert ) //cada opci\u00f3n es un UIAlertAction let susto = UIAlertAction ( title : \"Susto\" , style : . cancel ) { action in print ( \"BU!!! haber elegido muerte!\" ) } let muerte = UIAlertAction ( title : \"Muerte\" , style : . default ) { action in print ( \"Aqu\u00ed se acaba todo\" ) } //A\u00f1adimos las opciones al cuadro de di\u00e1logo alert . addAction ( susto ) alert . addAction ( muerte ) //Mostramos el alert con present, como se hace con cualquier controller self . present ( alert , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del alert\" ) } Podemos tener el n\u00famero de botones que queramos. No obstante, las \u201ciOS Human Interface Guidelines\u201d recomiendan como m\u00e1ximo dos , y en caso que necesitemos m\u00e1s usar un \u201cAction Sheet\u201d . Por otro lado un action sheet es un cuadro de di\u00e1logo que se usa para dar alternativas al usuario cuando ha realizado una acci\u00f3n. Por ejemplo supongamos un gestor de email en el que el usuario ha hecho tap sobre un mensaje. Podr\u00eda aparecer la siguiente action sheet El API es exactamente el mismo, solo que en el inicializador de UIAlertController se pasa como par\u00e1metro preferredStyle el valor actionSheet . let actionSheet = UIAlertController ( title : \"Opciones\" , message : \"Seleccione la opci\u00f3n\" , preferredStyle : . actionSheet ) let archivar = UIAlertAction ( title : \"Archivar\" , style : . default ){ action in print ( \"Aqu\u00ed se archivar\u00eda el mensaje\" ) } let eliminar = UIAlertAction ( title : \"Eliminar\" , style : . destructive ) { action in print ( \"Aqu\u00ed se eliminar\u00eda el mensaje\" ) } let cancelar = UIAlertAction ( title : \"Cancelar\" , style : . cancel ) { action in print ( \"Aqu\u00ed no se har\u00eda nada\" ) } actionSheet . addAction ( archivar ) actionSheet . addAction ( eliminar ) actionSheet . addAction ( cancelar ) self . present ( actionSheet , animated : true ) { print ( \"Ha acabado la animaci\u00f3n del action sheet\" ) }","title":"Alertas y action sheets"},{"location":"2_vistas/apuntes/#pickers","text":"Nos permiten elegir uno de entre una lista de valores, usando la met\u00e1fora visual de la t\u00edpica rueda que se gira para seleccionar el valor deseado. En el API se corresponden con la clase UIPickerView . En Xcode, el componente a arrastrar al storyboard es el \"Picker View\" Comparados con la mayor\u00eda de los otros controles son bastante m\u00e1s complejos, ya que un picker necesita de la ayuda de dos delegates (dos objetos que sean conformes a ciertos protocolos): Un delegate (protocolo UIPickerViewDelegate ): gestiona el comportamiento general del picker Un datasource (protocolo UIPickerViewDataSource ): gestiona el \"modelo de datos\": cu\u00e1ntas filas y columnas tiene Estos dos protocolos heredan de NSObjectProtocol , con lo que los objetos conformes a ellos deben ser conformes tambi\u00e9n a este \u00faltimo (esto se puede conseguir de modo sencillo haciendo que la clase herede de NSObject , ya que esta clase es conforme a este protocolo). Por ejemplo supongamos una clase GestorPicker que para hacer el c\u00f3digo m\u00e1s compacto va a hacer tanto de delegate como de datasource : import UIKit class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] //METODOS DE UIPickerViewDatasource //n\u00famero de \"columnas\" del Picker func numberOfComponents ( in pickerView : UIPickerView ) -> Int { return 1 } //n\u00famero de \"filas\" func pickerView ( _ pickerView : UIPickerView , numberOfRowsInComponent component : Int ) -> Int { return lista . count } //METODOS DE UIPickerViewDelegate func pickerView ( _ pickerView : UIPickerView , titleForRow row : Int , forComponent component : Int ) -> String ? { return lista [ row ] } } En el view controller de la pantalla con el picker definir\u00edamos una instancia de GestorPicker let gestorPicker = GestorPicker () Crear\u00edamos un outlet que represente al picker con Ctrl+Arrastrar, que generar\u00eda algo as\u00ed en el c\u00f3digo @IBOutlet weak var miPicker : UIPickerView ! Y finalmente dentro del viewDidLoad \"enlazar\u00edamos\" el picker con su datasource y su delegate asign\u00e1ndolos a sus propiedades del mismo nombre. Recordemos que datasource y delegate en este caso son el mismo objeto. self . miPicker . delegate = self . gestorPicker self . miPicker . dataSource = self . gestorPicker Los m\u00e9todos anteriores nos permiten pintar el picker , pero adem\u00e1s nos interesar\u00e1 saber qu\u00e9 opci\u00f3n est\u00e1 seleccionada. En cualquier momento podemos obtener el n\u00famero de fila seleccionado en el picker con //Cambiar el 0 por la \"columna\" que queramos self . miPicker . selectedRow ( inComponent : 0 ) Adem\u00e1s si nos interesa podemos ser avisados en el momento en que el usuario seleccione una opci\u00f3n. Cuando se produzca ese evento, el objeto que act\u00fae de delegate del picker recibir\u00e1 una llamada a su m\u00e9todo pickerView(_:,didSelectRow:,inComponent:) : class GestorPicker : NSObject , UIPickerViewDelegate , UIPickerViewDataSource { var lista = [ \"Pepe\" , \"Eva\" , \"Juan\" , \"Mar\u00eda\" ] ... func pickerView ( _ pickerView : UIPickerView , didSelectRow row : Int , inComponent component : Int ) { print ( \"Seleccionada fila: \\( row ) , dato: \\( lista [ row ] ) \" ) } ... }","title":"Pickers"},{"location":"2_vistas/apuntes/#otros-controles-sliders-switches-date-pickers","text":"Estos controles son muy heterog\u00e9neos, pero todos tienen en com\u00fan que tienen un valor asociado y que este valor puede cambiar debido a las acciones del usuario. El tipo del valor y la(s) propiedade(s) para acceder a \u00e9l ser\u00e1n muy distintas seg\u00fan el tipo de control, por ejemplo: Un UISwitch es booleano y se sabe si est\u00e1 a \"on\" con isOn Un UISlider tiene un valor Float y se accede a \u00e9l con la propiedad value Un UIDatePicker tiene una fecha y se accede a ella con la propiedad date Pero en todos se usa la misma idea, implementar un action vinculado al evento de cambio del valor de modo que en su c\u00f3digo podamos acceder al valor actual. Por ejemplo para un slider tendr\u00edamos algo como //Este m\u00e9todo se ha creado con el \"assistant editor\" y Ctrl+Arrastrar //de la ventana del storyboard al editor con el c\u00f3digo del view controller //Elegimos Connection \"action\" y type \"UISlider\" @IBAction func cambiaSlider ( _ sender : UISlider ) { print ( \"El valor es: \\( sender . value ) \" ) } Es importante que al crear el action , si lo hacemos gr\u00e1ficamente con Ctrl+Arrastrar, en el popup de opciones elijamos como tipo UISlider (o en general, el tipo del control en cuesti\u00f3n). As\u00ed el par\u00e1metro sender que representa el objeto que ha generado el evento tendr\u00e1 el tipo adecuado y no necesitaremos hacer un cast para acceder a la propiedad deseada, como pasar\u00eda si lo dejamos con tipo Any .","title":"Otros controles (sliders, switches, date pickers)"},{"location":"2_vistas/apuntes/#vistas-en-swift","text":"En la asignatura de Tecnolog\u00edas de Desarrollo hemos creado componentes de interfaz de usuario (vistas) arrastr\u00e1ndolos al storyboard . Vamos a ver aqu\u00ed c\u00f3mo crearlos desde Swift y cambiar sus propiedades, que son las mismas que tenemos en Xcode.","title":"Vistas en Swift"},{"location":"2_vistas/apuntes/#las-vistas-y-el-controller","text":"Cada vista est\u00e1 \u00edntimamente ligadas a un determinado controller . Podemos decir que un controller \"posee\" directamente una determinada vista, que es su vista principal, y esta a su vez puede contener subvistas. Toda esta jerarqu\u00eda de vistas forman lo que el usuario percibe como una \"pantalla\" de nuestra app . La vista \"principal\" de un controller es su propiedad view . El sitio indicado para manipular esta view es el m\u00e9todo viewDidLoad del controller en cuesti\u00f3n. Este m\u00e9todo se ejecuta una vez se ha cargado la vista y por tanto ya se han inicializado todos los componentes que hemos creado visualmente desde Xcode. En la plantilla creada por Xcode veremos que este m\u00e9todo llama al de la clase base, al final del m\u00e9todo podemos a\u00f1adir nuestro c\u00f3digo, por ejemplo para cambiar el color de fondo: override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. //aqu\u00ed \"view\" ya estar\u00e1 inicializada, podemos cambiar sus propiedades self . view . backgroundColor = UIColor . green } Otra opci\u00f3n es sobreescribir el m\u00e9todo loadView() del controller , a diferencia del anterior, si existe este m\u00e9todo se convierte en el responsable de cargar la vista principal, y se ignorar\u00e1 por tanto todo lo que se haya definido visualmente en el storyboard . override func loadView () { //Somos responsables de crear \"view\". //Aqu\u00ed le damos el tama\u00f1o de la pantalla del dispositivo //En un momento detallaremos el uso de la propiedad \"frame\" self . view = UIView ( frame : UIScreen . main . bounds ) self . view . backgroundColor = UIColor . green }","title":"Las vistas y el controller"},{"location":"2_vistas/apuntes/#jerarquia-de-vistas","text":"Las vistas nos proporcionan una serie de m\u00e9todos para consultar y modificar la jerarqu\u00eda. El m\u00e9todo b\u00e1sico que necesitaremos es addSubview , que nos permitir\u00e1 a\u00f1adir una subvista a una vista determinada, que se convertir\u00e1 en su vista \"madre\" o supervista : var label = UILabel () label . text = \"Soy una etiqueta\" //suponiendo que \"vista\" ya est\u00e9 definida, ahora ser\u00e1 la supervista de \"label\" vista . addSubView ( label ) Podemos eliminar una vista llamando a su m\u00e9todo removeFromSuperview() . Podemos tambi\u00e9n consultar la jerarqu\u00eda con los siguientes m\u00e9todos: superview : Nos da la vista padre de la vista destinataria del mensaje. subviews : Nos da la lista de subvistas de una vista dada. isDescendantOfView: Comprueba si una vista es descendiente de otra. Como vemos, una vista tiene una lista de vistas hijas. Cada vista hija tiene un \u00edndice, que determinar\u00e1 el orden en el que se dibujan. El \u00edndice 0 es el m\u00e1s cercano al observador, y por lo tanto tapar\u00e1 a los \u00edndices superiores. Podemos insertar una vista en un \u00edndice determinado de la lista de subvistas con insertSubview(_:,at:) . Puede que tengamos una jerarqu\u00eda compleja y necesitemos acceder desde el c\u00f3digo a una determinada vista por ejemplo para inicializar su valor. Una opci\u00f3n es hacer un outlet para cada vista que queramos modificar, pero esto podr\u00eda sobrecargar nuestro objeto de outlets . Tambi\u00e9n puede ser complejo y poco fiable el buscar la vista en la jerarqu\u00eda. En estos casos, lo m\u00e1s sencillo es darle a las vistas que buscamos una etiqueta ( tag ) mediante la propiedad Tag del inspector de atributos (debe ser un valor entero), o asignando la propiedad tag de forma program\u00e1tica. Podremos localizar en nuestro c\u00f3digo una vista a partir de su etiqueta mediante viewWithTag . Llamando a este m\u00e9todo sobre una vista, buscar\u00e1 entre todas las subvistas aquella con la etiqueta indicada: texto = self . window . viewWithTag ( tag : 1 ) La jerarqu\u00eda de vistas de una pantalla determinada de nuestra aplicaci\u00f3n puede llegar a ser muy compleja. Es por eso que en Xcode hay una opci\u00f3n que nos permite mostrar un \u201cdespiece\u201d visual en 3D de las vistas que componen la pantalla actual. Dicha opci\u00f3n est\u00e1 disponible en Debug > View Debugging .En modo texto podemos usar la propiedad recursiveDescription para imprimir la descripci\u00f3n textual de las vistas que contiene una vista dada.","title":"Jerarqu\u00eda de vistas"},{"location":"2_vistas/apuntes/#propiedades-de-una-vista","text":"A continuaci\u00f3n vamos a repasar las propiedades b\u00e1sicas de las vistas, que podremos modificar tanto desde Xcode como de forma program\u00e1tica.","title":"Propiedades de una vista"},{"location":"2_vistas/ejercicios/","text":"Ejercicio de vistas en iOS: controles b\u00e1sicos (1,5 puntos) \u00b6 El objetivo es practicar con los controles b\u00e1sicos de la interfaz de usuario en iOS creando un \"panel de control\" ficticio para una supuesta nave espacial al estilo del que aparece en la figura. Puedes ayudarte de la documentaci\u00f3n de referencia de UIKit para ver los m\u00e9todos y propiedades de los componentes: (0,25 puntos) Campo de texto: Al escribir en \u00e9l y pulsar intro en el teclado onscreen ,debe concatenarse lo escrito al campo de texto de varias l\u00edneas (un text view ) Si quieres que aparezca el teclado onscreen en el simulador debes desactivar la opci\u00f3n de men\u00fa de I/O > Keyboard > Connect Hardware Keyboard (que por defecto aparece activada) ya que si lo est\u00e1 se usar\u00e1 el teclado f\u00edsico del Mac pero no aparecer\u00e1 el teclado en pantalla. (0,5 puntos) Slider : Debes fijar el valor inicial en 0 y el final en 100 (son propiedades del objeto). F\u00edjalas por c\u00f3digo en el viewDidLoad del controller, consulta la documentaci\u00f3n para ver el nombre. Necesitar\u00e1s un outlet para acceder al slider y poder cambiar sus propiedades por c\u00f3digo. Al cambiar su valor debe aparecer en un label al lado cu\u00e1l es el valor actual. Al igual que los botones, para procesar un cambio en un slider puedes crear un action con Ctrl+Arrastrar (0,25 puntos) Al pulsar el bot\u00f3n \u00a1Emergencia! debe aparecer un action sheet con tres opciones: \"nave salvavidas\", \"hiperespacio\" o \"autodestrucci\u00f3n\" (como ves, una opci\u00f3n a la que deber\u00edas ponerle style: .destructive ). Las opciones simplemente imprimir\u00e1n un mensaje en la consola con print (por ejemplo \"\u00a1\u00a1Lanzada nave salvavidas!!). (0,5 puntos) A\u00f1ade un picker para elegir el destino del viaje de entre una serie de destinos prefijados (por ejemplo \"Saturno\", \"M13\", \"Nebulosa de Ori\u00f3n\",...). Cada vez que cambie el valor seleccionado en el picker debe aparecer un mensaje en la consola indic\u00e1ndolo y mostrando el valor actual.","title":"Ejercicios sobre vistas"},{"location":"2_vistas/ejercicios/#ejercicio-de-vistas-en-ios-controles-basicos-15-puntos","text":"El objetivo es practicar con los controles b\u00e1sicos de la interfaz de usuario en iOS creando un \"panel de control\" ficticio para una supuesta nave espacial al estilo del que aparece en la figura. Puedes ayudarte de la documentaci\u00f3n de referencia de UIKit para ver los m\u00e9todos y propiedades de los componentes: (0,25 puntos) Campo de texto: Al escribir en \u00e9l y pulsar intro en el teclado onscreen ,debe concatenarse lo escrito al campo de texto de varias l\u00edneas (un text view ) Si quieres que aparezca el teclado onscreen en el simulador debes desactivar la opci\u00f3n de men\u00fa de I/O > Keyboard > Connect Hardware Keyboard (que por defecto aparece activada) ya que si lo est\u00e1 se usar\u00e1 el teclado f\u00edsico del Mac pero no aparecer\u00e1 el teclado en pantalla. (0,5 puntos) Slider : Debes fijar el valor inicial en 0 y el final en 100 (son propiedades del objeto). F\u00edjalas por c\u00f3digo en el viewDidLoad del controller, consulta la documentaci\u00f3n para ver el nombre. Necesitar\u00e1s un outlet para acceder al slider y poder cambiar sus propiedades por c\u00f3digo. Al cambiar su valor debe aparecer en un label al lado cu\u00e1l es el valor actual. Al igual que los botones, para procesar un cambio en un slider puedes crear un action con Ctrl+Arrastrar (0,25 puntos) Al pulsar el bot\u00f3n \u00a1Emergencia! debe aparecer un action sheet con tres opciones: \"nave salvavidas\", \"hiperespacio\" o \"autodestrucci\u00f3n\" (como ves, una opci\u00f3n a la que deber\u00edas ponerle style: .destructive ). Las opciones simplemente imprimir\u00e1n un mensaje en la consola con print (por ejemplo \"\u00a1\u00a1Lanzada nave salvavidas!!). (0,5 puntos) A\u00f1ade un picker para elegir el destino del viaje de entre una serie de destinos prefijados (por ejemplo \"Saturno\", \"M13\", \"Nebulosa de Ori\u00f3n\",...). Cada vez que cambie el valor seleccionado en el picker debe aparecer un mensaje en la consola indic\u00e1ndolo y mostrando el valor actual.","title":"Ejercicio de vistas en iOS: controles b\u00e1sicos (1,5 puntos)"},{"location":"3_autolayout/apuntes/","text":"Autolayout \u00b6 El por qu\u00e9 de autolayout \u00b6 Hasta ahora en todas las apps que hemos desarrollado hemos colocado los componentes de interfaz en coordenadas fijas, arrastr\u00e1ndolas hasta su posici\u00f3n visualmente con Xcode o bien especificando directamente las coordenadas en Swift. El problema de esto es que si cambiamos de dispositivo o se rota la pantalla la interfaz no se va adaptar adecuadamente, ya que las dimensiones han cambiado y las coordenadas antes especificadas ahora pueden no tener sentido. Por ejemplo, supongamos que queremos centrar un bot\u00f3n en la pantalla, tanto vertical como horizontalmente. En principio parece que basta con moverlo con el rat\u00f3n hacia el centro. En el momento que el bot\u00f3n est\u00e1 centrado, aparecen unas gu\u00edas punteadas que nos lo indican. Sin embargo estas gu\u00edas solo nos est\u00e1n indicando que el componente est\u00e1 centrado con la resoluci\u00f3n actual , pero no va a seguir centrado si esta cambia. Si ejecutamos la aplicaci\u00f3n en el simulador usando el mismo dispositivo que hemos usado en el proceso de dise\u00f1o veremos que efectivamente est\u00e1 centrado. Pero no es as\u00ed si cambiamos el dispositivo, o si por ejemplo rotamos la pantalla en el simulador (tecla Cmd-Flecha izquierda) Necesitamos alg\u00fan sistema que adapte autom\u00e1ticamente las dimensiones de los componentes de la interfaz a la resoluci\u00f3n actual. En iOS ese sistema es Autolayout . Es un sistema declarativo y basado en restricciones. El sistema usa las restricciones especificadas para calcular autom\u00e1ticamente el frame de cada vista de la interfaz, y adaptarlo a las dimensiones actuales de la ventana. Manejo de restricciones desde Xcode \u00b6 Para especificar qu\u00e9 aspecto queremos que tenga la interfaz independientemente de la resoluci\u00f3n hay que a\u00f1adir restricciones . B\u00e1sicamente las hay de dos tipos: De alineaci\u00f3n ( align ): por ejemplo queremos que un bot\u00f3n est\u00e9 centrado horizontalmente o verticalmente en su contenedor. O que varios componentes est\u00e9n alineados entre s\u00ed. De espaciado ( pin ): por ejemplo queremos que entre un componente y otro, o entre un componente y el borde izquierdo de la pantalla haya un espacio vac\u00edo. Aqu\u00ed tambi\u00e9n se incluir\u00edan las restricciones de tama\u00f1o de un componente individual. (fijar el ancho, el alto,\u2026) Hay dos formas de a\u00f1adir restricciones en Xcode: \"haciendo clic y arrastrando\" con el rat\u00f3n o bien a trav\u00e9s de la barra de herramientas de AutoLayout. A\u00f1adiendo restricciones con botones/men\u00fas \u00b6 En la parte inferior derecha del storyboard hay una barra de botones espec\u00edficos para autolayout : Los que nos sirven para a\u00f1adir restricciones son el segundo y el tercero. Luego veremos el uso de los restantes. Vamos a arreglar el ejemplo anterior en el que quer\u00edamos centrar horizontal y verticalmente el bot\u00f3n. Tenemos que a\u00f1adir dos restricciones: una de centrado horizontal y otra de centrado vertical. En terminolog\u00eda de autolayout esto son restricciones de alineado ( align ). Seleccionamos este con el rat\u00f3n y pulsamos sobre el icono de Align (el segundo). En el popup que aparece marcamos las casillas de Horizontally in container y Vertically in container Pulsamos sobre el bot\u00f3n que ahora pondr\u00e1 Add 2 constraints para hacer efectivas las restricciones. Las l\u00edneas de gu\u00eda, que antes aparec\u00edan punteadas, ahora ser\u00e1n continuas indicando que ahora son restricciones de autolayout . Aunque cambiemos de dispositivo o de orientaci\u00f3n veremos que el bot\u00f3n sigue centrado. Las restricciones a\u00f1adidas las podemos ver en varios sitios de Xcode: En el \u00e1rea de Document outline , que es accesible pulsando sobre el icono que aparece en la parte inferior izquierda del storyboard . Aqu\u00ed podemos ver un \u201c\u00e1rbol\u201d desplegable con las restricciones. En el Size inspector (icono del panel de la derecha de Xcode) aparece una lista de restricciones aplicadas al componente actual. Cada una tiene un bot\u00f3n Edit para cambiar sus propiedades, aunque aqu\u00ed se muestran en su forma \"matem\u00e1tica\" que no es la m\u00e1s intuitiva (luego veremos que las restricciones son en realidad ecuaciones). Para editar las restricciones: Si hacemos clic sobre una restricci\u00f3n, ya hemos visto que podemos editar sus propiedades en el Size inspector del panel derecho de Xcode). Si seleccionamos una restricci\u00f3n y pulsamos la tecla Backspace se eliminar\u00e1 esta. A\u00f1adiendo restricciones con el rat\u00f3n \u00b6 Esta forma es algo m\u00e1s \u00e1gil que la anterior pero requiere de cierta pr\u00e1ctica. Cuando queremos establecer una restricci\u00f3n entre dos elementos arrastramos de uno a otro manteniendo pulsada la tecla Ctrl (igual que para crear un outlet o un action ). Cuando soltamos el bot\u00f3n del rat\u00f3n, aparece un men\u00fa contextual donde elegir la restricci\u00f3n. Las opciones disponibles en el men\u00fa dependen de la direcci\u00f3n y sentido en que se haya arrastrado: - Si arrastramos en sentido horizontal, podemos (entre otros) centrar verticalmente. Y al contrario si arrastramos en vertical. - Las restricciones de espaciado ser\u00e1n hacia el borde que hayamos arrastrado. Cuando se a\u00f1aden restricciones de espaciado con respecto al borde superior e inferior de la pantalla, puede verse que en realidad no se est\u00e1n referenciando los bordes de la pantalla en s\u00ed sino los de un \u00e1rea que Xcode llama safe area Estas \u00e1reas \u201ccrecen autom\u00e1ticamente\u201d para dejar espacio a las barras de navegaci\u00f3n y de botones que veremos cuando usemos navigation controllers y tab bar controllers , asegur\u00e1ndonos as\u00ed de que dichas barras no tapan a nuestras vistas. Restricciones insuficientes o contradictorias \u00b6 Generalmente cuando comenzamos a a\u00f1adir restricciones, las l\u00edneas que las representan aparecen en color naranja en lugar de azul. Esto sucede porque todav\u00eda las restricciones son insuficientes para determinar un\u00edvocamente las coordenadas del frame del componente. Por ejemplo si acabamos de crear un bot\u00f3n y lo centramos verticalmente, lo hemos \u201cfijado\u201d en el eje de las x pero no as\u00ed en el de las y . Adem\u00e1s se muestra un contorno dibujado en l\u00ednea punteada que indica d\u00f3nde calcula Xcode que acabar\u00e1 posicion\u00e1ndose el componente con las restricciones actuales (y que a lo mejor no es donde nosotros queremos). Como regla general nos van a hacer falta dos restricciones por cada dimensi\u00f3n (X e Y) para eliminar la ambig\u00fcedad, aunque hay elementos que solo necesitan una restricci\u00f3n por dimensi\u00f3n, como los botones. Veamos por qu\u00e9. Los botones tienen lo que se denomina un tama\u00f1o intr\u00ednseco . Es decir, aunque no lo digamos expl\u00edcitamente, iOS le asigna el ancho y el alto justo para que quepa el texto mostrado. O sea, es como si ya tuvieran una restricci\u00f3n impl\u00edcita en la X y en la Y. As\u00ed que cuando decimos que el bot\u00f3n est\u00e9 centrado en la X (verticalmente), a autolayout le basta esta restricci\u00f3n para determinar el comportamiento del bot\u00f3n en esta dimensi\u00f3n, ya que la combina con el tama\u00f1o impl\u00edcito. Otros componentes que tienen como tama\u00f1o intr\u00ednseco su contenido son los UILabel , los UIImage , los UITextField . Los UISwitch tienen tambi\u00e9n un ancho y alto fijos, as\u00ed como los UIStepper . Los UISlider son un caso especial porque tienen un alto fijo pero no pasa as\u00ed con el ancho ( M\u00e1s informaci\u00f3n ) Sin embargo no ocurre lo mismo con otros componentes. Por ejemplo los text view con barra de scroll no tienen un tama\u00f1o intr\u00ednseco . De este modo, a\u00f1adir la restricci\u00f3n de centrar un Text View en la dimensi\u00f3n X no resuelve la ambig\u00fcedad de qu\u00e9 ancho deber\u00eda tener, o visto de otro modo, en qu\u00e9 valor de x deber\u00eda empezar su borde izquierdo. Para este tipo de elementos nos har\u00e1n falta dos restricciones por cada dimensi\u00f3n, o dicho de otro modo 4 en total para posicionar el elemento sin ambig\u00fcedades. Otros componentes tienen un tama\u00f1o intr\u00ednseco solo en una dimensi\u00f3n, por ejemplo los slider lo tienen en la Y pero no en la X, por lo que nos har\u00e1 falta una \u00fanica restricci\u00f3n en la Y pero dos en la X. Otro problema t\u00edpico es cuando movemos con el rat\u00f3n el elemento una vez se ha establecido la restricci\u00f3n, de modo que no ocupa la posici\u00f3n que esta restricci\u00f3n est\u00e1 induciendo. Las l\u00edneas de restricci\u00f3n tambi\u00e9n aparecer\u00e1n en naranja, y el n\u00famero que indica su tama\u00f1o tendr\u00e1 un s\u00edmbolo + o - para indicar el desplazamiento. Podemos hacer que el elemento vuelva a la posici\u00f3n que indican las restricciones pulsando sobre el primero de los botones de autolayout , Update Frames . Cuando las restricciones son contradictorias , las l\u00edneas que las representan aparecen en color rojo. Por ejemplo en la siguiente figura hemos intentado especificar un espaciado de 20 puntos con el margen derecho, un ancho de 46 y adem\u00e1s que est\u00e9 centrado en horizontal. Con un tama\u00f1o de pantalla convencional esto es imposible, y as\u00ed lo indica Xcode. Cuando hay problemas con las restricciones estos se muestran tambi\u00e9n en el Document outline del storyboard. En el \u00e1ngulo superior derecho del Document outline aparece una peque\u00f1a flecha roja indicando que hay problemas, y si la pulsamos aparecer\u00e1 la lista de restricciones contradictorias e insuficientes. Podemos intentar resolver estos problemas de forma autom\u00e1tica. Para eso est\u00e1 el bot\u00f3n Resolve autolayout issues de la barra de botones de autolayout (recordar que est\u00e1 en la esquina inferior derecha del storyboard ). Hay varias posibilidades: Update frames : queremos recalcular las posiciones y dimensiones de los frames usando las restricciones actuales. Si hemos movido los elementos con el rat\u00f3n, volver\u00e1n a \u201csu posici\u00f3n\u201d. Update restrictions : si hemos movido los elementos, Xcode intentar\u00e1 recalcular las restricciones para que se correspondan con la posici\u00f3n actual. Add missing constraints : bas\u00e1ndose en la posici\u00f3n actual de los elementos, Xcode intentar\u00e1 inferir y a\u00f1adir las restricciones adecuadas para que el layout deje de ser ambiguo. Reset to suggested constraints : el equivalente a eliminar todas las restricciones ( Clear constraints ) y luego seleccionar Add missing constraints . Previsualizar el efecto de las restricciones \u00b6 Podemos previsualizar el efecto de las restricciones desde el propio Xcode. En la parte inferior del storyboard editor se ve el dispositivo que estamos usando actualmente, aparece algo como \"View as: iPhone XR\". Si clicamos con el rat\u00f3n en ese nombre aparecer\u00e1 una barra de herramientas para cambiar el dispositivo y/o la orientaci\u00f3n Restricciones sobre el tama\u00f1o \u00b6 Aunque hemos dicho que autolayout calcula el frame de cada componente, hasta ahora hemos ignorado el tama\u00f1o de los mismos. Centrar en horizontal y vertical elimina la ambig\u00fcedad en cuanto a en qu\u00e9 coordenadas \u201canclar\u201d el frame pero \u00bfqu\u00e9 hay de su ancho y alto?. Para muchos componentes ( UILabel , UIButton , UIImage ) no es necesario especificar un tama\u00f1o ya que lo tienen por defecto (el llamado \u201ctama\u00f1o intr\u00ednseco\u201d en el argot de autolayout). En el API la propiedad correspondiente es intrinsicContentSize . Lo m\u00e1s habitual es que sea el tama\u00f1o del texto que contienen. No obstante, tambi\u00e9n podemos poner restricciones sobre el tama\u00f1o. Podemos fijar el ancho y/o el alto o el aspect ratio . Estas son restricciones del tipo pin y por tanto las podemos encontrar donde encontramos las de espaciado entre componentes (en el men\u00fa principal o en la barra de botones de autolayout). Si usamos ctrl-arrastrar con el rat\u00f3n bastar\u00e1 con que arrastremos sin salirnos del componente (al arrastrar en horizontal se nos dar\u00e1 la posibilidad de finar el ancho y lo mismo con el alto si arrastramos en vertical). Si especificamos el tama\u00f1o mediante una restricci\u00f3n podemos forzar a que el contenido del bot\u00f3n tenga que \u201ccortarse\u201d porque no cabe, o bien que tenga que a\u00f1adirse un padding al sobrar espacio. Prioridades \u00b6 En autolayout a veces puede haber reglas contradictorias o ambiguas. Una forma de resolver estas ambig\u00fcedades o contradicciones es mediante el uso de prioridades *. Prioridades de las restricciones \u00b6 Cada restricci\u00f3n tiene asignada una prioridad , que es un valor num\u00e9rico que especifica su \u201cimportancia\u201d (a mayor valor, mayor prioridad): El valor por defecto es 1000, que significa que el sistema entiende que la restricci\u00f3n debe cumplirse . Valores menores que 1000 indican que el sistema intentar\u00e1 cumplir la restricci\u00f3n pero que es posible que no lo haga, si hay restricciones contradictorias de mayor prioridad. Podemos cambiar/ver la prioridad actual de la misma forma que podemos cambiar/ver el resto de propiedades de la restricci\u00f3n (ver apartado anterior). Prioridades de los componentes \u00b6 Hay casos en los que puede ser necesario \"comprimir\" o \"ensanchar\" los componentes para cumplir las restricciones. En el siguiente ejemplo, estamos fijando el espacio horizontal entre componentes y de componentes a m\u00e1rgenes muy peque\u00f1o, en 8 puntos, pero para que los espacios se cumplan, alguno de los componentes, o los dos, se tendr\u00eda que ensanchar con respecto a su tama\u00f1o intr\u00ednseco: Como vemos Xcode indica que hay un problema con las restricciones, ya que el layout es ambiguo. Para cumplir las restricciones se podr\u00eda ensanchar la imagen o el label con respecto a su tama\u00f1o intr\u00ednseco. \u00bfCu\u00e1l elegir? Adem\u00e1s de las restricciones, tambi\u00e9n los componentes GUI tienen dos valores de prioridad, relativos al tama\u00f1o. El Content hugging indica la prioridad que para el componente tiene evitar el padding (o \"relleno\" o \"ensanchado\"). Por defecto tiene un valor de 251. Fijaos en que es un valor relativamente bajo, indicando que si hay reglas que lleven a aumentar el padding se tomar\u00e1n en cuenta salvo que tengan prioridad muy baja. El problema anterior se podr\u00eda resolver modificando el hugging de alguno de los dos componentes, el label o la imagen. Si subimos la prioridad de un componente haremos que se \"expanda\" el otro, y a la inversa, si la bajamos, lo haremos \"expandirse\" a \u00e9l. En el problema inverso al anterior, podr\u00edamos haber exigido que los espacios entre componentes fueran muy grandes, forzando entonces a que uno de los dos componentes se \"comprima\" (y por ejemplo en el caso del label deje de mostrar parte de su contenido). Para poder decidir cu\u00e1l de ellos tenemos la Compression resistance , que es la prioridad que para el componente tiene mostrar completo su contenido, resisti\u00e9ndose por tanto a ser comprimido. Por defecto los componentes tienen este valor a 750. De nuevo jugando con este valor podemos decidir qu\u00e9 componente se deber\u00eda comprimir. Si una regla con prioridad por defecto lleva a que el contenido de un elemento se comprima ganar\u00e1 la regla, pero no ser\u00e1 as\u00ed si su prioridad es menor que 750. N\u00f3tese que se ha escogido un valor por defecto relativamente alto para evitar que reglas \"no demasiado importantes\" lleven a que se compriman los componentes y dejen de mostrarse \"completos\" como t\u00edtulos de botones, textos de labels , etc. Stack views \u00b6 Son agrupaciones de componentes en forma de fila o columna, y se usan para crear f\u00e1cilmente layouts de elementos en disposici\u00f3n horizontal o vertical. As\u00ed solo hay que especificar las restricciones del stack view como un bloque, y no de cada componente por separado. Para crear un stack view , seleccionar varios elementos (manteniendo pulsado Command + clic del rat\u00f3n en cada uno) y luego pulsar sobre el \u00faltimo bot\u00f3n de la barra de autolayout , llamado Embed In (recordad, parte inferior derecha de la ventana del storyboard ). En el men\u00fa desplegable del bot\u00f3n, elegir Stack View . Si los componentes seleccionados estaban m\u00e1s o menos en vertical se crear\u00e1 un stack view de este tipo y lo mismo si est\u00e1n en horizontal, aunque el tipo se puede cambiar en las propiedades. Las propiedades del stack view son accesibles seleccion\u00e1ndolo con el rat\u00f3n y como siempre en el Inspector de propiedades (el icono con una escuadra, panel derecho de Xcode). Podemos indicar c\u00f3mo se reparten los componentes el espacio disponible, dejar un espacio adicional entre ellos, especificar la alineaci\u00f3n,... El Axis indica si el stack view es vertical u horizontal Alignment es la alineaci\u00f3n en la perpendicular al eje del stack view , es decir, es la alineaci\u00f3n vertical para los stack views horizontales y viceversa. Distribution se refiere c\u00f3mo se distribuyen los elementos en la direcci\u00f3n del eje del stack view Alignment y Distribution \u00b6 Como hemos dicho, se refiere c\u00f3mo se alinean los componentes en la perpendicular al eje del stack view . Para uno horizontal, se referir\u00e1 entonces a la alineaci\u00f3n en vertical: Fill , Top , Center o Bottom . Los valores son distintos para los stack view verticales, en este caso pueden ser Fill , Leading , Center o Trailing . En un stack view horizontal, b\u00e1sicamente la altura la determina el elemento m\u00e1s alto. Con Fill indicamos que queremos que todos los componentes tengan el mismo tama\u00f1o en Y (el del componente m\u00e1s alto). El resto de opciones son diferentes alineaciones verticales. El mismo razonamiento se puede hacer con un stack view vertical, el elemento m\u00e1s anchho y Fill . En cuanto a distribution : Fill : se llena el espacio del stack view pero cada componente puede tener un tama\u00f1o distinto Fill Equally : se llena el espacio del stack view y todos los componentes tienen el mismo tama\u00f1o (ancho para stacks horizontales y alto para verticales). Fill Proportionally : se llena el espacio del stack view , cada componente de manera proporcional a su tama\u00f1o intr\u00ednseco. Equal Spacing : el espacio entre componentes debe ser igual y como m\u00ednimo el valor de la propiedad spacing del stack view . Tambi\u00e9n podemos anidar stack views , tener unos dentro de otros, por ejemplo aqu\u00ed tenemos uno horizontal anidado dentro de una fila de uno vertical Restricciones \"avanzadas\" \u00b6 Nota Esta parte es complementaria, y aunque interesante, no es necesaria para realizar los ejercicios de la sesi\u00f3n. Formulaci\u00f3n matem\u00e1tica de una restricci\u00f3n \u00b6 Internamente, cada restricci\u00f3n se formula como una ecuaci\u00f3n lineal en la que: 1 item1.atributo1 = multiplicador * item2.atributo2 + cte Algunas restricciones no son ecuaciones sino inecuaciones , sustituyendo el s\u00edmbolo = por <= o >= . Es decir, desde el punto de vista formal, lo que hace autolayout es resolver un sistema de ecuaciones lineales. Estas propiedades podemos verlas en el Size inspector (parte derecha de la pantalla, icono de la regla ). Si seleccionamos un componente de UI aparecer\u00e1n aqu\u00ed todas sus restricciones, que podemos editar pulsando en Edit . Por ejemplo, aqu\u00ed vemos las restricciones de un bot\u00f3n centrado en el eje de las X y con un espaciado est\u00e1ndar (8 puntos) con respecto a la gu\u00eda inferior. Podemos observar en la figura las propiedades de la restricci\u00f3n, que se corresponden directamente con los coeficientes del lado derecho de la ecuaci\u00f3n lineal (el multiplicador y la constante). Adem\u00e1s aparece una prioridad , que explicaremos en el siguiente apartado. Haciendo clic en el desplegable con el s\u00edmbolo = podemos cambiar la ecuaci\u00f3n por una inecuaci\u00f3n. En nuestro ejemplo la constante es 0 y el multiplicador 1 porque queremos centrar el componente en el contenedor, es decir 1 contenedor.centerX = componente.centerX Podemos por ejemplo cambiar la constante por 50, con lo que conseguiremos que el componente est\u00e9 desplazado 50 puntos a la izquierda de la posici\u00f3n de \u201ccentrado en X\u201d. Si en lugar de seleccionar el componente GUI seleccionamos directamente una restricci\u00f3n y nos vamos al Size inspector podremos editar directamente las propiedades de la restricci\u00f3n, incluyendo tambi\u00e9n los propios atributos. Expresar restricciones usando c\u00f3digo Swift \u00b6 En lugar de usar el editor visual de Xcode podemos especificar las restricciones por c\u00f3digo. Esto puede resultar interesante en diversas situaciones: A veces los elementos de la interfaz se crean din\u00e1micamente y por tanto no se puede especificar el layout por adelantado en Xcode. Otras veces, aunque los elementos de la interfaz no cambien en s\u00ed puede que queramos cambiar din\u00e1micamente las restricciones para conseguir efectos din\u00e1micos de layout . Hay dos formas de hacerlo: directamente con el API de autolayout o con un mayor nivel de abstracci\u00f3n usando el llamado \u201cVisual Format Language\u201d. Si podemos elegir, la mejor forma es la segunda, ya que es mucho m\u00e1s intuitivo especificar las restricciones y entenderlas leyendo luego el c\u00f3digo. El API b\u00e1sico de autolayout \u00b6 Cada restricci\u00f3n es un objeto de la clase NSLayoutConstraint . En el inicializador de esta clase se especifica directamente par\u00e1metro por par\u00e1metro cada una de las propiedades de la restricci\u00f3n. Por ejemplo, supongamos que estamos en un view controller y queremos centrar un bot\u00f3n en su contenedor en el eje de las X. El bot\u00f3n lo tenemos en un outlet llamado boton , y ya sabemos que a la vista podemos acceder desde el controller con self.view . La restricci\u00f3n en forma de expresi\u00f3n matem\u00e1tica ser\u00eda algo como 1 self.view.centerX = 1*boton.centerX+0 Donde se ha puesto de forma expl\u00edcita la constante y el multiplicador para ver m\u00e1s clara la correspondencia directa con el c\u00f3digo Swift, donde se har\u00eda como: let centradoX = NSLayoutConstraint ( item : self . boton , attribute : . centerY , relatedBy : . equal , toItem : self . view , attribute : . centerY , multiplier : 1.0 , constant : 0.0 ) Como vemos hay una correspondencia bastante directa entre la expresi\u00f3n matem\u00e1tica y el c\u00f3digo. Una vez creada la constante hay que activarla . Esto se puede hacer fijando isActive a true centradoX . isActive = true Una alternativa es a\u00f1adir la restricci\u00f3n a la vista con addConstraint() self . view . addConstraint ( centradoX ) Como vemos, hemos a\u00f1adido la restricci\u00f3n al contenedor del bot\u00f3n. Como norma general, si son vistas \u201cmadre/hija\u201d la a\u00f1adiremos a la \u201cmadre\u201d, y en otro caso al ancestro com\u00fan m\u00e1s cercano de ambas vistas . Por ejemplo si fuera una relaci\u00f3n entre dos botones dentro del mismo contenedor la a\u00f1adir\u00edamos al contenedor. MUY IMPORTANTE: Xcode a\u00f1ade impl\u00edcitamente algunas restricciones a los componentes, adem\u00e1s de las puestas expl\u00edcitamente por nosotros en c\u00f3digo, y es bastante probable que entren en conflicto con las nuestras y para resolver el problema el sistema las acabe ignorando. Por ello para usar autolayout por c\u00f3digo lo primero es indicar que para un determinado componente no queremos esas restricciones \u201cautom\u00e1ticas\u201d. En nuestro caso para el bot\u00f3n: self . boton . translatesAutoresizingMaskIntoConstraints = false Esto habr\u00eda que hacerlo antes de activar las restricciones. Visual Format Language \u00b6 La conversi\u00f3n de ecuaci\u00f3n matem\u00e1tica a llamada del API es bastante directa, pero tiene el problema de que no es f\u00e1cil y r\u00e1pido deducir intuitivamente la restricci\u00f3n leyendo el c\u00f3digo. Es mucho m\u00e1s intuitivo leer \u201cel componente debe estar centrado en el eje X pero desplazado 10 pixels a la izquierda\u201d que leer superview.centroX = componente.centroX + 10 . La descripci\u00f3n formal pero a la vez intuitiva de un conjunto de restricciones se puede hacer con una ingeniosa \u201crepresentaci\u00f3n en modo texto\u201d de la representaci\u00f3n gr\u00e1fica de las restricciones llamada Visual Format Language . Dicho formato permite representar un conjunto de restricciones con una cadena de caracteres. La representaci\u00f3n usa s\u00edmbolos \u201csemi-gr\u00e1ficos\u201d, un poco al estilo del ASCII-ART (salvando las distancias). As\u00ed, por ejemplo si queremos especificar que entre dos componentes debe haber una separaci\u00f3n est\u00e1ndar (8 pixels) usar\u00edamos la cadena: 1 [ boton1 ]-[ boton2 ] Donde los corchetes indican un componente, y el ``-``` indica la separaci\u00f3n est\u00e1ndar. La cadena se parece razonablemente a la representaci\u00f3n gr\u00e1fica que podr\u00edamos ver en Xcode de la misma restricci\u00f3n. Hay que indicar que boton1 y boton2 no son exactamente nombres de variables sino etiquetas arbitrarias. La llamada al API para crear esta restricci\u00f3n usando el visual format language ser\u00eda algo como: let constraint = NSLayoutConstraint . constraints ( withVisualFormat : \"[boton1]-[boton2]\" options : . alignAllCenterY , metrics : nil , views : viewsDict ]; donde: - El primer par\u00e1metro es la cadena de formato - options es una m\u00e1scara de bits formada a partir de enumerados describiendo la direcci\u00f3n y la alineaci\u00f3n de los componentes - metrics se usa si hay constantes en la restricci\u00f3n (no es el caso del ejemplo). Es un diccionario en el que las claves son los nombres de las constantes y los valores son los de las constantes. - El \u00faltimo es un diccionario donde las claves son los nombres de componentes en la cadena y los valores son las variables correspondientes a las vistas. Lo habr\u00edamos creado con un c\u00f3digo como: let b1 = UIButton () let b2 = UIButton () let viewsDict = [ \"boton1\" : b1 , \"boton2\" : b2 ] Algunos ejemplos adicionales de cadenas de formato: [boton1]-20-[boton2] separaci\u00f3n de 20 puntos [boton1(50)]-20-[boton2(>=50)] entre par\u00e9ntesis especificamos el ancho del bot\u00f3n, n\u00f3tese que se pueden poner desigualdades [boton1]-20@800-[boton2] las prioridades se ponen con la @ [boton1]-20-[boton2(==boton1)] el bot\u00f3n 2 debe ser del mismo tama\u00f1o que el 1. V:[topField]-10-[bottomField] con la V especificamos que es un layout en vertical, los dos campos estar\u00e1n uno encima del otro separados por una distancia de 10 puntos. |-[find]-[findNext]-[findField(>=20)]-| una l\u00ednea completa de layout , donde las barras verticales representan los bordes del contenedor. Se recomienda consultar la documentaci\u00f3n de Apple para m\u00e1s informaci\u00f3n sobre la sintaxis y ejemplos adicionales. En el dise\u00f1o del formato, se ha preferido la claridad y el paralelismo con la representaci\u00f3n gr\u00e1fica a la expresividad. Como resultado, ciertas restricciones no son expresables. Por ejemplo no se puede especificar que el ancho de un bot\u00f3n sea el doble que el de otro.","title":"Autolayout"},{"location":"3_autolayout/apuntes/#autolayout","text":"","title":"Autolayout"},{"location":"3_autolayout/apuntes/#el-por-que-de-autolayout","text":"Hasta ahora en todas las apps que hemos desarrollado hemos colocado los componentes de interfaz en coordenadas fijas, arrastr\u00e1ndolas hasta su posici\u00f3n visualmente con Xcode o bien especificando directamente las coordenadas en Swift. El problema de esto es que si cambiamos de dispositivo o se rota la pantalla la interfaz no se va adaptar adecuadamente, ya que las dimensiones han cambiado y las coordenadas antes especificadas ahora pueden no tener sentido. Por ejemplo, supongamos que queremos centrar un bot\u00f3n en la pantalla, tanto vertical como horizontalmente. En principio parece que basta con moverlo con el rat\u00f3n hacia el centro. En el momento que el bot\u00f3n est\u00e1 centrado, aparecen unas gu\u00edas punteadas que nos lo indican. Sin embargo estas gu\u00edas solo nos est\u00e1n indicando que el componente est\u00e1 centrado con la resoluci\u00f3n actual , pero no va a seguir centrado si esta cambia. Si ejecutamos la aplicaci\u00f3n en el simulador usando el mismo dispositivo que hemos usado en el proceso de dise\u00f1o veremos que efectivamente est\u00e1 centrado. Pero no es as\u00ed si cambiamos el dispositivo, o si por ejemplo rotamos la pantalla en el simulador (tecla Cmd-Flecha izquierda) Necesitamos alg\u00fan sistema que adapte autom\u00e1ticamente las dimensiones de los componentes de la interfaz a la resoluci\u00f3n actual. En iOS ese sistema es Autolayout . Es un sistema declarativo y basado en restricciones. El sistema usa las restricciones especificadas para calcular autom\u00e1ticamente el frame de cada vista de la interfaz, y adaptarlo a las dimensiones actuales de la ventana.","title":"El por qu\u00e9 de autolayout"},{"location":"3_autolayout/apuntes/#manejo-de-restricciones-desde-xcode","text":"Para especificar qu\u00e9 aspecto queremos que tenga la interfaz independientemente de la resoluci\u00f3n hay que a\u00f1adir restricciones . B\u00e1sicamente las hay de dos tipos: De alineaci\u00f3n ( align ): por ejemplo queremos que un bot\u00f3n est\u00e9 centrado horizontalmente o verticalmente en su contenedor. O que varios componentes est\u00e9n alineados entre s\u00ed. De espaciado ( pin ): por ejemplo queremos que entre un componente y otro, o entre un componente y el borde izquierdo de la pantalla haya un espacio vac\u00edo. Aqu\u00ed tambi\u00e9n se incluir\u00edan las restricciones de tama\u00f1o de un componente individual. (fijar el ancho, el alto,\u2026) Hay dos formas de a\u00f1adir restricciones en Xcode: \"haciendo clic y arrastrando\" con el rat\u00f3n o bien a trav\u00e9s de la barra de herramientas de AutoLayout.","title":"Manejo de restricciones desde Xcode"},{"location":"3_autolayout/apuntes/#anadiendo-restricciones-con-botonesmenus","text":"En la parte inferior derecha del storyboard hay una barra de botones espec\u00edficos para autolayout : Los que nos sirven para a\u00f1adir restricciones son el segundo y el tercero. Luego veremos el uso de los restantes. Vamos a arreglar el ejemplo anterior en el que quer\u00edamos centrar horizontal y verticalmente el bot\u00f3n. Tenemos que a\u00f1adir dos restricciones: una de centrado horizontal y otra de centrado vertical. En terminolog\u00eda de autolayout esto son restricciones de alineado ( align ). Seleccionamos este con el rat\u00f3n y pulsamos sobre el icono de Align (el segundo). En el popup que aparece marcamos las casillas de Horizontally in container y Vertically in container Pulsamos sobre el bot\u00f3n que ahora pondr\u00e1 Add 2 constraints para hacer efectivas las restricciones. Las l\u00edneas de gu\u00eda, que antes aparec\u00edan punteadas, ahora ser\u00e1n continuas indicando que ahora son restricciones de autolayout . Aunque cambiemos de dispositivo o de orientaci\u00f3n veremos que el bot\u00f3n sigue centrado. Las restricciones a\u00f1adidas las podemos ver en varios sitios de Xcode: En el \u00e1rea de Document outline , que es accesible pulsando sobre el icono que aparece en la parte inferior izquierda del storyboard . Aqu\u00ed podemos ver un \u201c\u00e1rbol\u201d desplegable con las restricciones. En el Size inspector (icono del panel de la derecha de Xcode) aparece una lista de restricciones aplicadas al componente actual. Cada una tiene un bot\u00f3n Edit para cambiar sus propiedades, aunque aqu\u00ed se muestran en su forma \"matem\u00e1tica\" que no es la m\u00e1s intuitiva (luego veremos que las restricciones son en realidad ecuaciones). Para editar las restricciones: Si hacemos clic sobre una restricci\u00f3n, ya hemos visto que podemos editar sus propiedades en el Size inspector del panel derecho de Xcode). Si seleccionamos una restricci\u00f3n y pulsamos la tecla Backspace se eliminar\u00e1 esta.","title":"A\u00f1adiendo restricciones con botones/men\u00fas"},{"location":"3_autolayout/apuntes/#anadiendo-restricciones-con-el-raton","text":"Esta forma es algo m\u00e1s \u00e1gil que la anterior pero requiere de cierta pr\u00e1ctica. Cuando queremos establecer una restricci\u00f3n entre dos elementos arrastramos de uno a otro manteniendo pulsada la tecla Ctrl (igual que para crear un outlet o un action ). Cuando soltamos el bot\u00f3n del rat\u00f3n, aparece un men\u00fa contextual donde elegir la restricci\u00f3n. Las opciones disponibles en el men\u00fa dependen de la direcci\u00f3n y sentido en que se haya arrastrado: - Si arrastramos en sentido horizontal, podemos (entre otros) centrar verticalmente. Y al contrario si arrastramos en vertical. - Las restricciones de espaciado ser\u00e1n hacia el borde que hayamos arrastrado. Cuando se a\u00f1aden restricciones de espaciado con respecto al borde superior e inferior de la pantalla, puede verse que en realidad no se est\u00e1n referenciando los bordes de la pantalla en s\u00ed sino los de un \u00e1rea que Xcode llama safe area Estas \u00e1reas \u201ccrecen autom\u00e1ticamente\u201d para dejar espacio a las barras de navegaci\u00f3n y de botones que veremos cuando usemos navigation controllers y tab bar controllers , asegur\u00e1ndonos as\u00ed de que dichas barras no tapan a nuestras vistas.","title":"A\u00f1adiendo restricciones con el rat\u00f3n"},{"location":"3_autolayout/apuntes/#restricciones-insuficientes-o-contradictorias","text":"Generalmente cuando comenzamos a a\u00f1adir restricciones, las l\u00edneas que las representan aparecen en color naranja en lugar de azul. Esto sucede porque todav\u00eda las restricciones son insuficientes para determinar un\u00edvocamente las coordenadas del frame del componente. Por ejemplo si acabamos de crear un bot\u00f3n y lo centramos verticalmente, lo hemos \u201cfijado\u201d en el eje de las x pero no as\u00ed en el de las y . Adem\u00e1s se muestra un contorno dibujado en l\u00ednea punteada que indica d\u00f3nde calcula Xcode que acabar\u00e1 posicion\u00e1ndose el componente con las restricciones actuales (y que a lo mejor no es donde nosotros queremos). Como regla general nos van a hacer falta dos restricciones por cada dimensi\u00f3n (X e Y) para eliminar la ambig\u00fcedad, aunque hay elementos que solo necesitan una restricci\u00f3n por dimensi\u00f3n, como los botones. Veamos por qu\u00e9. Los botones tienen lo que se denomina un tama\u00f1o intr\u00ednseco . Es decir, aunque no lo digamos expl\u00edcitamente, iOS le asigna el ancho y el alto justo para que quepa el texto mostrado. O sea, es como si ya tuvieran una restricci\u00f3n impl\u00edcita en la X y en la Y. As\u00ed que cuando decimos que el bot\u00f3n est\u00e9 centrado en la X (verticalmente), a autolayout le basta esta restricci\u00f3n para determinar el comportamiento del bot\u00f3n en esta dimensi\u00f3n, ya que la combina con el tama\u00f1o impl\u00edcito. Otros componentes que tienen como tama\u00f1o intr\u00ednseco su contenido son los UILabel , los UIImage , los UITextField . Los UISwitch tienen tambi\u00e9n un ancho y alto fijos, as\u00ed como los UIStepper . Los UISlider son un caso especial porque tienen un alto fijo pero no pasa as\u00ed con el ancho ( M\u00e1s informaci\u00f3n ) Sin embargo no ocurre lo mismo con otros componentes. Por ejemplo los text view con barra de scroll no tienen un tama\u00f1o intr\u00ednseco . De este modo, a\u00f1adir la restricci\u00f3n de centrar un Text View en la dimensi\u00f3n X no resuelve la ambig\u00fcedad de qu\u00e9 ancho deber\u00eda tener, o visto de otro modo, en qu\u00e9 valor de x deber\u00eda empezar su borde izquierdo. Para este tipo de elementos nos har\u00e1n falta dos restricciones por cada dimensi\u00f3n, o dicho de otro modo 4 en total para posicionar el elemento sin ambig\u00fcedades. Otros componentes tienen un tama\u00f1o intr\u00ednseco solo en una dimensi\u00f3n, por ejemplo los slider lo tienen en la Y pero no en la X, por lo que nos har\u00e1 falta una \u00fanica restricci\u00f3n en la Y pero dos en la X. Otro problema t\u00edpico es cuando movemos con el rat\u00f3n el elemento una vez se ha establecido la restricci\u00f3n, de modo que no ocupa la posici\u00f3n que esta restricci\u00f3n est\u00e1 induciendo. Las l\u00edneas de restricci\u00f3n tambi\u00e9n aparecer\u00e1n en naranja, y el n\u00famero que indica su tama\u00f1o tendr\u00e1 un s\u00edmbolo + o - para indicar el desplazamiento. Podemos hacer que el elemento vuelva a la posici\u00f3n que indican las restricciones pulsando sobre el primero de los botones de autolayout , Update Frames . Cuando las restricciones son contradictorias , las l\u00edneas que las representan aparecen en color rojo. Por ejemplo en la siguiente figura hemos intentado especificar un espaciado de 20 puntos con el margen derecho, un ancho de 46 y adem\u00e1s que est\u00e9 centrado en horizontal. Con un tama\u00f1o de pantalla convencional esto es imposible, y as\u00ed lo indica Xcode. Cuando hay problemas con las restricciones estos se muestran tambi\u00e9n en el Document outline del storyboard. En el \u00e1ngulo superior derecho del Document outline aparece una peque\u00f1a flecha roja indicando que hay problemas, y si la pulsamos aparecer\u00e1 la lista de restricciones contradictorias e insuficientes. Podemos intentar resolver estos problemas de forma autom\u00e1tica. Para eso est\u00e1 el bot\u00f3n Resolve autolayout issues de la barra de botones de autolayout (recordar que est\u00e1 en la esquina inferior derecha del storyboard ). Hay varias posibilidades: Update frames : queremos recalcular las posiciones y dimensiones de los frames usando las restricciones actuales. Si hemos movido los elementos con el rat\u00f3n, volver\u00e1n a \u201csu posici\u00f3n\u201d. Update restrictions : si hemos movido los elementos, Xcode intentar\u00e1 recalcular las restricciones para que se correspondan con la posici\u00f3n actual. Add missing constraints : bas\u00e1ndose en la posici\u00f3n actual de los elementos, Xcode intentar\u00e1 inferir y a\u00f1adir las restricciones adecuadas para que el layout deje de ser ambiguo. Reset to suggested constraints : el equivalente a eliminar todas las restricciones ( Clear constraints ) y luego seleccionar Add missing constraints .","title":"Restricciones insuficientes o contradictorias"},{"location":"3_autolayout/apuntes/#previsualizar-el-efecto-de-las-restricciones","text":"Podemos previsualizar el efecto de las restricciones desde el propio Xcode. En la parte inferior del storyboard editor se ve el dispositivo que estamos usando actualmente, aparece algo como \"View as: iPhone XR\". Si clicamos con el rat\u00f3n en ese nombre aparecer\u00e1 una barra de herramientas para cambiar el dispositivo y/o la orientaci\u00f3n","title":"Previsualizar el efecto de las restricciones"},{"location":"3_autolayout/apuntes/#restricciones-sobre-el-tamano","text":"Aunque hemos dicho que autolayout calcula el frame de cada componente, hasta ahora hemos ignorado el tama\u00f1o de los mismos. Centrar en horizontal y vertical elimina la ambig\u00fcedad en cuanto a en qu\u00e9 coordenadas \u201canclar\u201d el frame pero \u00bfqu\u00e9 hay de su ancho y alto?. Para muchos componentes ( UILabel , UIButton , UIImage ) no es necesario especificar un tama\u00f1o ya que lo tienen por defecto (el llamado \u201ctama\u00f1o intr\u00ednseco\u201d en el argot de autolayout). En el API la propiedad correspondiente es intrinsicContentSize . Lo m\u00e1s habitual es que sea el tama\u00f1o del texto que contienen. No obstante, tambi\u00e9n podemos poner restricciones sobre el tama\u00f1o. Podemos fijar el ancho y/o el alto o el aspect ratio . Estas son restricciones del tipo pin y por tanto las podemos encontrar donde encontramos las de espaciado entre componentes (en el men\u00fa principal o en la barra de botones de autolayout). Si usamos ctrl-arrastrar con el rat\u00f3n bastar\u00e1 con que arrastremos sin salirnos del componente (al arrastrar en horizontal se nos dar\u00e1 la posibilidad de finar el ancho y lo mismo con el alto si arrastramos en vertical). Si especificamos el tama\u00f1o mediante una restricci\u00f3n podemos forzar a que el contenido del bot\u00f3n tenga que \u201ccortarse\u201d porque no cabe, o bien que tenga que a\u00f1adirse un padding al sobrar espacio.","title":"Restricciones sobre el tama\u00f1o"},{"location":"3_autolayout/apuntes/#prioridades","text":"En autolayout a veces puede haber reglas contradictorias o ambiguas. Una forma de resolver estas ambig\u00fcedades o contradicciones es mediante el uso de prioridades *.","title":"Prioridades"},{"location":"3_autolayout/apuntes/#prioridades-de-las-restricciones","text":"Cada restricci\u00f3n tiene asignada una prioridad , que es un valor num\u00e9rico que especifica su \u201cimportancia\u201d (a mayor valor, mayor prioridad): El valor por defecto es 1000, que significa que el sistema entiende que la restricci\u00f3n debe cumplirse . Valores menores que 1000 indican que el sistema intentar\u00e1 cumplir la restricci\u00f3n pero que es posible que no lo haga, si hay restricciones contradictorias de mayor prioridad. Podemos cambiar/ver la prioridad actual de la misma forma que podemos cambiar/ver el resto de propiedades de la restricci\u00f3n (ver apartado anterior).","title":"Prioridades de las restricciones"},{"location":"3_autolayout/apuntes/#prioridades-de-los-componentes","text":"Hay casos en los que puede ser necesario \"comprimir\" o \"ensanchar\" los componentes para cumplir las restricciones. En el siguiente ejemplo, estamos fijando el espacio horizontal entre componentes y de componentes a m\u00e1rgenes muy peque\u00f1o, en 8 puntos, pero para que los espacios se cumplan, alguno de los componentes, o los dos, se tendr\u00eda que ensanchar con respecto a su tama\u00f1o intr\u00ednseco: Como vemos Xcode indica que hay un problema con las restricciones, ya que el layout es ambiguo. Para cumplir las restricciones se podr\u00eda ensanchar la imagen o el label con respecto a su tama\u00f1o intr\u00ednseco. \u00bfCu\u00e1l elegir? Adem\u00e1s de las restricciones, tambi\u00e9n los componentes GUI tienen dos valores de prioridad, relativos al tama\u00f1o. El Content hugging indica la prioridad que para el componente tiene evitar el padding (o \"relleno\" o \"ensanchado\"). Por defecto tiene un valor de 251. Fijaos en que es un valor relativamente bajo, indicando que si hay reglas que lleven a aumentar el padding se tomar\u00e1n en cuenta salvo que tengan prioridad muy baja. El problema anterior se podr\u00eda resolver modificando el hugging de alguno de los dos componentes, el label o la imagen. Si subimos la prioridad de un componente haremos que se \"expanda\" el otro, y a la inversa, si la bajamos, lo haremos \"expandirse\" a \u00e9l. En el problema inverso al anterior, podr\u00edamos haber exigido que los espacios entre componentes fueran muy grandes, forzando entonces a que uno de los dos componentes se \"comprima\" (y por ejemplo en el caso del label deje de mostrar parte de su contenido). Para poder decidir cu\u00e1l de ellos tenemos la Compression resistance , que es la prioridad que para el componente tiene mostrar completo su contenido, resisti\u00e9ndose por tanto a ser comprimido. Por defecto los componentes tienen este valor a 750. De nuevo jugando con este valor podemos decidir qu\u00e9 componente se deber\u00eda comprimir. Si una regla con prioridad por defecto lleva a que el contenido de un elemento se comprima ganar\u00e1 la regla, pero no ser\u00e1 as\u00ed si su prioridad es menor que 750. N\u00f3tese que se ha escogido un valor por defecto relativamente alto para evitar que reglas \"no demasiado importantes\" lleven a que se compriman los componentes y dejen de mostrarse \"completos\" como t\u00edtulos de botones, textos de labels , etc.","title":"Prioridades de los componentes"},{"location":"3_autolayout/apuntes/#stack-views","text":"Son agrupaciones de componentes en forma de fila o columna, y se usan para crear f\u00e1cilmente layouts de elementos en disposici\u00f3n horizontal o vertical. As\u00ed solo hay que especificar las restricciones del stack view como un bloque, y no de cada componente por separado. Para crear un stack view , seleccionar varios elementos (manteniendo pulsado Command + clic del rat\u00f3n en cada uno) y luego pulsar sobre el \u00faltimo bot\u00f3n de la barra de autolayout , llamado Embed In (recordad, parte inferior derecha de la ventana del storyboard ). En el men\u00fa desplegable del bot\u00f3n, elegir Stack View . Si los componentes seleccionados estaban m\u00e1s o menos en vertical se crear\u00e1 un stack view de este tipo y lo mismo si est\u00e1n en horizontal, aunque el tipo se puede cambiar en las propiedades. Las propiedades del stack view son accesibles seleccion\u00e1ndolo con el rat\u00f3n y como siempre en el Inspector de propiedades (el icono con una escuadra, panel derecho de Xcode). Podemos indicar c\u00f3mo se reparten los componentes el espacio disponible, dejar un espacio adicional entre ellos, especificar la alineaci\u00f3n,... El Axis indica si el stack view es vertical u horizontal Alignment es la alineaci\u00f3n en la perpendicular al eje del stack view , es decir, es la alineaci\u00f3n vertical para los stack views horizontales y viceversa. Distribution se refiere c\u00f3mo se distribuyen los elementos en la direcci\u00f3n del eje del stack view","title":"Stack views"},{"location":"3_autolayout/apuntes/#alignment-y-distribution","text":"Como hemos dicho, se refiere c\u00f3mo se alinean los componentes en la perpendicular al eje del stack view . Para uno horizontal, se referir\u00e1 entonces a la alineaci\u00f3n en vertical: Fill , Top , Center o Bottom . Los valores son distintos para los stack view verticales, en este caso pueden ser Fill , Leading , Center o Trailing . En un stack view horizontal, b\u00e1sicamente la altura la determina el elemento m\u00e1s alto. Con Fill indicamos que queremos que todos los componentes tengan el mismo tama\u00f1o en Y (el del componente m\u00e1s alto). El resto de opciones son diferentes alineaciones verticales. El mismo razonamiento se puede hacer con un stack view vertical, el elemento m\u00e1s anchho y Fill . En cuanto a distribution : Fill : se llena el espacio del stack view pero cada componente puede tener un tama\u00f1o distinto Fill Equally : se llena el espacio del stack view y todos los componentes tienen el mismo tama\u00f1o (ancho para stacks horizontales y alto para verticales). Fill Proportionally : se llena el espacio del stack view , cada componente de manera proporcional a su tama\u00f1o intr\u00ednseco. Equal Spacing : el espacio entre componentes debe ser igual y como m\u00ednimo el valor de la propiedad spacing del stack view . Tambi\u00e9n podemos anidar stack views , tener unos dentro de otros, por ejemplo aqu\u00ed tenemos uno horizontal anidado dentro de una fila de uno vertical","title":"Alignment y Distribution"},{"location":"3_autolayout/apuntes/#restricciones-avanzadas","text":"Nota Esta parte es complementaria, y aunque interesante, no es necesaria para realizar los ejercicios de la sesi\u00f3n.","title":"Restricciones \"avanzadas\""},{"location":"3_autolayout/apuntes/#formulacion-matematica-de-una-restriccion","text":"Internamente, cada restricci\u00f3n se formula como una ecuaci\u00f3n lineal en la que: 1 item1.atributo1 = multiplicador * item2.atributo2 + cte Algunas restricciones no son ecuaciones sino inecuaciones , sustituyendo el s\u00edmbolo = por <= o >= . Es decir, desde el punto de vista formal, lo que hace autolayout es resolver un sistema de ecuaciones lineales. Estas propiedades podemos verlas en el Size inspector (parte derecha de la pantalla, icono de la regla ). Si seleccionamos un componente de UI aparecer\u00e1n aqu\u00ed todas sus restricciones, que podemos editar pulsando en Edit . Por ejemplo, aqu\u00ed vemos las restricciones de un bot\u00f3n centrado en el eje de las X y con un espaciado est\u00e1ndar (8 puntos) con respecto a la gu\u00eda inferior. Podemos observar en la figura las propiedades de la restricci\u00f3n, que se corresponden directamente con los coeficientes del lado derecho de la ecuaci\u00f3n lineal (el multiplicador y la constante). Adem\u00e1s aparece una prioridad , que explicaremos en el siguiente apartado. Haciendo clic en el desplegable con el s\u00edmbolo = podemos cambiar la ecuaci\u00f3n por una inecuaci\u00f3n. En nuestro ejemplo la constante es 0 y el multiplicador 1 porque queremos centrar el componente en el contenedor, es decir 1 contenedor.centerX = componente.centerX Podemos por ejemplo cambiar la constante por 50, con lo que conseguiremos que el componente est\u00e9 desplazado 50 puntos a la izquierda de la posici\u00f3n de \u201ccentrado en X\u201d. Si en lugar de seleccionar el componente GUI seleccionamos directamente una restricci\u00f3n y nos vamos al Size inspector podremos editar directamente las propiedades de la restricci\u00f3n, incluyendo tambi\u00e9n los propios atributos.","title":"Formulaci\u00f3n matem\u00e1tica de una restricci\u00f3n"},{"location":"3_autolayout/apuntes/#expresar-restricciones-usando-codigo-swift","text":"En lugar de usar el editor visual de Xcode podemos especificar las restricciones por c\u00f3digo. Esto puede resultar interesante en diversas situaciones: A veces los elementos de la interfaz se crean din\u00e1micamente y por tanto no se puede especificar el layout por adelantado en Xcode. Otras veces, aunque los elementos de la interfaz no cambien en s\u00ed puede que queramos cambiar din\u00e1micamente las restricciones para conseguir efectos din\u00e1micos de layout . Hay dos formas de hacerlo: directamente con el API de autolayout o con un mayor nivel de abstracci\u00f3n usando el llamado \u201cVisual Format Language\u201d. Si podemos elegir, la mejor forma es la segunda, ya que es mucho m\u00e1s intuitivo especificar las restricciones y entenderlas leyendo luego el c\u00f3digo.","title":"Expresar restricciones usando c\u00f3digo Swift"},{"location":"3_autolayout/ejercicios/","text":"Ejercicios de Autolayout (1,5 puntos) \u00b6 El objetivo es a\u00f1adir autolayout a la aplicaci\u00f3n de \u201cpioneras\u201d que hicimos en sesiones anteriores para que la interfaz se vea correctamente en todos los modelos de iPhone. Pantalla inicial (0,5 puntos) \u00b6 Incluye los tres botones de la pantalla principal en un stack view vertical para que estos aparezcan con el mismo tama\u00f1o (consulta la secci\u00f3n de stack view de los apuntes) Una vez hecho esto, haz que ocupen toda la pantalla sea cual sea la resoluci\u00f3n. Lo m\u00e1s sencillo es poner distancia 0 del stack view a los 4 bordes. Pantalla secundaria (0,5 puntos) \u00b6 A\u00f1adid restricciones a la pantalla secundaria (la que muestra informaci\u00f3n sobre cada pionera). Se deben cumplir las siguientes condiciones aproximadamente: El text view debe aparecer centrado horizontal y verticalmente. Debes fijar adem\u00e1s o bien su tama\u00f1o o bien la separaci\u00f3n con los bordes, queda a tu elecci\u00f3n. El bot\u00f3n debe aparecer en la parte inferior de la pantalla, a una distancia fija del borde (la que quieras), y centrado horizontalmente. Launch Screen (0,5 puntos) \u00b6 Haz un LaunchScreen.storyboard que quede como el de la siguiente imagen (mis disculpas a todos los dise\u00f1adores de interfaces :)): La imagen la puedes descargar de aqui . Crea un nuevo \"image set\" en el assets llamado \"logo\" y arr\u00e1strala all\u00ed La Image View tiene como image al \"logo\" y como content mode \"aspect fit\", para que no se deformen las proporciones Tanto la imagen como el label \"MM.UA\" est\u00e1n centrados en vertical La imagen debe tener un aspect ratio de 1:2 La imagen y el label \"MM.UA\" deben tener el mismo ancho (selecciona las dos clicando en cada una y manteniendo la tecla Cmd , y luego en el tercer bot\u00f3n de autolayout - \"Add new constraints\" tienes la restricci\u00f3n de \"equal widths\") La imagen est\u00e1 a 24 puntos del borde izquierdo, el label \"MM.UA\" a 24 del derecho y entre la imagen y el label tambi\u00e9n hay 24 puntos El label \"Universidad de Alicante\" est\u00e1 centrado en horizontal y a una distancia de 32 puntos del borde inferior de la imagen","title":"Ejercicios de *Autolayout* (1,5 puntos)"},{"location":"3_autolayout/ejercicios/#ejercicios-de-autolayout-15-puntos","text":"El objetivo es a\u00f1adir autolayout a la aplicaci\u00f3n de \u201cpioneras\u201d que hicimos en sesiones anteriores para que la interfaz se vea correctamente en todos los modelos de iPhone.","title":"Ejercicios de Autolayout (1,5 puntos)"},{"location":"3_autolayout/ejercicios/#pantalla-inicial-05-puntos","text":"Incluye los tres botones de la pantalla principal en un stack view vertical para que estos aparezcan con el mismo tama\u00f1o (consulta la secci\u00f3n de stack view de los apuntes) Una vez hecho esto, haz que ocupen toda la pantalla sea cual sea la resoluci\u00f3n. Lo m\u00e1s sencillo es poner distancia 0 del stack view a los 4 bordes.","title":"Pantalla inicial (0,5 puntos)"},{"location":"3_autolayout/ejercicios/#pantalla-secundaria-05-puntos","text":"A\u00f1adid restricciones a la pantalla secundaria (la que muestra informaci\u00f3n sobre cada pionera). Se deben cumplir las siguientes condiciones aproximadamente: El text view debe aparecer centrado horizontal y verticalmente. Debes fijar adem\u00e1s o bien su tama\u00f1o o bien la separaci\u00f3n con los bordes, queda a tu elecci\u00f3n. El bot\u00f3n debe aparecer en la parte inferior de la pantalla, a una distancia fija del borde (la que quieras), y centrado horizontalmente.","title":"Pantalla secundaria (0,5 puntos)"},{"location":"3_autolayout/ejercicios/#launch-screen-05-puntos","text":"Haz un LaunchScreen.storyboard que quede como el de la siguiente imagen (mis disculpas a todos los dise\u00f1adores de interfaces :)): La imagen la puedes descargar de aqui . Crea un nuevo \"image set\" en el assets llamado \"logo\" y arr\u00e1strala all\u00ed La Image View tiene como image al \"logo\" y como content mode \"aspect fit\", para que no se deformen las proporciones Tanto la imagen como el label \"MM.UA\" est\u00e1n centrados en vertical La imagen debe tener un aspect ratio de 1:2 La imagen y el label \"MM.UA\" deben tener el mismo ancho (selecciona las dos clicando en cada una y manteniendo la tecla Cmd , y luego en el tercer bot\u00f3n de autolayout - \"Add new constraints\" tienes la restricci\u00f3n de \"equal widths\") La imagen est\u00e1 a 24 puntos del borde izquierdo, el label \"MM.UA\" a 24 del derecho y entre la imagen y el label tambi\u00e9n hay 24 puntos El label \"Universidad de Alicante\" est\u00e1 centrado en horizontal y a una distancia de 32 puntos del borde inferior de la imagen","title":"Launch Screen (0,5 puntos)"},{"location":"4_tablas/apuntes/","text":"Tablas \u00b6 Introducci\u00f3n \u00b6 Las vistas de tabla ( UITableView ) se encargan de mostrar, gestionar y hacer scrolling de una tabla de elementos de una sola columna. Cada una de las filas se modela con un UITableViewCell . Si necesitamos m\u00e1s de una columna podemos usar UICollectionView , que ver\u00e9is en la parte \u201cavanzada\u201d de la asignatura. En las \u00faltimas versiones de iOS las funcionalidades de UICollectionView se han ampliado para permitir mostrar solo una columna. Descritas as\u00ed, puede parecer que las tablas deben desempe\u00f1ar un papel muy limitado en las aplicaciones iOS, pero nada m\u00e1s lejos de la realidad. Son la forma m\u00e1s habitual en aplicaciones m\u00f3viles de mostrar listas de elementos, no solo en iOS sino en todas las plataformas. Adem\u00e1s su aspecto visual es enormemente configurable, con lo que que muchas \"pantallas\" de apps que a primera vista no lo parecen, en realidad son tablas, por ejemplo en las aplicaciones de Mail, Ajustes, Reloj\u2026 Las tablas pueden ser simples ( UITableViewStylePlain ) o agrupadas ( UITableViewStyleGrouped ) Hay varios estilos predefinidos para las filas, que nos permiten mostrar diversos elementos: t\u00edtulo, subt\u00edtulo, icono a la izquierda, \u2026 Tambi\u00e9n podemos crear nuestros propios estilos de celda bien por c\u00f3digo o bien gr\u00e1ficamente en el interface builder . Creaci\u00f3n de vistas de tabla \u00b6 Una vista de tabla interact\u00faa b\u00e1sicamente con tres objetos. Pueden ser distintos o puede ser el mismo objeto que desempe\u00f1e m\u00e1s de un papel: En primer lugar, el view controller . Ya hemos visto el papel que hace en las aplicaciones. En segundo lugar, el data source : las vistas de tabla solo almacenan directamente los datos de las filas actualmente visibles en pantalla. El resto se los piden a un objeto que debe ser conforme al protocolo UITableViewDataSource . Este es obligatorio, no podemos crear una tabla sin \u00e9l. Y finalmente el delegate : para gestionar algunos eventos de manipulaci\u00f3n de la tabla (como la edici\u00f3n, el borrado, o el mover una fila) y controlar algunos aspectos de la apariencia de las celdas, se usa el UITableViewDelegate Es muy habitual, al menos en los casos m\u00e1s simples, que el controller , el delegate y el data source sean el mismo objeto. Si usamos una vista de tabla dibujada en el storyboard podemos conectarla con los dos \u201ccolaboradores\u201d gr\u00e1ficamente mediante el \u201cConnections Inspector\u201d del panel \u201cUtilities\u201d. La otra opci\u00f3n es establecer la conexi\u00f3n por c\u00f3digo, fijando ciertas propiedades de la tabla, que luego veremos. Tablas est\u00e1ticas \u00b6 En algunos casos conocemos de partida los elementos que queremos dibujar en la tabla. Ejemplo t\u00edpico de esto es la aplicaci\u00f3n de Ajustes , en la que las opciones est\u00e1n colocadas en una tabla simplemente para que est\u00e9n m\u00e1s organizadas y tengan un formato atractivo. Esto lo podemos conseguir con una tabla est\u00e1tica . Para crear una pantalla con una tabla est\u00e1tica arrastramos un Table View Controller al storyboard . Es un controller asociado a una vista de tabla que ocupa toda la pantalla del dispositivo. Por defecto usa una tabla din\u00e1mica, pero podemos cambiarlo seleccionando la tabla en el Attributes inspector y seleccionando Static Cells en la primera propiedad, Content . Podemos a\u00f1adir secciones a la tabla y cambiar el n\u00famero de celdas en cada secci\u00f3n. Para poder cambiar el n\u00famero de celdas hay que tener seleccionada la secci\u00f3n deseada, lo que a veces es dif\u00edcil con el rat\u00f3n, por lo que podemos usar los nodos del Document outline : Podemos aumentar el n\u00famero de celdas de modo que no quepan en la pantalla. Para desplazarnos por la tabla podemos seleccionarla y hacer scroll con la rueda del rat\u00f3n Tablas din\u00e1micas \u00b6 En este tipo de tablas los datos son din\u00e1micos: no se conocen por adelantado cuando se est\u00e1 dise\u00f1ando la aplicaci\u00f3n y suelen proceder de alguna fuente externa como una base de datos o un servidor. Vamos a ver primero c\u00f3mo crear la tabla en s\u00ed y luego el objeto que va a ocuparse de los datos que queremos mostrar en la tabla El objeto Tabla \u00b6 La tabla en s\u00ed es una componente m\u00e1s de interfaz de usuario, como un bot\u00f3n, un slider ,\u2026 Para crear una tabla, arrastramos un table view desde la librer\u00eda de componentes de la parte inferior derecha de Xcode Cuidado: no us\u00e9is para este caso un table view controller sino un table view . El primero incluye no solo la tabla en s\u00ed sino tambi\u00e9n un controller , y la tabla ocupa todo el tama\u00f1o de la pantalla y no se puede cambiar de tama\u00f1o. Una vez creada la tabla, nos vamos al attributes inspector (icono , en la parte superior derecha de Xcode) y hacemos que el Content sea Dynamic prototypes y el n\u00famero de Prototype cells al menos 1. Veremos que en la tabla aparece una \u201csecci\u00f3n\u201d titulada Prototype cells . En esta aparecen los prototypes o plantillas en las que se basar\u00e1n las celdas de nuestra tabla. En muchas tablas todas las celdas son iguales y por eso nos basta con un prototipo, pero podemos crear los necesarios. Para editar gr\u00e1ficamente el prototipo basta con seleccionarlo con el rat\u00f3n y editarlo cambiando sus atributos con el attributes inspector . El m\u00e1s importante es el Style . Podemos usar uno propio ( Custom ) o uno de los predefinidos Para cada estilo tenemos una serie de elementos con los que podemos \u201cjugar\u201d: un t\u00edtulo, una imagen, en algunos casos un texto adicional\u2026. En general, como queremos que el contenido concreto de la celda sea distinto para cada una, lo que haremos ser\u00e1 fijarlos por c\u00f3digo. Aqu\u00ed solo elegimos el aspecto general y si ciertos elementos estar\u00e1n o no presentes. Por ejemplo en el estilo basic la celda solo contiene un texto, mientras que en el detail contiene uno m\u00e1s grande y otro m\u00e1s peque\u00f1o. Otro atributo importante es el reuse identifier , donde escribiremos un identificador inventado por nosotros para este prototipo. Cuando hablemos del datasource veremos d\u00f3nde referenciar este identificador en nuestro c\u00f3digo. La fuente de datos o datasource \u00b6 En iOS se usa el patr\u00f3n delegaci\u00f3n para delegar en otro objeto distinto a la propia tabla la responsabilidad de devolver los datos cuando es necesario pintarlos en pantalla. Este delegado se denomina en iOS datasource . Cuando iOS necesite pintar una celda le pedir\u00e1 al datasource que se la devuelva rellenada con sus contenidos. El datasource puede ser cualquier objeto con tal de que implemente el protocol UITableViewDataSource . En los ejemplos m\u00e1s sencillos habitualmente es el controller de la pantalla en la que est\u00e1 la tabla, aunque este enfoque suele llevar a que acabe habiendo demasiado c\u00f3digo en el controller . Por ello nosotros vamos a usar otra clase adicional Implementar el datasource \u00b6 Como hemos dicho, nuestro objeto debe implementar el protocolo UITableViewDataSource . Este protocolo tiene dos m\u00e9todos obligatorios: Un m\u00e9todo que dado un n\u00famero de secci\u00f3n nos devuelva cu\u00e1ntas filas hay en esa secci\u00f3n. Un m\u00e9todo que dado un n\u00famero de fila nos devuelva una UITableViewCell , que es un objeto de interfaz de usuario que representa una celda. Dicho objeto contiene b\u00e1sicamente el texto a mostrar en la celda, m\u00e1s alguna informaci\u00f3n adicional. Como vemos, son dos tareas que puede y debe hacer el objeto que controle los datos a mostrar, otro objeto no tendr\u00eda esta informaci\u00f3n. Antes de empezar a implementar los m\u00e9todos tendremos que indicar que nuestra clase implementa el protocolo UITableViewDataSource . Un requisito adicional, \u201cfruto\u201d de la \u201cera\u201d de Objective-C es que el datasource debe heredar de la clase Obj-C NSObject , definida en el framework Foundation , as\u00ed que el esqueleto inicial de nuestra clase ser\u00eda algo como: class MiDataSource : NSObject , UITableViewDataSource { //Definici\u00f3n de la clase } Si usamos un view controller como datasource , como es habitual en la mayor\u00eda de ejemplos que ver\u00e1s en libros y en tutoriales en la web, no ser\u00e1 necesario especificar la herencia de NSObject porque los controller ya heredan por defecto de esta clase. Vamos a hacer un ejemplo sencillo en el que cada celda simplemente muestra el n\u00famero de fila en que est\u00e1, y tenemos 1000 celdas. En un ejemplo algo m\u00e1s realista, los datos estar\u00edan almacenados en una BD, o bien en un array en memoria. El m\u00e9todo que devuelve el n\u00famero de celdas para una secci\u00f3n debe tener la signatura tableView(_:, numberOfRowsInSection:) . Aqu\u00ed tenemos la implementaci\u00f3n para nuestro ejemplo sencillo, que devolver\u00e1 simplemente 1000. En una BD tendr\u00edamos que devolver el n\u00famero de registros, o en un array su propiedad count func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return 1000 } El m\u00e9todo que devuelve una celda dada una fila debe tener la signatura tableView(_:, cellForRowAt:) , y es algo m\u00e1s complicado que el anterior. Vamos a ver primero una implementaci\u00f3n \u201cingenua\u201d, que simplemente crea la UITableViewCell , la rellena de contenido y la devuelve. En un momento veremos que este c\u00f3digo es muy ineficiente y no deber\u00edamos usarlo tal cual en una aplicaci\u00f3n real . Pero por el momento nos sirve para discutir qu\u00e9 significan los par\u00e1metros y c\u00f3mo construir un objeto celda. func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { //instanciamos una nueva celda let celda = UITableViewCell ( style : . default , reuseIdentifier : \"\" ) //la rellenamos de contenido celda . textLabel ?. text = \"Celda n\u00famero \\( indexPath . row ) \" return celda } Algunas consideraciones sobre el c\u00f3digo anterior: - Un IndexPath es un struct que almacena informaci\u00f3n sobre la posici\u00f3n de una celda. Contiene b\u00e1sicamente el n\u00famero de fila (propiedad row ) y el n\u00famero de secci\u00f3n (propiedad section . Ignoramos este \u00faltimo ya que nuestro ejemplo tiene una \u00fanica secci\u00f3n. - Al inicializador de UITableViewCell le pasamos el estilo de la celda (en principio de entre los predefinidos) y luego el reuseIdentifier , que luego veremos qu\u00e9 es. De momento pasamos la cadena vac\u00eda. Lo que acabamos de hacer, crear un nuevo UITableViewCell por cada fila es muy ineficiente dado que una tabla puede tener cientos o miles de ellas. Por eso se suele usar un truco ingenioso: se crea un peque\u00f1o n\u00famero de celdas (las que se ven simult\u00e1neamente en pantalla) y luego se reutilizan conforme se va haciendo scroll por la tabla, rellen\u00e1ndolas con los nuevos datos. iOS ofrece soporte para esta reutilizaci\u00f3n manteniendo un pool de celdas que podemos reutilizar para rellenar con nuevos datos. Podemos sacar una celda del pool con el m\u00e9todo de la vista de tabla dequeueReusableCell(withIdentifier:) . El identificador sirve para etiquetar el \u201ctipo\u201d de celda. En casos m\u00e1s complicados podr\u00edamos tener varios pool con distintos tipos de celda para reutilizar. En el ejemplo usaremos un \u00fanico identificador (es arbitrario y lo elige el desarrollador). MUY IMPORTANTE: el identificador del reuseIdentifier debe ser el mismo que elegimos gr\u00e1ficamente al editar el prototipo de la celda. Si no fallar\u00e1 nuestro c\u00f3digo La nueva versi\u00f3n del c\u00f3digo queda as\u00ed: func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let nuevaCelda = tableView . dequeueReusableCell ( withIdentifier : \"unaCelda\" , for : indexPath ) nuevaCelda . textLabel ?. text = datos [ indexPath . row ] return nuevaCelda } Conectar la tabla y el datasource \u00b6 Podemos hacer la conexi\u00f3n usando dos m\u00e9todos alternativos: gr\u00e1ficamente o por c\u00f3digo. Cuando el datasource es una clase adicional es algo m\u00e1s sencillo por c\u00f3digo. Cuando es el controller la forma m\u00e1s directa es la gr\u00e1fica. Como en el ejemplo de la secci\u00f3n anterior hemos hecho que el datasource sea una clase adicional, vamos a ver en primer lugar c\u00f3mo se har\u00eda la conexi\u00f3n por c\u00f3digo . Basta con asignar la propiedad dataSource del objeto tabla a una instancia de nuestro objeto datasource . Por ejemplo podr\u00edamos hacer la asignaci\u00f3n en el viewDidLoad() del controller de la pantalla donde est\u00e1 la tabla: //Este outlet lo habr\u00edamos creado gr\u00e1ficamente con Xcode @IBOutlet weak var miTabla : UITableView ! //guardamos el datasource como una propiedad del controller var miDS : MiDataSource ! override func viewDidLoad () { super . viewDidLoad () self . miDS = MiDataSource () //asignamos el datasource como el delegado de la tabla self . miTabla . dataSource = miDS } En el c\u00f3digo anterior puede parecer que podr\u00edamos ahorrarnos la variable miDS y asignar directamente el dataSource a una nueva instancia, es decir self.miTabla.dataSource = MiDataSource() . Pero esto no funcionar\u00e1 y la tabla aparecer\u00e1 vac\u00eda. Si consultamos la documentaci\u00f3n del API de iOS veremos que la propiedad dataSource es weak , lo que significa que si el objeto referenciado por ella no est\u00e1 referenciado por ninguna variable m\u00e1s, iOS considerar\u00e1 que puede liberar la memoria ocupada por \u00e9l. En consecuencia el dataSource se quedar\u00eda vac\u00edo y no aparecer\u00edan los datos. En el c\u00f3digo anterior accedemos al objeto tabla con un outlet creado previamente en Xcode de modo gr\u00e1fico, pero esto no parece tener mucho sentido si hemos dicho que \u00edbamos a establecer la conexi\u00f3n por c\u00f3digo. Si no estamos usando el outlet para alguna tarea adicional, una alternativa ser\u00eda asignar un tag fijo a la tabla (por ejemplo 100) y acceder a ella con self.view.viewWithTag(tag:100) Otra alternativa a lo anterior es hacer la conexi\u00f3n con Xcode. Para conectar gr\u00e1ficamente la tabla con el datasource primero necesitamos tener una \u201crepresentaci\u00f3n gr\u00e1fica\u201d en pantalla del objeto MiDataSource con el que queremos conectar. Podemos arrastrar a la pantalla un Object de la librer\u00eda de objetos de la parte inferior derecha de Xcode. Este es como si fuera un componente m\u00e1s de la interfaz gr\u00e1fica pero no tiene representaci\u00f3n en pantalla. En lugar de arrastrarlo a la pantalla en s\u00ed como ocurre con los componentes gr\u00e1ficos convencionales, debemos arrastrarlo al \u00e1rbol de componentes que aparece a su izquierda Una vez colocado aqu\u00ed, vamos a indicar que este objeto es de la clase MiDataSource . Para ello usamos el Identity inspector , y en la propiedad Custom class escribimos el nombre de la clase Ya podemos conectar la propiedad dataSource de la tabla con este objeto. La propiedad la podemos ver si seleccionamos la tabla con el rat\u00f3n y vamos al Connections inspector (el icono del \u00e1rea de Utilities ). Arrastramos con el rat\u00f3n (no hace falta Ctrl ) desde el c\u00edrculo que representa al datasource hasta el icono del objeto que representa a la clase MiDataSource Gesti\u00f3n de tablas \u00b6 En las tablas din\u00e1micas podemos por supuesto insertar y eliminar celdas. Tambi\u00e9n podemos seleccionarlas haciendo tap sobre ellas. Para evitar que la propia tabla se tenga que hacer cargo de estas tareas se usa de nuevo el patr\u00f3n delegaci\u00f3n : designamos una instancia de una clase determinada que se encargar\u00e1 de procesar la inserci\u00f3n y el borrado. Esta instancia se le debe asignar a la propiedad delegate de la tabla, bien por c\u00f3digo o bien gr\u00e1ficamente, como hac\u00edamos en el caso del dataSource . Aunque la tarea primaria es cosa del delegate , el dataSource ser\u00e1 avisado si se va a insertar o eliminar alguna celda, para que procese los datos El delegate tendr\u00e1 que ser de una clase que implemente el protocolo UITableViewDelegate . Este protocolo proporciona m\u00e9todos para manejar secciones de la tabla, configurar las cabeceras y pies de cada secci\u00f3n, gestionar qu\u00e9 hacer cuando se selecciona una celda, insertar, eliminar y reordenar celdas, y algunas otras tareas. En casi todos los ejemplos que ver\u00e9is en libros y en la web se suele hacer que el controller act\u00fae de delegate para simplificar el c\u00f3digo y reducir el n\u00famero de clases del ejemplo, pero a cambio complicamos el c\u00f3digo del controller . El c\u00f3digo de una clase que act\u00fae de delegate de tabla debe tener el siguiente esqueleto b\u00e1sico. Al igual que en el caso del dataSource , la herencia de NSObject es a su vez \u201cherencia\u201d de la \u00e9poca de Objective-C import Foundation import UIKit class MiDelegate : NSObject , UITableViewDelegate { //definici\u00f3n de la clase } En los siguientes apartados solo vamos a discutir c\u00f3mo implementar los m\u00e9todos del protocolo UITableViewDelegate , no c\u00f3mo hacer la conexi\u00f3n entre la tabla y el delegate , ya que la conexi\u00f3n se hace pr\u00e1cticamente igual que cuando habl\u00e1bamos del datasource , sea por c\u00f3digo o gr\u00e1ficamente. Seleccionar celdas \u00b6 Cuando el usuario selecciona una celda haciendo tap sobre ella se llama al m\u00e9todo tableView(_: didSelectRowAt:) del delegate . Como ejemplo vamos a ver c\u00f3mo implementar\u00edamos este m\u00e9todo de forma que cuando se seleccione una celda se ponga en ella una marca de verificaci\u00f3n, y que si ya est\u00e1 se quite. En las celdas predefinidas, esta marca (y otras similares) se controla con la propiedad accessoryType de la celda. func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let celda = tableView . cellForRow ( at : indexPath ) { //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos if celda . accessoryType == UITableViewCell . AccessoryType . none { celda . accessoryType = . checkmark } else { celda . accessoryType = . none } //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris tableView . deselectRow ( at : indexPath , animated : true ) } } Insertar y eliminar filas \u00b6 iOS nos ofrece de forma autom\u00e1tica el \u201cmodo edici\u00f3n\u201d, en el que en la parte izquierda de cada celda aparece un icono indicador de las operaciones que se pueden hacer con ella. Hay dos indicadores: Una se\u00f1al de \"prohibido\" para poder borrar la celda (pulsando sobre la se\u00f1al y luego sobre el bot\u00f3n \u201cBorrar\u201d que aparece). Un s\u00edmbolo de \u2018+\u2019 que sirve para insertar una nueva celda Podemos activar el modo edici\u00f3n con el m\u00e9todo setEditing del objeto tabla: 1 2 // suponemos que \"miTabla\" es un outlet a la tabla self . miTabla . setEditing ( true , animated : true ); Por defecto al activar el modo edici\u00f3n en todas las celdas aparecer\u00e1 la se\u00f1al de \u201cprohibido\u201d. Implementando en el delegate el m\u00e9todo tableView(_:,editingStyleForRowAt:) podemos especificar qu\u00e9 tipo de estilo de edici\u00f3n queremos para una celda determinada. El sistema nos \u201cpreguntar\u00e1\u201d el estilo de edici\u00f3n para un n\u00famero de celda y debemos devolver UITableViewCellEditingStyle.delete o bien UITableViewCellEditingStyle.insert . Aunque el modo edici\u00f3n es autom\u00e1tico, el borrado efectivo de las celdas y de su contenido lo tenemos que hacer nosotros, al igual que la inserci\u00f3n. iOS avisar\u00e1 al datasource de que se est\u00e1 intentando insertar o eliminar una celda, NO al delegate . Esto es l\u00f3gico ya que los datos los gestiona el datasource . As\u00ed, cuando se pulse sobre el y luego sobre \u201cdelete\u201d o sobre el , se llamar\u00e1 al m\u00e9todo del datasource llamado tableView(_:, commit:, forRowAt:) . En este m\u00e9todo tenemos que hacer dos cosas: Actualizar los datos (borrar el dato o insertar uno nuevo) Llamar a un m\u00e9todo del API de la tabla para que esta inserci\u00f3n o borrado se represente de manera visual (que gr\u00e1ficamente aparezca o desaparezca la celda) Es muy importante destacar que primero hay que actualizar los datos y luego ocuparse de la parte gr\u00e1fica. Si lo hacemos al rev\u00e9s no funcionar\u00e1 bien, ya que iOS intentar\u00e1 redibujar la tabla usando los datos \u201cantiguos\u201d. Simplemente implementando el siguiente m\u00e9todo (aunque estuviera vac\u00edo) activaremos el swipe to delete , pero el bot\u00f3n delete no va a funcionar salvo que implementemos el borrado como aqu\u00ed se muestra func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCell . EditingStyle , forRowAt indexPath : IndexPath ) { if editingStyle == UITableViewCell . EditingStyle . delete { self . datos . remove ( at : indexPath . row ) tableView . deleteRows ( at : [ indexPath ], with : UITableView . RowAnimation . fade ) } else if editingStyle == UITableViewCell . EditingStyle . insert { self . datos . insert ( \"Nueva celda\" , at : indexPath . row ) tableView . insertRows ( at : [ indexPath ], with : UITableView . RowAnimation . bottom ) } } N\u00f3tese que los m\u00e9todos insertRows y deleteRows permiten insertar o borrar varias celdas a la vez y por ello como primer par\u00e1metro requieren un array de indexPath , y no un indexPath directamente. Si insertamos/borramos una \u00fanica celda ser\u00e1 un array de un \u00fanico componente. Esto que hemos visto se aplica a cuando la inserci\u00f3n o eliminaci\u00f3n las dispara el propio iOS pulsando en los botones del sistema. Pero tambi\u00e9n podemos disparar nosotros manualmente la inserci\u00f3n o eliminaci\u00f3n. Por ejemplo veamos c\u00f3mo se insertar\u00eda una nueva celda \u201cmanualmente\u201d al principio de la tabla. //primero hay que actualizar los datos self . datos . insert ( \"Nueva celda\" , at : 0 ) //y ahora visualmente insertar la celda let indexPath = IndexPath ( row : 0 , section : 0 ) //suponemos que tenemos accesible la tabla, la necesitamos tabla . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . fade ) Diffable Data Sources \u00b6 Como hemos visto, el encargado de gestionar los datos mostrados en la tabla y sincronizar el estado de la propia interfaz es el propio programador. Pero esto da lugar a c\u00f3digo tedioso y propenso a errores. Ser\u00eda mucho mejor que iOS se encargara de seguir autom\u00e1ticamente la pista de los datos si estos cambian y actualizara visualmente la tabla de manera autom\u00e1tica. Esto lo podemos conseguir con los Diffable Data Sources , que se introdujeron en iOS13. Para crear un Diffable Data Source necesitamos especificar: El tipo de los items de la tabla. Adem\u00e1s este debe ser conforme al protocolo hashable (lo son autom\u00e1ticamente tipos b\u00e1sicos como String o Int, luego veremos qu\u00e9 implicaciones tiene esto) El tipo de las secciones de la tabla. En iOS por defecto son simplemente enteros, pero aqu\u00ed podemos especificar el tipo que queramos (siempre que como antes, sea hashable ) La UITableView asociada al data source El c\u00f3digo que crea cada celda (lo que hac\u00edamos en el m\u00e9todo tableView(_:, cellForRowAt:) ) Por ejemplo, supongamos para simplificar que los identificadores de secci\u00f3n van a ser enteros y los datos de la tabla String s. Podr\u00edamos crear nuestro diffable data source como sigue: class MiDiffableDS : UITableViewDiffableDataSource < Int , String > { init ( tabla : UITableView ) { super . init ( tableView : tabla , cellProvider : { tableView , indexPath , item in let cell = tableView . dequeueReusableCell ( withIdentifier : \"miCelda\" , for : indexPath ) cell . textLabel ?. text = item return cell }) } } cosas interesantes: Nuestra clase hereda de UITableViewDiffableDataSource , que es la clase base de los diffable data sources en iOS. Esta clase es gen\u00e9rica y est\u00e1 parametrizada por <TipoDeSeccion, TipoDeItem> , en nuestro caso Int y String como ya hemos dicho En el constructor de la clase base hay que pasar como par\u00e1metros: La UITableView asociada. Aqu\u00ed es donde se hace la conexi\u00f3n entre datasource y tabla. En nuestro ejemplo este par\u00e1metro se lo pasamos al inicializador de la clase derivada, as\u00ed se lo podemos pasar desde el controller que es el \"due\u00f1o\" de la tabla. en cellProvider pasamos una clausura que b\u00e1sicamente es la implementaci\u00f3n que hac\u00edamos antes del tableView(_:, cellForRowAt:) (obtener la celda reutilizada, rellenarla de datos y devolverla) Si no queremos \"molestarnos\" en definir una clase propia tambi\u00e9n podemos crear directamente una instancia de la clase base y luego asign\u00e1rsela a la tabla como su datasouce: //suponiendo que el UITableView se llame \"tabla\" //Este c\u00f3digo podr\u00eda estar en el viewDidLoad del controller let miDataSource = UITableViewDiffableDataSource < Int , String >( tableview : miTabla , //cellProvider igual que antes ... ) miTabla . dataSource = miDataSource De momento no hemos sacado ning\u00fan beneficio apreciable de usar un diffable data source . Los beneficios empiezan cuando queremos modificar los datos asociados a la tabla. La idea es que el conjunto de datos se representa con lo que se llama un snapshot , que podemos modificar (crear de nuevo, a\u00f1adir datos, borrar datos,...). Una vez modificado el snapshot llamamos al m\u00e9todo apply sobre el datasource para que visualmente se apliquen los cambios correspondientes. Por ejemplo podr\u00edamos inicializar los datos como sigue: var snapshot = NSDiffableDataSourceSnapshot < Int , String >() snapshot . appendSections ([ 0 ]) snapshot . appendItems ([ \"uno\" , \"dos\" , \"tres\" ], toSection : 0 ) ds . apply ( snapshot , animatingDifferences : false ) Como vemos en este ejemplo, podemos a\u00f1adir secciones a la tabla e items dentro de cada secci\u00f3n. Al llamar a apply se actualizar\u00e1 la tabla, con una animaci\u00f3n si el par\u00e1metro animatingDifferences es true . En el snapshot tenemos m\u00e9todos para insertar, modificar o eliminar items, por ejemplo: //aqu\u00ed ds ser\u00eda el diffable data source que hemos creado var snapshot = ds . snapshot () snapshot . deleteItems ([ \"uno\" ]) ds . apply ( snapshot ) Los items se borran especificando un id , que en el caso de un tipo simple como String se corresponde con el propio contenido. La tabla se actualizar\u00e1 autom\u00e1ticamente tras el apply . Para implementar el borrado de celdas haciendo tap sobre ellas en el modo edici\u00f3n tendremos que sobreescribir el m\u00e9todo tableView(_,commit:,atIndexPath:) en nuestro diffable data source : override func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCell . EditingStyle , forRowAt indexPath : IndexPath ) { var snapshot = self . snapshot () if let item = itemIdentifier ( for : indexPath ) { snapshot . deleteItems ([ item ]) apply ( snapshot ) } } La diferencia es que ahora no tenemos que actualizar visualmente la tabla, solo modificar el snapshot y aplicarlo al datasource . Para saber qu\u00e9 item est\u00e1 en la posici\u00f3n indexPath usamos el m\u00e9todo itemIdentifier .","title":"Tablas"},{"location":"4_tablas/apuntes/#tablas","text":"","title":"Tablas"},{"location":"4_tablas/apuntes/#introduccion","text":"Las vistas de tabla ( UITableView ) se encargan de mostrar, gestionar y hacer scrolling de una tabla de elementos de una sola columna. Cada una de las filas se modela con un UITableViewCell . Si necesitamos m\u00e1s de una columna podemos usar UICollectionView , que ver\u00e9is en la parte \u201cavanzada\u201d de la asignatura. En las \u00faltimas versiones de iOS las funcionalidades de UICollectionView se han ampliado para permitir mostrar solo una columna. Descritas as\u00ed, puede parecer que las tablas deben desempe\u00f1ar un papel muy limitado en las aplicaciones iOS, pero nada m\u00e1s lejos de la realidad. Son la forma m\u00e1s habitual en aplicaciones m\u00f3viles de mostrar listas de elementos, no solo en iOS sino en todas las plataformas. Adem\u00e1s su aspecto visual es enormemente configurable, con lo que que muchas \"pantallas\" de apps que a primera vista no lo parecen, en realidad son tablas, por ejemplo en las aplicaciones de Mail, Ajustes, Reloj\u2026 Las tablas pueden ser simples ( UITableViewStylePlain ) o agrupadas ( UITableViewStyleGrouped ) Hay varios estilos predefinidos para las filas, que nos permiten mostrar diversos elementos: t\u00edtulo, subt\u00edtulo, icono a la izquierda, \u2026 Tambi\u00e9n podemos crear nuestros propios estilos de celda bien por c\u00f3digo o bien gr\u00e1ficamente en el interface builder .","title":"Introducci\u00f3n"},{"location":"4_tablas/apuntes/#creacion-de-vistas-de-tabla","text":"Una vista de tabla interact\u00faa b\u00e1sicamente con tres objetos. Pueden ser distintos o puede ser el mismo objeto que desempe\u00f1e m\u00e1s de un papel: En primer lugar, el view controller . Ya hemos visto el papel que hace en las aplicaciones. En segundo lugar, el data source : las vistas de tabla solo almacenan directamente los datos de las filas actualmente visibles en pantalla. El resto se los piden a un objeto que debe ser conforme al protocolo UITableViewDataSource . Este es obligatorio, no podemos crear una tabla sin \u00e9l. Y finalmente el delegate : para gestionar algunos eventos de manipulaci\u00f3n de la tabla (como la edici\u00f3n, el borrado, o el mover una fila) y controlar algunos aspectos de la apariencia de las celdas, se usa el UITableViewDelegate Es muy habitual, al menos en los casos m\u00e1s simples, que el controller , el delegate y el data source sean el mismo objeto. Si usamos una vista de tabla dibujada en el storyboard podemos conectarla con los dos \u201ccolaboradores\u201d gr\u00e1ficamente mediante el \u201cConnections Inspector\u201d del panel \u201cUtilities\u201d. La otra opci\u00f3n es establecer la conexi\u00f3n por c\u00f3digo, fijando ciertas propiedades de la tabla, que luego veremos.","title":"Creaci\u00f3n de vistas de tabla"},{"location":"4_tablas/apuntes/#tablas-estaticas","text":"En algunos casos conocemos de partida los elementos que queremos dibujar en la tabla. Ejemplo t\u00edpico de esto es la aplicaci\u00f3n de Ajustes , en la que las opciones est\u00e1n colocadas en una tabla simplemente para que est\u00e9n m\u00e1s organizadas y tengan un formato atractivo. Esto lo podemos conseguir con una tabla est\u00e1tica . Para crear una pantalla con una tabla est\u00e1tica arrastramos un Table View Controller al storyboard . Es un controller asociado a una vista de tabla que ocupa toda la pantalla del dispositivo. Por defecto usa una tabla din\u00e1mica, pero podemos cambiarlo seleccionando la tabla en el Attributes inspector y seleccionando Static Cells en la primera propiedad, Content . Podemos a\u00f1adir secciones a la tabla y cambiar el n\u00famero de celdas en cada secci\u00f3n. Para poder cambiar el n\u00famero de celdas hay que tener seleccionada la secci\u00f3n deseada, lo que a veces es dif\u00edcil con el rat\u00f3n, por lo que podemos usar los nodos del Document outline : Podemos aumentar el n\u00famero de celdas de modo que no quepan en la pantalla. Para desplazarnos por la tabla podemos seleccionarla y hacer scroll con la rueda del rat\u00f3n","title":"Tablas est\u00e1ticas"},{"location":"4_tablas/apuntes/#tablas-dinamicas","text":"En este tipo de tablas los datos son din\u00e1micos: no se conocen por adelantado cuando se est\u00e1 dise\u00f1ando la aplicaci\u00f3n y suelen proceder de alguna fuente externa como una base de datos o un servidor. Vamos a ver primero c\u00f3mo crear la tabla en s\u00ed y luego el objeto que va a ocuparse de los datos que queremos mostrar en la tabla","title":"Tablas din\u00e1micas"},{"location":"4_tablas/apuntes/#el-objeto-tabla","text":"La tabla en s\u00ed es una componente m\u00e1s de interfaz de usuario, como un bot\u00f3n, un slider ,\u2026 Para crear una tabla, arrastramos un table view desde la librer\u00eda de componentes de la parte inferior derecha de Xcode Cuidado: no us\u00e9is para este caso un table view controller sino un table view . El primero incluye no solo la tabla en s\u00ed sino tambi\u00e9n un controller , y la tabla ocupa todo el tama\u00f1o de la pantalla y no se puede cambiar de tama\u00f1o. Una vez creada la tabla, nos vamos al attributes inspector (icono , en la parte superior derecha de Xcode) y hacemos que el Content sea Dynamic prototypes y el n\u00famero de Prototype cells al menos 1. Veremos que en la tabla aparece una \u201csecci\u00f3n\u201d titulada Prototype cells . En esta aparecen los prototypes o plantillas en las que se basar\u00e1n las celdas de nuestra tabla. En muchas tablas todas las celdas son iguales y por eso nos basta con un prototipo, pero podemos crear los necesarios. Para editar gr\u00e1ficamente el prototipo basta con seleccionarlo con el rat\u00f3n y editarlo cambiando sus atributos con el attributes inspector . El m\u00e1s importante es el Style . Podemos usar uno propio ( Custom ) o uno de los predefinidos Para cada estilo tenemos una serie de elementos con los que podemos \u201cjugar\u201d: un t\u00edtulo, una imagen, en algunos casos un texto adicional\u2026. En general, como queremos que el contenido concreto de la celda sea distinto para cada una, lo que haremos ser\u00e1 fijarlos por c\u00f3digo. Aqu\u00ed solo elegimos el aspecto general y si ciertos elementos estar\u00e1n o no presentes. Por ejemplo en el estilo basic la celda solo contiene un texto, mientras que en el detail contiene uno m\u00e1s grande y otro m\u00e1s peque\u00f1o. Otro atributo importante es el reuse identifier , donde escribiremos un identificador inventado por nosotros para este prototipo. Cuando hablemos del datasource veremos d\u00f3nde referenciar este identificador en nuestro c\u00f3digo.","title":"El objeto Tabla"},{"location":"4_tablas/apuntes/#la-fuente-de-datos-o-datasource","text":"En iOS se usa el patr\u00f3n delegaci\u00f3n para delegar en otro objeto distinto a la propia tabla la responsabilidad de devolver los datos cuando es necesario pintarlos en pantalla. Este delegado se denomina en iOS datasource . Cuando iOS necesite pintar una celda le pedir\u00e1 al datasource que se la devuelva rellenada con sus contenidos. El datasource puede ser cualquier objeto con tal de que implemente el protocol UITableViewDataSource . En los ejemplos m\u00e1s sencillos habitualmente es el controller de la pantalla en la que est\u00e1 la tabla, aunque este enfoque suele llevar a que acabe habiendo demasiado c\u00f3digo en el controller . Por ello nosotros vamos a usar otra clase adicional","title":"La fuente de datos o datasource"},{"location":"4_tablas/apuntes/#gestion-de-tablas","text":"En las tablas din\u00e1micas podemos por supuesto insertar y eliminar celdas. Tambi\u00e9n podemos seleccionarlas haciendo tap sobre ellas. Para evitar que la propia tabla se tenga que hacer cargo de estas tareas se usa de nuevo el patr\u00f3n delegaci\u00f3n : designamos una instancia de una clase determinada que se encargar\u00e1 de procesar la inserci\u00f3n y el borrado. Esta instancia se le debe asignar a la propiedad delegate de la tabla, bien por c\u00f3digo o bien gr\u00e1ficamente, como hac\u00edamos en el caso del dataSource . Aunque la tarea primaria es cosa del delegate , el dataSource ser\u00e1 avisado si se va a insertar o eliminar alguna celda, para que procese los datos El delegate tendr\u00e1 que ser de una clase que implemente el protocolo UITableViewDelegate . Este protocolo proporciona m\u00e9todos para manejar secciones de la tabla, configurar las cabeceras y pies de cada secci\u00f3n, gestionar qu\u00e9 hacer cuando se selecciona una celda, insertar, eliminar y reordenar celdas, y algunas otras tareas. En casi todos los ejemplos que ver\u00e9is en libros y en la web se suele hacer que el controller act\u00fae de delegate para simplificar el c\u00f3digo y reducir el n\u00famero de clases del ejemplo, pero a cambio complicamos el c\u00f3digo del controller . El c\u00f3digo de una clase que act\u00fae de delegate de tabla debe tener el siguiente esqueleto b\u00e1sico. Al igual que en el caso del dataSource , la herencia de NSObject es a su vez \u201cherencia\u201d de la \u00e9poca de Objective-C import Foundation import UIKit class MiDelegate : NSObject , UITableViewDelegate { //definici\u00f3n de la clase } En los siguientes apartados solo vamos a discutir c\u00f3mo implementar los m\u00e9todos del protocolo UITableViewDelegate , no c\u00f3mo hacer la conexi\u00f3n entre la tabla y el delegate , ya que la conexi\u00f3n se hace pr\u00e1cticamente igual que cuando habl\u00e1bamos del datasource , sea por c\u00f3digo o gr\u00e1ficamente.","title":"Gesti\u00f3n de tablas"},{"location":"4_tablas/apuntes/#seleccionar-celdas","text":"Cuando el usuario selecciona una celda haciendo tap sobre ella se llama al m\u00e9todo tableView(_: didSelectRowAt:) del delegate . Como ejemplo vamos a ver c\u00f3mo implementar\u00edamos este m\u00e9todo de forma que cuando se seleccione una celda se ponga en ella una marca de verificaci\u00f3n, y que si ya est\u00e1 se quite. En las celdas predefinidas, esta marca (y otras similares) se controla con la propiedad accessoryType de la celda. func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let celda = tableView . cellForRow ( at : indexPath ) { //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos if celda . accessoryType == UITableViewCell . AccessoryType . none { celda . accessoryType = . checkmark } else { celda . accessoryType = . none } //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris tableView . deselectRow ( at : indexPath , animated : true ) } }","title":"Seleccionar celdas"},{"location":"4_tablas/apuntes/#insertar-y-eliminar-filas","text":"iOS nos ofrece de forma autom\u00e1tica el \u201cmodo edici\u00f3n\u201d, en el que en la parte izquierda de cada celda aparece un icono indicador de las operaciones que se pueden hacer con ella. Hay dos indicadores: Una se\u00f1al de \"prohibido\" para poder borrar la celda (pulsando sobre la se\u00f1al y luego sobre el bot\u00f3n \u201cBorrar\u201d que aparece). Un s\u00edmbolo de \u2018+\u2019 que sirve para insertar una nueva celda Podemos activar el modo edici\u00f3n con el m\u00e9todo setEditing del objeto tabla: 1 2 // suponemos que \"miTabla\" es un outlet a la tabla self . miTabla . setEditing ( true , animated : true ); Por defecto al activar el modo edici\u00f3n en todas las celdas aparecer\u00e1 la se\u00f1al de \u201cprohibido\u201d. Implementando en el delegate el m\u00e9todo tableView(_:,editingStyleForRowAt:) podemos especificar qu\u00e9 tipo de estilo de edici\u00f3n queremos para una celda determinada. El sistema nos \u201cpreguntar\u00e1\u201d el estilo de edici\u00f3n para un n\u00famero de celda y debemos devolver UITableViewCellEditingStyle.delete o bien UITableViewCellEditingStyle.insert . Aunque el modo edici\u00f3n es autom\u00e1tico, el borrado efectivo de las celdas y de su contenido lo tenemos que hacer nosotros, al igual que la inserci\u00f3n. iOS avisar\u00e1 al datasource de que se est\u00e1 intentando insertar o eliminar una celda, NO al delegate . Esto es l\u00f3gico ya que los datos los gestiona el datasource . As\u00ed, cuando se pulse sobre el y luego sobre \u201cdelete\u201d o sobre el , se llamar\u00e1 al m\u00e9todo del datasource llamado tableView(_:, commit:, forRowAt:) . En este m\u00e9todo tenemos que hacer dos cosas: Actualizar los datos (borrar el dato o insertar uno nuevo) Llamar a un m\u00e9todo del API de la tabla para que esta inserci\u00f3n o borrado se represente de manera visual (que gr\u00e1ficamente aparezca o desaparezca la celda) Es muy importante destacar que primero hay que actualizar los datos y luego ocuparse de la parte gr\u00e1fica. Si lo hacemos al rev\u00e9s no funcionar\u00e1 bien, ya que iOS intentar\u00e1 redibujar la tabla usando los datos \u201cantiguos\u201d. Simplemente implementando el siguiente m\u00e9todo (aunque estuviera vac\u00edo) activaremos el swipe to delete , pero el bot\u00f3n delete no va a funcionar salvo que implementemos el borrado como aqu\u00ed se muestra func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCell . EditingStyle , forRowAt indexPath : IndexPath ) { if editingStyle == UITableViewCell . EditingStyle . delete { self . datos . remove ( at : indexPath . row ) tableView . deleteRows ( at : [ indexPath ], with : UITableView . RowAnimation . fade ) } else if editingStyle == UITableViewCell . EditingStyle . insert { self . datos . insert ( \"Nueva celda\" , at : indexPath . row ) tableView . insertRows ( at : [ indexPath ], with : UITableView . RowAnimation . bottom ) } } N\u00f3tese que los m\u00e9todos insertRows y deleteRows permiten insertar o borrar varias celdas a la vez y por ello como primer par\u00e1metro requieren un array de indexPath , y no un indexPath directamente. Si insertamos/borramos una \u00fanica celda ser\u00e1 un array de un \u00fanico componente. Esto que hemos visto se aplica a cuando la inserci\u00f3n o eliminaci\u00f3n las dispara el propio iOS pulsando en los botones del sistema. Pero tambi\u00e9n podemos disparar nosotros manualmente la inserci\u00f3n o eliminaci\u00f3n. Por ejemplo veamos c\u00f3mo se insertar\u00eda una nueva celda \u201cmanualmente\u201d al principio de la tabla. //primero hay que actualizar los datos self . datos . insert ( \"Nueva celda\" , at : 0 ) //y ahora visualmente insertar la celda let indexPath = IndexPath ( row : 0 , section : 0 ) //suponemos que tenemos accesible la tabla, la necesitamos tabla . insertRows ( at : [ indexPath ], with : UITableViewRowAnimation . fade )","title":"Insertar y eliminar filas"},{"location":"4_tablas/apuntes/#diffable-data-sources","text":"Como hemos visto, el encargado de gestionar los datos mostrados en la tabla y sincronizar el estado de la propia interfaz es el propio programador. Pero esto da lugar a c\u00f3digo tedioso y propenso a errores. Ser\u00eda mucho mejor que iOS se encargara de seguir autom\u00e1ticamente la pista de los datos si estos cambian y actualizara visualmente la tabla de manera autom\u00e1tica. Esto lo podemos conseguir con los Diffable Data Sources , que se introdujeron en iOS13. Para crear un Diffable Data Source necesitamos especificar: El tipo de los items de la tabla. Adem\u00e1s este debe ser conforme al protocolo hashable (lo son autom\u00e1ticamente tipos b\u00e1sicos como String o Int, luego veremos qu\u00e9 implicaciones tiene esto) El tipo de las secciones de la tabla. En iOS por defecto son simplemente enteros, pero aqu\u00ed podemos especificar el tipo que queramos (siempre que como antes, sea hashable ) La UITableView asociada al data source El c\u00f3digo que crea cada celda (lo que hac\u00edamos en el m\u00e9todo tableView(_:, cellForRowAt:) ) Por ejemplo, supongamos para simplificar que los identificadores de secci\u00f3n van a ser enteros y los datos de la tabla String s. Podr\u00edamos crear nuestro diffable data source como sigue: class MiDiffableDS : UITableViewDiffableDataSource < Int , String > { init ( tabla : UITableView ) { super . init ( tableView : tabla , cellProvider : { tableView , indexPath , item in let cell = tableView . dequeueReusableCell ( withIdentifier : \"miCelda\" , for : indexPath ) cell . textLabel ?. text = item return cell }) } } cosas interesantes: Nuestra clase hereda de UITableViewDiffableDataSource , que es la clase base de los diffable data sources en iOS. Esta clase es gen\u00e9rica y est\u00e1 parametrizada por <TipoDeSeccion, TipoDeItem> , en nuestro caso Int y String como ya hemos dicho En el constructor de la clase base hay que pasar como par\u00e1metros: La UITableView asociada. Aqu\u00ed es donde se hace la conexi\u00f3n entre datasource y tabla. En nuestro ejemplo este par\u00e1metro se lo pasamos al inicializador de la clase derivada, as\u00ed se lo podemos pasar desde el controller que es el \"due\u00f1o\" de la tabla. en cellProvider pasamos una clausura que b\u00e1sicamente es la implementaci\u00f3n que hac\u00edamos antes del tableView(_:, cellForRowAt:) (obtener la celda reutilizada, rellenarla de datos y devolverla) Si no queremos \"molestarnos\" en definir una clase propia tambi\u00e9n podemos crear directamente una instancia de la clase base y luego asign\u00e1rsela a la tabla como su datasouce: //suponiendo que el UITableView se llame \"tabla\" //Este c\u00f3digo podr\u00eda estar en el viewDidLoad del controller let miDataSource = UITableViewDiffableDataSource < Int , String >( tableview : miTabla , //cellProvider igual que antes ... ) miTabla . dataSource = miDataSource De momento no hemos sacado ning\u00fan beneficio apreciable de usar un diffable data source . Los beneficios empiezan cuando queremos modificar los datos asociados a la tabla. La idea es que el conjunto de datos se representa con lo que se llama un snapshot , que podemos modificar (crear de nuevo, a\u00f1adir datos, borrar datos,...). Una vez modificado el snapshot llamamos al m\u00e9todo apply sobre el datasource para que visualmente se apliquen los cambios correspondientes. Por ejemplo podr\u00edamos inicializar los datos como sigue: var snapshot = NSDiffableDataSourceSnapshot < Int , String >() snapshot . appendSections ([ 0 ]) snapshot . appendItems ([ \"uno\" , \"dos\" , \"tres\" ], toSection : 0 ) ds . apply ( snapshot , animatingDifferences : false ) Como vemos en este ejemplo, podemos a\u00f1adir secciones a la tabla e items dentro de cada secci\u00f3n. Al llamar a apply se actualizar\u00e1 la tabla, con una animaci\u00f3n si el par\u00e1metro animatingDifferences es true . En el snapshot tenemos m\u00e9todos para insertar, modificar o eliminar items, por ejemplo: //aqu\u00ed ds ser\u00eda el diffable data source que hemos creado var snapshot = ds . snapshot () snapshot . deleteItems ([ \"uno\" ]) ds . apply ( snapshot ) Los items se borran especificando un id , que en el caso de un tipo simple como String se corresponde con el propio contenido. La tabla se actualizar\u00e1 autom\u00e1ticamente tras el apply . Para implementar el borrado de celdas haciendo tap sobre ellas en el modo edici\u00f3n tendremos que sobreescribir el m\u00e9todo tableView(_,commit:,atIndexPath:) en nuestro diffable data source : override func tableView ( _ tableView : UITableView , commit editingStyle : UITableViewCell . EditingStyle , forRowAt indexPath : IndexPath ) { var snapshot = self . snapshot () if let item = itemIdentifier ( for : indexPath ) { snapshot . deleteItems ([ item ]) apply ( snapshot ) } } La diferencia es que ahora no tenemos que actualizar visualmente la tabla, solo modificar el snapshot y aplicarlo al datasource . Para saber qu\u00e9 item est\u00e1 en la posici\u00f3n indexPath usamos el m\u00e9todo itemIdentifier .","title":"Diffable Data Sources"},{"location":"4_tablas/ejercicios/","text":"Ejercicios de tablas (2,25 puntos) \u00b6 Vamos a crear una peque\u00f1a aplicaci\u00f3n en la que se muestre una tabla con una lista de dato y se puedan insertar y eliminar filas Crear la interfaz (0,25 puntos) \u00b6 Crea otra pantalla, al estilo de la que aparece en la figura. Tiene que tener los siguientes componentes: Un text field Un button con el texto \"Insertar\" Un table view . Mostrar datos en la tabla (1 punto) \u00b6 Crea una clase Swift llamada DSTabla que va a hacer de datasource de la tabla seleccion\u00e1ndola. Haz que el DSTabla implemente el protocolo UITableViewDataSource Conecta el DSTabla con la propiedad dataSource de la tabla El DSTabla va a almacenar los datos en una propiedad lista de tipo array de String (puedes usar los nombres que aparecen en el ejemplo u otros datos cualesquiera, es indiferente) //en la clase DSTabla, definimos e inicializamos la propiedad var lista = [ \"Daenerys Targaryen\" , \"Jon Nieve\" , \"Cersei Lannister\" , \"Eddard Stark\" ] Ahora tendr\u00e1s que implementar t\u00fa de manera adecuada los m\u00e9todos: tableView(_:, numberOfRowsInSection:) recuerda que debe devolver el n\u00famero de filas de la tabla tableView(_:, cellForRowAt:) : recuerda que debe devolver la celda para una fila determinada Insertar filas (0,5 puntos) \u00b6 Implementa en el datasource un m\u00e9todo insertarCelda(enTabla:,enFila:,conTexto:) que al pasarle el UITableView , un n\u00famero de fila y un texto a\u00f1ada el texto a la lista de datos y luego a\u00f1ada visualmente la fila en la tabla. En la interfaz haz que cuando se escriba un texto en el campo de texto y se pulse el bot\u00f3n Insertar se llame al m\u00e9todo insertarCelda (enTabla:,enFila:,conTexto:) que has definido. Delegate (0,5 puntos) \u00b6 Vamos a hacer que se puedan \"marcar\" filas de la tabla. Para ello necesitas alg\u00fan objeto que act\u00fae de delegate . Crea para ello una clase DelegateTabla Haz que esta clase herede de NSObject e implemente el protocolo UITableViewDelegate Implementa en esta clase un m\u00e9todo similar al que en las transparencias marca o desmarca una fila poni\u00e9ndole un \"checkmark\", pero aqu\u00ed cambiando el texto a color rojo (propiedad textColor a UIColor.red ) y si est\u00e1 en rojo pasando a negro. Ahora vamos a conectar el delegate con la tabla gr\u00e1ficamente, en vez de por c\u00f3digo. Para ello: Arrastrar un componente Object al \u00e1rbol de componentes de la pantalla del m\u00f3vil (al \u00e1rbol que aparece a la izquierda, no a la pantalla en s\u00ed). Seleccionar el componente, y en el Identity inspector (cuarto icono del panel derecho de Xcode), escribir el nombre de la clase DelegateTabla en Custom Class . Conectar tabla y delegate: seleccionamos la tabla con el rat\u00f3n y vamos al Connections inspector (el icono panel derecho de Xcode). Arrastramos con el rat\u00f3n (no hace falta Ctrl ) desde el c\u00edrculo que representa al delegate hasta el icono del objeto que representa a la clase TablaDelegate Una vez hecho esto, comprueba que funciona correctamente.","title":"Ejercicios de tablas (2,25 puntos)"},{"location":"4_tablas/ejercicios/#ejercicios-de-tablas-225-puntos","text":"Vamos a crear una peque\u00f1a aplicaci\u00f3n en la que se muestre una tabla con una lista de dato y se puedan insertar y eliminar filas","title":"Ejercicios de tablas (2,25 puntos)"},{"location":"4_tablas/ejercicios/#crear-la-interfaz-025-puntos","text":"Crea otra pantalla, al estilo de la que aparece en la figura. Tiene que tener los siguientes componentes: Un text field Un button con el texto \"Insertar\" Un table view .","title":"Crear la interfaz (0,25 puntos)"},{"location":"4_tablas/ejercicios/#mostrar-datos-en-la-tabla-1-punto","text":"Crea una clase Swift llamada DSTabla que va a hacer de datasource de la tabla seleccion\u00e1ndola. Haz que el DSTabla implemente el protocolo UITableViewDataSource Conecta el DSTabla con la propiedad dataSource de la tabla El DSTabla va a almacenar los datos en una propiedad lista de tipo array de String (puedes usar los nombres que aparecen en el ejemplo u otros datos cualesquiera, es indiferente) //en la clase DSTabla, definimos e inicializamos la propiedad var lista = [ \"Daenerys Targaryen\" , \"Jon Nieve\" , \"Cersei Lannister\" , \"Eddard Stark\" ] Ahora tendr\u00e1s que implementar t\u00fa de manera adecuada los m\u00e9todos: tableView(_:, numberOfRowsInSection:) recuerda que debe devolver el n\u00famero de filas de la tabla tableView(_:, cellForRowAt:) : recuerda que debe devolver la celda para una fila determinada","title":"Mostrar datos en la tabla (1 punto)"},{"location":"4_tablas/ejercicios/#insertar-filas-05-puntos","text":"Implementa en el datasource un m\u00e9todo insertarCelda(enTabla:,enFila:,conTexto:) que al pasarle el UITableView , un n\u00famero de fila y un texto a\u00f1ada el texto a la lista de datos y luego a\u00f1ada visualmente la fila en la tabla. En la interfaz haz que cuando se escriba un texto en el campo de texto y se pulse el bot\u00f3n Insertar se llame al m\u00e9todo insertarCelda (enTabla:,enFila:,conTexto:) que has definido.","title":"Insertar filas (0,5 puntos)"},{"location":"4_tablas/ejercicios/#delegate-05-puntos","text":"Vamos a hacer que se puedan \"marcar\" filas de la tabla. Para ello necesitas alg\u00fan objeto que act\u00fae de delegate . Crea para ello una clase DelegateTabla Haz que esta clase herede de NSObject e implemente el protocolo UITableViewDelegate Implementa en esta clase un m\u00e9todo similar al que en las transparencias marca o desmarca una fila poni\u00e9ndole un \"checkmark\", pero aqu\u00ed cambiando el texto a color rojo (propiedad textColor a UIColor.red ) y si est\u00e1 en rojo pasando a negro. Ahora vamos a conectar el delegate con la tabla gr\u00e1ficamente, en vez de por c\u00f3digo. Para ello: Arrastrar un componente Object al \u00e1rbol de componentes de la pantalla del m\u00f3vil (al \u00e1rbol que aparece a la izquierda, no a la pantalla en s\u00ed). Seleccionar el componente, y en el Identity inspector (cuarto icono del panel derecho de Xcode), escribir el nombre de la clase DelegateTabla en Custom Class . Conectar tabla y delegate: seleccionamos la tabla con el rat\u00f3n y vamos al Connections inspector (el icono panel derecho de Xcode). Arrastramos con el rat\u00f3n (no hace falta Ctrl ) desde el c\u00edrculo que representa al delegate hasta el icono del objeto que representa a la clase TablaDelegate Una vez hecho esto, comprueba que funciona correctamente.","title":"Delegate (0,5 puntos)"},{"location":"5_contenedores/apuntes/","text":"Controladores contenedores \u00b6 A diferencia de los otros tipos de controllers que hemos visto, los controladores contenedores no muestran directamente el contenido \u201cprincipal\u201d de la aplicaci\u00f3n. El papel de estos controladores es, como su propio nombre indica, el de servir de contenedores a los controladores que muestran el contenido y permitir la nanegaci\u00f3n sencilla entre ellos. En esta parte b\u00e1sica de la asignatura vamos a ver los dos controladores contenedores m\u00e1s t\u00edpicos: el tab bar y el navigation . Los dos nos sirven para organizar la app en diferentes pantallas, con la diferencia de que el navigation controller se usa cuando la navegaci\u00f3n es jer\u00e1rquica/secuencial (por ejemplo, un par de vistas maestro/detalle, o un asistente con varios pasos) y el tab bar cuando queremos dividir nuestra app en distintos \"apartados\" pero no hay una relaci\u00f3n jer\u00e1rquica entre ellos. Tab bar controllers \u00b6 Permiten dise\u00f1ar la t\u00edpica aplicaci\u00f3n dividida por \u201capartados\u201d o \u201ctabs\u201d. Por ejemplo lo podemos ver en la aplicaci\u00f3n de \u201csalud\u201d de iOS (entre much\u00edsimas otras) Lo que tenemos es un controlador de tipo \u201ctab bar\u201d que gestiona la barra inferior y la navegaci\u00f3n entre pantallas cuando pulsamos cada uno de sus iconos, pero el contenido de las pantallas lo gestionan los otros controladores. Formas de crear un tab bar controller \u00b6 Podemos arrastrar un tab bar controller al storyboard desde la object library . Vemos que el nuevo tab bar controller aparece conectado a dos controladores convencionales (de la clase UIViewController ). Autom\u00e1ticamente cuando pulsemos en cada icono, se saltar\u00e1 al controller asociado. Podemos a\u00f1adir pantallas a este tab bar controller sin m\u00e1s que crearlas en el storyboard y luego conectarlas. Hacemos Ctrl+arrastrar desde el tab bar controller hasta la pantalla a conectar y en el men\u00fa contextual elegimos el tipo de segue llamado view controllers (en el apartado relationship segue ). Otra forma de crear un tab bar controller relacionado con una pantalla que ya tengamos creada es seleccionar la misma y en el men\u00fa de Editor elegir Embed in > Tab bar controller . Aparecer\u00e1 un tab bar controller con un \u00fanico icono en la barra inferior, y ya conectado a la pantalla actual. Personalizar la barra inferior \u00b6 Desde Xcode podemos cambiar algunas propiedades b\u00e1sicas de los iconos de la barra inferior en el attribute inspector , como el icono, el t\u00edtulo, la posici\u00f3n del t\u00edtulo con respecto al icono, si queremos que aparezca un badge , etc. El interfaz nos permite especificar las propiedades del UITabBarItem y UIBarItem como si fueran objetos separados. En realidad es el mismo pero las propiedades aparecen separadas ya que la segunda clase es la superclase de la primera En el apartado Tab bar item , si elegimos uno de los iconos del sistema no podremos cambiar el t\u00edtulo ya que Apple considera que lo contrario podr\u00eda inducir a confusi\u00f3n al usuario. En el \u00faltimo apartado de los apuntes se habla algo m\u00e1s sobre el formato de los iconos que podemos a\u00f1adir a una tab bar Navigation controllers \u00b6 Los navigation controller sirven para crear estructuras de navegaci\u00f3n jer\u00e1rquica en las que tenemos pantallas y \u201csubpantallas\u201d. Estando en una de ellas podemos volver atr\u00e1s una a una. El navigation controller se encargar\u00e1 de que se vaya cambiando autom\u00e1ticamente al controlador apropiado (el de la pantalla actual). N\u00f3tese que cuando estamos navegando de este modo estamos usando una pila de controladores , en el sentido que tiene este t\u00e9rmino en estructuras de datos, ya que conforme vamos profundizando en la jerarqu\u00eda se van apilando los controladores, y cuando volvemos atr\u00e1s quitamos el de la parte de arriba de la pila. Crear un controlador de navegaci\u00f3n \u00b6 Hay dos formas de crear gr\u00e1ficamente un controlador de navegaci\u00f3n: 1) Seleccionamos un controller en el storyboard y elegimos la opci\u00f3n de men\u00fa de Editor > Embed in > Navigation controller . Se crear\u00e1 un controlador de navegaci\u00f3n que tiene como controlador de contenido asociado al que hab\u00edamos seleccionado. N\u00f3tese que como en el caso de los tab bar controller en el de navegaci\u00f3n la pantalla est\u00e1 en gris indicando que el contenido no es responsabilidad de este controlador. En el controlador de contenido asociado podemos ver que la parte superior aparece en gris, indicando que esta es la barra de navegaci\u00f3n que gestionar\u00e1 el controlador de navegaci\u00f3n. 2) Podemos arrastrar un Navigation controller desde la librer\u00eda de objectos hasta el storyboard . Por defecto nos crear\u00e1 el controlador de navegaci\u00f3n junto con un controlador de tabla, estructura apropiada para comenzar con una vista maestro/detalle. No obstante si no queremos este segundo controlador podemos borrarlo y conectar el de navegaci\u00f3n con uno nuevo con Ctrl+Arrastrar entre ambos y seleccionando en el men\u00fa contextual la opci\u00f3n de root view controller bajo relationship segue . Las pantallas que est\u00e1n en la jerarqu\u00eda de un navigation controller tienen en la parte superior una barra de navegaci\u00f3n , que en el \u00e1rbol de la jerarqu\u00eda de vistas ( Document outline ) aparece como Navigation item . Podemos cambiar varias de sus propiedades en el inspector de propiedades, como el t\u00edtulo, una l\u00ednea adicional de t\u00edtulo ( prompt ), el t\u00edtulo del bot\u00f3n para ir atr\u00e1s (que iOS muestra autom\u00e1ticamente), y si queremos que el t\u00edtulo sea grande. A\u00f1adir pantallas a la jerarqu\u00eda \u00b6 Para a\u00f1adir un controlador a la jerarqu\u00eda de navegaci\u00f3n basta con Ctrl+Arrastrar entre el componente que disparar\u00eda el salto y el controlador de destino. En el men\u00fa contextual hay que elegir el segue adecuado (sea push o show) . Evidentemente el controlador de origen tiene que estar ya en la jerarqu\u00eda de navegaci\u00f3n para que esta operaci\u00f3n funcione. Personalizar la barra de navegaci\u00f3n \u00b6 Autom\u00e1ticamente el controlador de navegaci\u00f3n gestionar\u00e1 una barra de navegaci\u00f3n en la parte superior de la pantalla. Esta barra muestra por defecto en su parte izquierda un bot\u00f3n < Back para ir al controlador anterior. La barra de navegaci\u00f3n es totalmente personalizable. Lo m\u00e1s inmediato es mostrar un t\u00edtulo para la pantalla actual cambiando la propiedad title del controlador. Esta propiedad en general es una simple descripci\u00f3n de la pantalla, pero en el caso de controladores de contenido que est\u00e9n incluidos en un contenedor, representa el t\u00edtulo de la barra de navegaci\u00f3n. El cambio de title podemos hacerlo bien en el interface builder de Xcode o bien por c\u00f3digo, por ejemplo en el m\u00e9todo viewWillAppear del controller , ya que se ejecutar\u00e1 antes de mostrar la vista. Al cambiar el t\u00edtulo del controlador tambi\u00e9n cambiar\u00e1 autom\u00e1ticamente el bot\u00f3n ``< Back``` del siguiente \u201cnivel\u201d para reflejar el nuevo t\u00edtulo. Si el t\u00edtulo del controller es demasiado largo y no cabe en el bot\u00f3n este seguir\u00e1 con el t\u00edtulo por defecto ( Back ) Podemos cambiar completamente la barra de navegaci\u00f3n. Es accesible mediante la propiedad navigationItem del controlador, y podemos cambiar por ejemplo: backBarButtonItem : el bot\u00f3n, de tipo UIBarButtonItem , que se utilizar\u00e1 para volver atr\u00e1s a este controlador titleView : el componente con el t\u00edtulo para el controlador, cuyo texto como hemos visto podemos cambiar con la propiedad title del controlador. rightBarButtonItem : por defecto nil . T\u00edpicamente se usa para a\u00f1adir un bot\u00f3n para editar el contenido de la pantalla actual, pero podemos colocar lo que queramos. Iconos \u00b6 Como hemos visto le podemos poner un icono a cada secci\u00f3n de una tab bar . Como veremos, pasa lo mismo con las navigation bar . Los iconos \"cl\u00e1sicos\" para usar en estos casos en iOS son en formato png y debemos a\u00f1adirlos al proyecto, pero desde iOS13 hay un nuevo conjunto de unos 2400 iconos ya inclu\u00eddos en el sistema llamados \"SF Symbols\" y especialmente dise\u00f1ados para encajar con la fuente por defecto. Iconos PNG \u00b6 Los iconos de este tipo son monocrom\u00e1ticos. El formato a usar es .png, del que el sistema examinar\u00e1 el canal alfa o de transparencia, tomando como forma del icono los pixels que sean opacos, pero ignorando su color. El tama\u00f1o recomendado para los iconos var\u00eda seg\u00fan la interfaz se muestre en modo compact (que en un iPhone corresponder\u00eda a portrait /vertical) o regular (en un iPhone ser\u00eda landscape /horizontal, y en un iPad ser\u00eda cualquier modo, ya que un iPad en vertical es mucho m\u00e1s ancho que un iPhone). Pod\u00e9is consultar m\u00e1s detalles sobre el formato y el tama\u00f1o recomendado en el apartado \" Tab bar icon size \" de las iOS Human Interface Guidelines de Apple. SF Symbols \u00b6 Est\u00e1n disponibles desde iOS13. Presentan varias ventajas, entre ellas la de integrarse perfectamente con la fuente del sistema, ser vectoriales y por tanto escalables sin perder resoluci\u00f3n, estar ya inclu\u00eddos en iOS (no hay que a\u00f1adirlos al assets ) y hpoder renderizarse en distintos modos (monocromo, niveles de color, multicolor). Para m\u00e1s informaci\u00f3n sobre estos iconos, se recomienda consultar el apartado correspondiente de las Human Interface Guidelines. Apple ofrece una aplicaci\u00f3n para Mac con la que se puede visualizar el cat\u00e1logo completo de s\u00edmbolos, aunque no est\u00e1n disponibles directamente en la web. Hay varios sitios de terceros que muestran la informaci\u00f3n (pod\u00e9is buscar \"sf symbols online\") pero en teor\u00eda por motivos de licencia estos sitios no pueden mostrar los iconos en s\u00ed.","title":"Controladores contenedores"},{"location":"5_contenedores/apuntes/#controladores-contenedores","text":"A diferencia de los otros tipos de controllers que hemos visto, los controladores contenedores no muestran directamente el contenido \u201cprincipal\u201d de la aplicaci\u00f3n. El papel de estos controladores es, como su propio nombre indica, el de servir de contenedores a los controladores que muestran el contenido y permitir la nanegaci\u00f3n sencilla entre ellos. En esta parte b\u00e1sica de la asignatura vamos a ver los dos controladores contenedores m\u00e1s t\u00edpicos: el tab bar y el navigation . Los dos nos sirven para organizar la app en diferentes pantallas, con la diferencia de que el navigation controller se usa cuando la navegaci\u00f3n es jer\u00e1rquica/secuencial (por ejemplo, un par de vistas maestro/detalle, o un asistente con varios pasos) y el tab bar cuando queremos dividir nuestra app en distintos \"apartados\" pero no hay una relaci\u00f3n jer\u00e1rquica entre ellos.","title":"Controladores contenedores"},{"location":"5_contenedores/apuntes/#tab-bar-controllers","text":"Permiten dise\u00f1ar la t\u00edpica aplicaci\u00f3n dividida por \u201capartados\u201d o \u201ctabs\u201d. Por ejemplo lo podemos ver en la aplicaci\u00f3n de \u201csalud\u201d de iOS (entre much\u00edsimas otras) Lo que tenemos es un controlador de tipo \u201ctab bar\u201d que gestiona la barra inferior y la navegaci\u00f3n entre pantallas cuando pulsamos cada uno de sus iconos, pero el contenido de las pantallas lo gestionan los otros controladores.","title":"Tab bar controllers"},{"location":"5_contenedores/apuntes/#formas-de-crear-un-tab-bar-controller","text":"Podemos arrastrar un tab bar controller al storyboard desde la object library . Vemos que el nuevo tab bar controller aparece conectado a dos controladores convencionales (de la clase UIViewController ). Autom\u00e1ticamente cuando pulsemos en cada icono, se saltar\u00e1 al controller asociado. Podemos a\u00f1adir pantallas a este tab bar controller sin m\u00e1s que crearlas en el storyboard y luego conectarlas. Hacemos Ctrl+arrastrar desde el tab bar controller hasta la pantalla a conectar y en el men\u00fa contextual elegimos el tipo de segue llamado view controllers (en el apartado relationship segue ). Otra forma de crear un tab bar controller relacionado con una pantalla que ya tengamos creada es seleccionar la misma y en el men\u00fa de Editor elegir Embed in > Tab bar controller . Aparecer\u00e1 un tab bar controller con un \u00fanico icono en la barra inferior, y ya conectado a la pantalla actual.","title":"Formas de crear un tab bar controller"},{"location":"5_contenedores/apuntes/#personalizar-la-barra-inferior","text":"Desde Xcode podemos cambiar algunas propiedades b\u00e1sicas de los iconos de la barra inferior en el attribute inspector , como el icono, el t\u00edtulo, la posici\u00f3n del t\u00edtulo con respecto al icono, si queremos que aparezca un badge , etc. El interfaz nos permite especificar las propiedades del UITabBarItem y UIBarItem como si fueran objetos separados. En realidad es el mismo pero las propiedades aparecen separadas ya que la segunda clase es la superclase de la primera En el apartado Tab bar item , si elegimos uno de los iconos del sistema no podremos cambiar el t\u00edtulo ya que Apple considera que lo contrario podr\u00eda inducir a confusi\u00f3n al usuario. En el \u00faltimo apartado de los apuntes se habla algo m\u00e1s sobre el formato de los iconos que podemos a\u00f1adir a una tab bar","title":"Personalizar la barra inferior"},{"location":"5_contenedores/apuntes/#navigation-controllers","text":"Los navigation controller sirven para crear estructuras de navegaci\u00f3n jer\u00e1rquica en las que tenemos pantallas y \u201csubpantallas\u201d. Estando en una de ellas podemos volver atr\u00e1s una a una. El navigation controller se encargar\u00e1 de que se vaya cambiando autom\u00e1ticamente al controlador apropiado (el de la pantalla actual). N\u00f3tese que cuando estamos navegando de este modo estamos usando una pila de controladores , en el sentido que tiene este t\u00e9rmino en estructuras de datos, ya que conforme vamos profundizando en la jerarqu\u00eda se van apilando los controladores, y cuando volvemos atr\u00e1s quitamos el de la parte de arriba de la pila.","title":"Navigation controllers"},{"location":"5_contenedores/apuntes/#crear-un-controlador-de-navegacion","text":"Hay dos formas de crear gr\u00e1ficamente un controlador de navegaci\u00f3n: 1) Seleccionamos un controller en el storyboard y elegimos la opci\u00f3n de men\u00fa de Editor > Embed in > Navigation controller . Se crear\u00e1 un controlador de navegaci\u00f3n que tiene como controlador de contenido asociado al que hab\u00edamos seleccionado. N\u00f3tese que como en el caso de los tab bar controller en el de navegaci\u00f3n la pantalla est\u00e1 en gris indicando que el contenido no es responsabilidad de este controlador. En el controlador de contenido asociado podemos ver que la parte superior aparece en gris, indicando que esta es la barra de navegaci\u00f3n que gestionar\u00e1 el controlador de navegaci\u00f3n. 2) Podemos arrastrar un Navigation controller desde la librer\u00eda de objectos hasta el storyboard . Por defecto nos crear\u00e1 el controlador de navegaci\u00f3n junto con un controlador de tabla, estructura apropiada para comenzar con una vista maestro/detalle. No obstante si no queremos este segundo controlador podemos borrarlo y conectar el de navegaci\u00f3n con uno nuevo con Ctrl+Arrastrar entre ambos y seleccionando en el men\u00fa contextual la opci\u00f3n de root view controller bajo relationship segue . Las pantallas que est\u00e1n en la jerarqu\u00eda de un navigation controller tienen en la parte superior una barra de navegaci\u00f3n , que en el \u00e1rbol de la jerarqu\u00eda de vistas ( Document outline ) aparece como Navigation item . Podemos cambiar varias de sus propiedades en el inspector de propiedades, como el t\u00edtulo, una l\u00ednea adicional de t\u00edtulo ( prompt ), el t\u00edtulo del bot\u00f3n para ir atr\u00e1s (que iOS muestra autom\u00e1ticamente), y si queremos que el t\u00edtulo sea grande.","title":"Crear un controlador de navegaci\u00f3n"},{"location":"5_contenedores/apuntes/#anadir-pantallas-a-la-jerarquia","text":"Para a\u00f1adir un controlador a la jerarqu\u00eda de navegaci\u00f3n basta con Ctrl+Arrastrar entre el componente que disparar\u00eda el salto y el controlador de destino. En el men\u00fa contextual hay que elegir el segue adecuado (sea push o show) . Evidentemente el controlador de origen tiene que estar ya en la jerarqu\u00eda de navegaci\u00f3n para que esta operaci\u00f3n funcione.","title":"A\u00f1adir pantallas a la jerarqu\u00eda"},{"location":"5_contenedores/apuntes/#personalizar-la-barra-de-navegacion","text":"Autom\u00e1ticamente el controlador de navegaci\u00f3n gestionar\u00e1 una barra de navegaci\u00f3n en la parte superior de la pantalla. Esta barra muestra por defecto en su parte izquierda un bot\u00f3n < Back para ir al controlador anterior. La barra de navegaci\u00f3n es totalmente personalizable. Lo m\u00e1s inmediato es mostrar un t\u00edtulo para la pantalla actual cambiando la propiedad title del controlador. Esta propiedad en general es una simple descripci\u00f3n de la pantalla, pero en el caso de controladores de contenido que est\u00e9n incluidos en un contenedor, representa el t\u00edtulo de la barra de navegaci\u00f3n. El cambio de title podemos hacerlo bien en el interface builder de Xcode o bien por c\u00f3digo, por ejemplo en el m\u00e9todo viewWillAppear del controller , ya que se ejecutar\u00e1 antes de mostrar la vista. Al cambiar el t\u00edtulo del controlador tambi\u00e9n cambiar\u00e1 autom\u00e1ticamente el bot\u00f3n ``< Back``` del siguiente \u201cnivel\u201d para reflejar el nuevo t\u00edtulo. Si el t\u00edtulo del controller es demasiado largo y no cabe en el bot\u00f3n este seguir\u00e1 con el t\u00edtulo por defecto ( Back ) Podemos cambiar completamente la barra de navegaci\u00f3n. Es accesible mediante la propiedad navigationItem del controlador, y podemos cambiar por ejemplo: backBarButtonItem : el bot\u00f3n, de tipo UIBarButtonItem , que se utilizar\u00e1 para volver atr\u00e1s a este controlador titleView : el componente con el t\u00edtulo para el controlador, cuyo texto como hemos visto podemos cambiar con la propiedad title del controlador. rightBarButtonItem : por defecto nil . T\u00edpicamente se usa para a\u00f1adir un bot\u00f3n para editar el contenido de la pantalla actual, pero podemos colocar lo que queramos.","title":"Personalizar la barra de navegaci\u00f3n"},{"location":"5_contenedores/apuntes/#iconos","text":"Como hemos visto le podemos poner un icono a cada secci\u00f3n de una tab bar . Como veremos, pasa lo mismo con las navigation bar . Los iconos \"cl\u00e1sicos\" para usar en estos casos en iOS son en formato png y debemos a\u00f1adirlos al proyecto, pero desde iOS13 hay un nuevo conjunto de unos 2400 iconos ya inclu\u00eddos en el sistema llamados \"SF Symbols\" y especialmente dise\u00f1ados para encajar con la fuente por defecto.","title":"Iconos "},{"location":"5_contenedores/apuntes/#iconos-png","text":"Los iconos de este tipo son monocrom\u00e1ticos. El formato a usar es .png, del que el sistema examinar\u00e1 el canal alfa o de transparencia, tomando como forma del icono los pixels que sean opacos, pero ignorando su color. El tama\u00f1o recomendado para los iconos var\u00eda seg\u00fan la interfaz se muestre en modo compact (que en un iPhone corresponder\u00eda a portrait /vertical) o regular (en un iPhone ser\u00eda landscape /horizontal, y en un iPad ser\u00eda cualquier modo, ya que un iPad en vertical es mucho m\u00e1s ancho que un iPhone). Pod\u00e9is consultar m\u00e1s detalles sobre el formato y el tama\u00f1o recomendado en el apartado \" Tab bar icon size \" de las iOS Human Interface Guidelines de Apple.","title":"Iconos PNG"},{"location":"5_contenedores/apuntes/#sf-symbols","text":"Est\u00e1n disponibles desde iOS13. Presentan varias ventajas, entre ellas la de integrarse perfectamente con la fuente del sistema, ser vectoriales y por tanto escalables sin perder resoluci\u00f3n, estar ya inclu\u00eddos en iOS (no hay que a\u00f1adirlos al assets ) y hpoder renderizarse en distintos modos (monocromo, niveles de color, multicolor). Para m\u00e1s informaci\u00f3n sobre estos iconos, se recomienda consultar el apartado correspondiente de las Human Interface Guidelines. Apple ofrece una aplicaci\u00f3n para Mac con la que se puede visualizar el cat\u00e1logo completo de s\u00edmbolos, aunque no est\u00e1n disponibles directamente en la web. Hay varios sitios de terceros que muestran la informaci\u00f3n (pod\u00e9is buscar \"sf symbols online\") pero en teor\u00eda por motivos de licencia estos sitios no pueden mostrar los iconos en s\u00ed.","title":"SF Symbols"},{"location":"5_contenedores/ejercicios/","text":"Ejercicio de contenedores y tablas \u00b6 Insertar tabla en view controller Poner 4 restricciones a los bordes de 0 Cambiar ViewController por ListaViewController En el identity inspector cambiar la clase por ListaViewController Editor > Embed in > Navigation Controller","title":"Ejercicios"},{"location":"5_contenedores/ejercicios/#ejercicio-de-contenedores-y-tablas","text":"Insertar tabla en view controller Poner 4 restricciones a los bordes de 0 Cambiar ViewController por ListaViewController En el identity inspector cambiar la clase por ListaViewController Editor > Embed in > Navigation Controller","title":"Ejercicio de contenedores y tablas"},{"location":"proyecto/lista_compra/","text":"Miniproyecto: Lista de la compra (3 puntos en total) \u00b6 Vamos a realizar una miniaplicaci\u00f3n para llevar la lista de la compra, podremos introducir productos y marcarlos cuando ya los hayamos comprado. Adem\u00e1s tendremos una pantalla con un cuadro de texto para escribir nuestras notas, cosas que debemos recordar pero no nos caben en la lista. La aplicaci\u00f3n ser\u00e1 funcional pero no guardar\u00e1 los datos de manera persistente. Esto lo veremos en la asignatura de Persistencia en Dispositivos M\u00f3viles. Organizaci\u00f3n inicial \u00b6 Crear un nuevo proyecto, llam\u00e1ndolo ListaCompra Para organizar un poco mejor el c\u00f3digo, vamos a meter en una carpeta los view controllers y renombrar el controller inicial: Bot\u00f3n derecho sobre el ViewController , en el men\u00fa popup \"New Group from Selection\". Llamar Controllers al nuevo grupo Cambiar el nombre de ViewController por ListaViewController , clicando con bot\u00f3n derecho en el c\u00f3digo fuente sobre el nombre de la clase y seleccionando la opci\u00f3n de Refactor > Rename... Funcionalidad: Mostrar lista de la compra (1 punto) \u00b6 Crear la tabla en el storyboard: \u00b6 Insertar un componente de UI de tipo table view en ListaViewController Ponerle 4 restricciones de autolayout de distancia 0 a los bordes, para que ocupe toda la pantalla del dispositivo Configurar la tabla como din\u00e1mica, y crear la celda prototipo: en las propiedades de la tabla (panel derecho, inspector de propiedades) Asegurarse que el Content es Dynamic prototypes (que es una tabla din\u00e1mica) Incrementar el n\u00famero de Prototype cells a 1 Elegir como style Plain que es un estilo preconfigurado solo con un t\u00edtulo de celda, nos basta para mostrar esta lista Poner como identifier el nombre \"miCelda\" Crear un outlet de la tabla, llamado tabla en ListaViewController Crear la fuente de datos de la tabla \u00b6 Crear un nuevo grupo (carpeta para organizar c\u00f3digo): en el panel izquierdo de Xcode, vista \"navegador\", bot\u00f3n derecho sobre la carpeta ListaCompra y en el men\u00fa desplegable, New Group . Llamarlo Lista Crear dentro de este grupo un struct Item , para guardar los datos de un item de la lista struct Item { var nombre : String var comprado : Bool } Crear dentro del grupo Lista la clase ListaHelper : File > New ... > File y en el asistente, elegir Swift File . Crear un fichero llamado ListaHelper , que har\u00e1 de datasource de la tabla. Queremos que aparezca la lista de cosas a comprar y que si ya est\u00e1n compradas aparezca un \"checkmark\" al lado. Puedes copiar el siguiente c\u00f3digo, tienes que completar el segundo m\u00e9todo: import UIKit class ListaHelper : NSObject , UITableViewDataSource { var lista : [ Item ] = [ Item ( nombre : \"pan\" , comprado : true ), Item ( nombre : \"agua\" , comprado : false ), Item ( nombre : \"tomates\" , comprado : true ) ] func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return lista . count } func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { //TO-DO: escribir c\u00f3digo que: //1. obtenga una celda reutilizada llamando a tableView.dequeueReusableCell // Acordarse de usar el identificador \"miCelda\" que hemos configurado antes //2. rellenar el .text de la celda con el nombre del item en la pos correspondiente del array //3. si la propiedad `comprado` del item es `true`, fijar `accesoryType`de la celda a `.checkmark`. Si no, a `none` //4. devolver la celda } } En ListaViewController crear una instancia de ListaHelper y hacer que sea datasource de la tabla: //En la clase ListaViewController //Este outlet ya lo deber\u00edamos tener @IBOutlet weak var tabla : UITableView ! //Declaramos e inicializamos el datasource var miHelper = ListaHelper () override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. //Lo conectamos con la tabla self . tabla . dataSource = miHelper } Ejecutar el proyecto y comprobar que en pantalla aparece la lista de items Funcionalidad de marcar/desmarcar items (0,5 puntos) \u00b6 El objeto que es \"avisado\" cuando hacemos tap en una celda es el delegate de la tabla, por tanto necesitamos uno, haremos que ListaHelper lo sea: A\u00f1adir el protocolo correspondiente a la cabecera de ListaHelper class ListaHelper : NSObject , UITableViewDataSource , UITableViewDelegate { //... } Implementar el m\u00e9todo didSelectRowAt del delegate, aqu\u00ed tienes el mismo c\u00f3digo que usamos en un ejemplo de la sesi\u00f3n de tablas func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let celda = tableView . cellForRow ( at : indexPath ) { //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos if celda . accessoryType == UITableViewCell . AccessoryType . none { celda . accessoryType = . checkmark } else { celda . accessoryType = . none } //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris tableView . deselectRow ( at : indexPath , animated : true ) } } En el ListaViewController , hay que vincular el delegate de la tabla con la instancia de ListaHelper @IBOutlet weak var tabla : UITableView ! var miHelper = ListaHelper () override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. self . tabla . dataSource = miHelper **// A\u00d1ADE ESTA LINEA ** ** self . tabla . delegate = miHelper ** } Funcionalidad de \"nuevo item\" (1 punto) \u00b6 Crearemos una nueva pantalla en la app con un campo de texto donde se pueda escribir el nombre del nuevo item de la lista, y un bot\u00f3n de \"guardar\" Desde el punto de vista de la usabilidad seguramente ser\u00eda mejor que se pudieran editar los items de la lista \"in-place\" pero as\u00ed practicamos la navegaci\u00f3n entre pantallas con el Navigation controller . Crear la pantalla \u00b6 En el storyboard , hay que crear la nueva pantalla. Desde el panel de componentes de usuario, arrastrar un view controller nuevo, que ser\u00e1 la pantalla de a\u00f1adir item A\u00f1adirle a este nuevo view controller un cuadro de texto un bot\u00f3n \"guardar\" Fijar las restricciones de autolayout que consideres necesarias para estos componentes, el bot\u00f3n de guardar debe salir debajo del campo de texto Todav\u00eda nos falta que se pueda navegar entre la pantalla de lista y la pantalla de nuevo \u00edtem: Meter la pantalla de lista dentro de un navigation controller : Seleccionar el view controller (bot\u00f3n del c\u00edrculo amarillo con el cuadrado blanco dentro, en la parte superior de la pantalla simulada del dispositivo) , luego ir al men\u00fa Editor > Embed in...> Navigation controller . Aparecer\u00e1 el navigation controller conectado autom\u00e1ticamente a la primera pantalla. En la pantalla de lista habr\u00e1 aparecido una barra de navegaci\u00f3n en su parte superior, seleccionarla, ir a las propiedades y poner como t\u00edtulo \"Lista de la compra\". Vamos a a\u00f1adir el bot\u00f3n para saltar a la siguiente pantalla: Desde el panel de componentes de UI, arrastrar un Bar Button Item a la barra de navegaci\u00f3n de la pantalla de lista, a la parte de la derecha. En las propiedades del nuevo bot\u00f3n elegir como System Item el valor Add para que sea el t\u00edpico bot\u00f3n de \"A\u00f1adir\" por defecto (en iOS suelen aparecer simplemente con un \"+\") Conectar la pantalla de lista con la de nuevo item con ctrl+arrastrar desde este bot\u00f3n \"+\" hasta la pantalla de nuevo item. En el men\u00fa popup elegir como tipo de segue \"show\" Si probamos la app se podr\u00e1 navegar entre las dos pantallas, y volver a la primera desde la segunda gracias al bot\u00f3n con el bot\u00f3n < Lista de la compra que aparecer\u00e1 autom\u00e1ticamente en la barra de navegaci\u00f3n. Crear el controller de la nueva pantalla \u00b6 Una vez arreglada la navegaci\u00f3n, nos falta implementar la funcionalidad de la segunda pantalla. Primero tenemos que crear su controller : Crear una clase NuevoItemViewController: Bot\u00f3n derecho sobre la carpeta Controllers , seleccionar New File... y en el asistente elegir la plantilla Cocoa Touch Class , viene mejor para crear view controllers . En la segunda pantalla del asistente, poner el nombre de la nueva clase ( NuevoItemViewController ) y especificar que debe ser una subclase de UIViewController Vincular la clase con la pantalla en el storyboard En el storyboard seleccionar la segunda pantalla y en el panel de la derecha ir al \"identity inspector\" (4\u00ba icono) y poner como Class la clase creada, NuevoItemViewController Implementar la funcionalidad del bot\u00f3n \"guardar\" \u00b6 En el NuevoItemViewController creamos: un outlet para el campo de texto una propiedad nombre de tipo String para guardar el mismo dato, ya que desde la pantalla inicial no podemos acceder al campo de texto de la segunda. Queremos que cuando se pulse \"guardar\" se vuelva atr\u00e1s a la primera pantalla y adem\u00e1s se haga una copia del contenido del campo de texto en la propiedad nombre . Para volver atr\u00e1s: Crea una unwind action en ListaViewController para volver atr\u00e1s a esta pantalla desde la de nuevo item: recuerda que es un m\u00e9todo que est\u00e9 marcado con @IBAction y como par\u00e1metros tenga solo uno de tipo UIStoryboardSegue . si escribes \"unwind\" el autocompletar de Xcode te dar\u00e1 accesso a una plantilla de c\u00f3digo para un unwind action , para que no tengas que escribirlo t\u00fa de cero Conecta el bot\u00f3n de guardar de la pantalla de nuevo item con la unwind action (Ctrl+Arrastrar con el icono de \"Exit\" de la parte superior de la pantalla del dispositivo). Xcode buscar\u00e1 todas las \"unwind actions\" de todos los controllers y te mostrar\u00e1 una lista (en este caso solo habr\u00e1 una, la que creaste antes). NOTA: s\u00ed, esta forma de trabajar es \"rara\". Parece raro que el unwind action se cree en la pantalla destino y la conexi\u00f3n se haga desde el \"exit\" de otra pantalla, pero esto nos permite especificar que queremos saltar desde cualquier pantalla a cualquier pantalla, y tambi\u00e9n desde varias pantallas ejecutar la misma \"unwind action\" (volver a una misma pantalla). Para copiar el dato a la propiedad \"nombre\": En el NuevoItemViewController crea un m\u00e9todo prepare(for:,sender:) que se disparar\u00e1 cuando volvamos atr\u00e1s por el unwind segue override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { //TO-DO: coger el valor del campo de texto y asign\u00e1rselo a la propiedad \"nombre\" } Para terminar, en el m\u00e9todo del unwind del ListaViewController debes crear el nuevo item con el nombre especificado, para ello, este m\u00e9todo debe: obtener el valor de la propiedad nombre del NuevoItemViewController . Ten en cuenta que el controller lo puedes obtener de la propiedad source del segue que se recibe como par\u00e1metro, pero debes hacer un cast (puedes hacerlo con as! ) a NuevoItemViewController para que la propiedad nombre sea accesible crear un nuevo objeto de la clase Item con ese nombre y el valor de comprado a false (si lo acabamos de a\u00f1adir no puede estar ya comprado) en el datasource miHelper tienes que a\u00f1adirle a la lista el nuevo Item (m\u00e9todo append ) puedes recargar la tabla para que se muestre el nuevo dato: self.tabla.reloadData() Crear la pantalla de notas y la navegaci\u00f3n hasta ella (0,5 puntos) \u00b6 Para completar la app queremos tener una pantalla con un text view en el que podamos escribir un texto para apuntar algo de lo que queramos acordarnos y que no podemos apuntar en la lista porque no nos cabe. Haremos que se pueda elegir entre la pantalla de lista y la que llamaremos de \"notas\" mediante un tab bar . Selecciona en el storyboard el controller de la primera pantalla (recuerda, cuadro blanco en c\u00edrculo amarillo) y elige la opci\u00f3n de men\u00fa de Editor > Embed in > Tab bar controller . Aparecer\u00e1 un tab bar controller con la primera opci\u00f3n ya asociada a la pantalla de lista. Nos falta crear la pantalla de notas y vincularla al tab bar controller Crea la nueva pantalla en el storyboard , a\u00f1adi\u00e9ndole un Text view que ocupe toda la pantalla (a\u00f1ade las restricciones de autolayout necesarias para esto). No nos va a hacer falta crear c\u00f3digo Swift para este controller ya que en esta pantalla no hay nada de l\u00f3gica propia, solo se puede escribir en el campo de texto. Finalmente conecta el tab bar controller a la pantalla de notas con Ctrl-Arrastrar del rat\u00f3n y entre las opciones de conexi\u00f3n elige Relationship segue - View Controllers . Cambia los iconos y sus nombres en el tab bar para que reflejen las dos secciones de la app : \"lista\" y \"notas\". Lo m\u00e1s sencillo es que uses SF Symbols en lugar de tener que importar iconos de alguna web. El storyboard final de la aplicaci\u00f3n deber\u00eda quedar como el siguiente:","title":"Miniproyecto: Lista de la compra (3 puntos en total)"},{"location":"proyecto/lista_compra/#miniproyecto-lista-de-la-compra-3-puntos-en-total","text":"Vamos a realizar una miniaplicaci\u00f3n para llevar la lista de la compra, podremos introducir productos y marcarlos cuando ya los hayamos comprado. Adem\u00e1s tendremos una pantalla con un cuadro de texto para escribir nuestras notas, cosas que debemos recordar pero no nos caben en la lista. La aplicaci\u00f3n ser\u00e1 funcional pero no guardar\u00e1 los datos de manera persistente. Esto lo veremos en la asignatura de Persistencia en Dispositivos M\u00f3viles.","title":"Miniproyecto: Lista de la compra (3 puntos en total)"},{"location":"proyecto/lista_compra/#organizacion-inicial","text":"Crear un nuevo proyecto, llam\u00e1ndolo ListaCompra Para organizar un poco mejor el c\u00f3digo, vamos a meter en una carpeta los view controllers y renombrar el controller inicial: Bot\u00f3n derecho sobre el ViewController , en el men\u00fa popup \"New Group from Selection\". Llamar Controllers al nuevo grupo Cambiar el nombre de ViewController por ListaViewController , clicando con bot\u00f3n derecho en el c\u00f3digo fuente sobre el nombre de la clase y seleccionando la opci\u00f3n de Refactor > Rename...","title":"Organizaci\u00f3n inicial"},{"location":"proyecto/lista_compra/#funcionalidad-mostrar-lista-de-la-compra-1-punto","text":"","title":"Funcionalidad: Mostrar lista de la compra (1 punto)"},{"location":"proyecto/lista_compra/#crear-la-tabla-en-el-storyboard","text":"Insertar un componente de UI de tipo table view en ListaViewController Ponerle 4 restricciones de autolayout de distancia 0 a los bordes, para que ocupe toda la pantalla del dispositivo Configurar la tabla como din\u00e1mica, y crear la celda prototipo: en las propiedades de la tabla (panel derecho, inspector de propiedades) Asegurarse que el Content es Dynamic prototypes (que es una tabla din\u00e1mica) Incrementar el n\u00famero de Prototype cells a 1 Elegir como style Plain que es un estilo preconfigurado solo con un t\u00edtulo de celda, nos basta para mostrar esta lista Poner como identifier el nombre \"miCelda\" Crear un outlet de la tabla, llamado tabla en ListaViewController","title":"Crear la tabla en el storyboard:"},{"location":"proyecto/lista_compra/#crear-la-fuente-de-datos-de-la-tabla","text":"Crear un nuevo grupo (carpeta para organizar c\u00f3digo): en el panel izquierdo de Xcode, vista \"navegador\", bot\u00f3n derecho sobre la carpeta ListaCompra y en el men\u00fa desplegable, New Group . Llamarlo Lista Crear dentro de este grupo un struct Item , para guardar los datos de un item de la lista struct Item { var nombre : String var comprado : Bool } Crear dentro del grupo Lista la clase ListaHelper : File > New ... > File y en el asistente, elegir Swift File . Crear un fichero llamado ListaHelper , que har\u00e1 de datasource de la tabla. Queremos que aparezca la lista de cosas a comprar y que si ya est\u00e1n compradas aparezca un \"checkmark\" al lado. Puedes copiar el siguiente c\u00f3digo, tienes que completar el segundo m\u00e9todo: import UIKit class ListaHelper : NSObject , UITableViewDataSource { var lista : [ Item ] = [ Item ( nombre : \"pan\" , comprado : true ), Item ( nombre : \"agua\" , comprado : false ), Item ( nombre : \"tomates\" , comprado : true ) ] func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return lista . count } func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { //TO-DO: escribir c\u00f3digo que: //1. obtenga una celda reutilizada llamando a tableView.dequeueReusableCell // Acordarse de usar el identificador \"miCelda\" que hemos configurado antes //2. rellenar el .text de la celda con el nombre del item en la pos correspondiente del array //3. si la propiedad `comprado` del item es `true`, fijar `accesoryType`de la celda a `.checkmark`. Si no, a `none` //4. devolver la celda } } En ListaViewController crear una instancia de ListaHelper y hacer que sea datasource de la tabla: //En la clase ListaViewController //Este outlet ya lo deber\u00edamos tener @IBOutlet weak var tabla : UITableView ! //Declaramos e inicializamos el datasource var miHelper = ListaHelper () override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. //Lo conectamos con la tabla self . tabla . dataSource = miHelper } Ejecutar el proyecto y comprobar que en pantalla aparece la lista de items","title":"Crear la fuente de datos de la tabla"},{"location":"proyecto/lista_compra/#funcionalidad-de-marcardesmarcar-items-05-puntos","text":"El objeto que es \"avisado\" cuando hacemos tap en una celda es el delegate de la tabla, por tanto necesitamos uno, haremos que ListaHelper lo sea: A\u00f1adir el protocolo correspondiente a la cabecera de ListaHelper class ListaHelper : NSObject , UITableViewDataSource , UITableViewDelegate { //... } Implementar el m\u00e9todo didSelectRowAt del delegate, aqu\u00ed tienes el mismo c\u00f3digo que usamos en un ejemplo de la sesi\u00f3n de tablas func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let celda = tableView . cellForRow ( at : indexPath ) { //Si no hay marca de verificaci\u00f3n la ponemos. Si la hay la quitamos if celda . accessoryType == UITableViewCell . AccessoryType . none { celda . accessoryType = . checkmark } else { celda . accessoryType = . none } //deseleccionamos la celda, si no se quedar\u00e1 con el fondo gris tableView . deselectRow ( at : indexPath , animated : true ) } } En el ListaViewController , hay que vincular el delegate de la tabla con la instancia de ListaHelper @IBOutlet weak var tabla : UITableView ! var miHelper = ListaHelper () override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view. self . tabla . dataSource = miHelper **// A\u00d1ADE ESTA LINEA ** ** self . tabla . delegate = miHelper ** }","title":"Funcionalidad de marcar/desmarcar items (0,5 puntos)"},{"location":"proyecto/lista_compra/#funcionalidad-de-nuevo-item-1-punto","text":"Crearemos una nueva pantalla en la app con un campo de texto donde se pueda escribir el nombre del nuevo item de la lista, y un bot\u00f3n de \"guardar\" Desde el punto de vista de la usabilidad seguramente ser\u00eda mejor que se pudieran editar los items de la lista \"in-place\" pero as\u00ed practicamos la navegaci\u00f3n entre pantallas con el Navigation controller .","title":"Funcionalidad de \"nuevo item\" (1 punto)"},{"location":"proyecto/lista_compra/#crear-la-pantalla","text":"En el storyboard , hay que crear la nueva pantalla. Desde el panel de componentes de usuario, arrastrar un view controller nuevo, que ser\u00e1 la pantalla de a\u00f1adir item A\u00f1adirle a este nuevo view controller un cuadro de texto un bot\u00f3n \"guardar\" Fijar las restricciones de autolayout que consideres necesarias para estos componentes, el bot\u00f3n de guardar debe salir debajo del campo de texto Todav\u00eda nos falta que se pueda navegar entre la pantalla de lista y la pantalla de nuevo \u00edtem: Meter la pantalla de lista dentro de un navigation controller : Seleccionar el view controller (bot\u00f3n del c\u00edrculo amarillo con el cuadrado blanco dentro, en la parte superior de la pantalla simulada del dispositivo) , luego ir al men\u00fa Editor > Embed in...> Navigation controller . Aparecer\u00e1 el navigation controller conectado autom\u00e1ticamente a la primera pantalla. En la pantalla de lista habr\u00e1 aparecido una barra de navegaci\u00f3n en su parte superior, seleccionarla, ir a las propiedades y poner como t\u00edtulo \"Lista de la compra\". Vamos a a\u00f1adir el bot\u00f3n para saltar a la siguiente pantalla: Desde el panel de componentes de UI, arrastrar un Bar Button Item a la barra de navegaci\u00f3n de la pantalla de lista, a la parte de la derecha. En las propiedades del nuevo bot\u00f3n elegir como System Item el valor Add para que sea el t\u00edpico bot\u00f3n de \"A\u00f1adir\" por defecto (en iOS suelen aparecer simplemente con un \"+\") Conectar la pantalla de lista con la de nuevo item con ctrl+arrastrar desde este bot\u00f3n \"+\" hasta la pantalla de nuevo item. En el men\u00fa popup elegir como tipo de segue \"show\" Si probamos la app se podr\u00e1 navegar entre las dos pantallas, y volver a la primera desde la segunda gracias al bot\u00f3n con el bot\u00f3n < Lista de la compra que aparecer\u00e1 autom\u00e1ticamente en la barra de navegaci\u00f3n.","title":"Crear la pantalla"},{"location":"proyecto/lista_compra/#crear-el-controller-de-la-nueva-pantalla","text":"Una vez arreglada la navegaci\u00f3n, nos falta implementar la funcionalidad de la segunda pantalla. Primero tenemos que crear su controller : Crear una clase NuevoItemViewController: Bot\u00f3n derecho sobre la carpeta Controllers , seleccionar New File... y en el asistente elegir la plantilla Cocoa Touch Class , viene mejor para crear view controllers . En la segunda pantalla del asistente, poner el nombre de la nueva clase ( NuevoItemViewController ) y especificar que debe ser una subclase de UIViewController Vincular la clase con la pantalla en el storyboard En el storyboard seleccionar la segunda pantalla y en el panel de la derecha ir al \"identity inspector\" (4\u00ba icono) y poner como Class la clase creada, NuevoItemViewController","title":"Crear el controller de la nueva pantalla"},{"location":"proyecto/lista_compra/#implementar-la-funcionalidad-del-boton-guardar","text":"En el NuevoItemViewController creamos: un outlet para el campo de texto una propiedad nombre de tipo String para guardar el mismo dato, ya que desde la pantalla inicial no podemos acceder al campo de texto de la segunda. Queremos que cuando se pulse \"guardar\" se vuelva atr\u00e1s a la primera pantalla y adem\u00e1s se haga una copia del contenido del campo de texto en la propiedad nombre . Para volver atr\u00e1s: Crea una unwind action en ListaViewController para volver atr\u00e1s a esta pantalla desde la de nuevo item: recuerda que es un m\u00e9todo que est\u00e9 marcado con @IBAction y como par\u00e1metros tenga solo uno de tipo UIStoryboardSegue . si escribes \"unwind\" el autocompletar de Xcode te dar\u00e1 accesso a una plantilla de c\u00f3digo para un unwind action , para que no tengas que escribirlo t\u00fa de cero Conecta el bot\u00f3n de guardar de la pantalla de nuevo item con la unwind action (Ctrl+Arrastrar con el icono de \"Exit\" de la parte superior de la pantalla del dispositivo). Xcode buscar\u00e1 todas las \"unwind actions\" de todos los controllers y te mostrar\u00e1 una lista (en este caso solo habr\u00e1 una, la que creaste antes). NOTA: s\u00ed, esta forma de trabajar es \"rara\". Parece raro que el unwind action se cree en la pantalla destino y la conexi\u00f3n se haga desde el \"exit\" de otra pantalla, pero esto nos permite especificar que queremos saltar desde cualquier pantalla a cualquier pantalla, y tambi\u00e9n desde varias pantallas ejecutar la misma \"unwind action\" (volver a una misma pantalla). Para copiar el dato a la propiedad \"nombre\": En el NuevoItemViewController crea un m\u00e9todo prepare(for:,sender:) que se disparar\u00e1 cuando volvamos atr\u00e1s por el unwind segue override func prepare ( for segue : UIStoryboardSegue , sender : Any ?) { //TO-DO: coger el valor del campo de texto y asign\u00e1rselo a la propiedad \"nombre\" } Para terminar, en el m\u00e9todo del unwind del ListaViewController debes crear el nuevo item con el nombre especificado, para ello, este m\u00e9todo debe: obtener el valor de la propiedad nombre del NuevoItemViewController . Ten en cuenta que el controller lo puedes obtener de la propiedad source del segue que se recibe como par\u00e1metro, pero debes hacer un cast (puedes hacerlo con as! ) a NuevoItemViewController para que la propiedad nombre sea accesible crear un nuevo objeto de la clase Item con ese nombre y el valor de comprado a false (si lo acabamos de a\u00f1adir no puede estar ya comprado) en el datasource miHelper tienes que a\u00f1adirle a la lista el nuevo Item (m\u00e9todo append ) puedes recargar la tabla para que se muestre el nuevo dato: self.tabla.reloadData()","title":"Implementar la funcionalidad del bot\u00f3n \"guardar\""},{"location":"proyecto/lista_compra/#crear-la-pantalla-de-notas-y-la-navegacion-hasta-ella-05-puntos","text":"Para completar la app queremos tener una pantalla con un text view en el que podamos escribir un texto para apuntar algo de lo que queramos acordarnos y que no podemos apuntar en la lista porque no nos cabe. Haremos que se pueda elegir entre la pantalla de lista y la que llamaremos de \"notas\" mediante un tab bar . Selecciona en el storyboard el controller de la primera pantalla (recuerda, cuadro blanco en c\u00edrculo amarillo) y elige la opci\u00f3n de men\u00fa de Editor > Embed in > Tab bar controller . Aparecer\u00e1 un tab bar controller con la primera opci\u00f3n ya asociada a la pantalla de lista. Nos falta crear la pantalla de notas y vincularla al tab bar controller Crea la nueva pantalla en el storyboard , a\u00f1adi\u00e9ndole un Text view que ocupe toda la pantalla (a\u00f1ade las restricciones de autolayout necesarias para esto). No nos va a hacer falta crear c\u00f3digo Swift para este controller ya que en esta pantalla no hay nada de l\u00f3gica propia, solo se puede escribir en el campo de texto. Finalmente conecta el tab bar controller a la pantalla de notas con Ctrl-Arrastrar del rat\u00f3n y entre las opciones de conexi\u00f3n elige Relationship segue - View Controllers . Cambia los iconos y sus nombres en el tab bar para que reflejen las dos secciones de la app : \"lista\" y \"notas\". Lo m\u00e1s sencillo es que uses SF Symbols en lugar de tener que importar iconos de alguna web. El storyboard final de la aplicaci\u00f3n deber\u00eda quedar como el siguiente:","title":"Crear la pantalla de notas y la navegaci\u00f3n hasta ella (0,5 puntos)"},{"location":"proyecto/marvel/","text":"Proyecto de la asignatura de interfaces de usuario, parte de iOS b\u00e1sico \u00b6 Este \"miniproyecto\" trata de hacer una peque\u00f1a aplicaci\u00f3n bas\u00e1ndose en el API de la editorial Marvel, que nos permite consultar informaci\u00f3n sobre los personajes, los comics , las series ,... Pasos iniciales \u00b6 Registro en la API de Marvel \u00b6 Para poder usar la API de Marvel hacen falta claves de desarrollador. La plantilla de proyecto disponible en la web ya tiene unas incorporadas. Con esas claves se pueden hacer 3000 peticiones diarias al API, probablemente suficientes para su uso en clase. No obstante tambi\u00e9n puedes registrarte desde el portal de desarrolladores de Marvel para poder obtener claves propias. Acceso a la API \u00b6 La API de Marvel es REST, por lo que acepta peticiones HTTP. No obstante hacerlas directamente con los APIs de iOS ser\u00eda un poco engorroso, por lo que vamos a usar un par de librer\u00edas que nos faciliten no solo hacer la petici\u00f3n en s\u00ed sino sobre todo parsear el JSON. Usaremos una librer\u00eda adicional llamada Marvelous, que encapsula las llamadas al API en una serie de clases de modo que no tenemos que hacer peticiones HTTP directamente. IMPORTANTE : para acelerar el trabajo en el aula ten\u00e9is disponible en moodle la plantilla de workspace ya creada. Uso de la plantilla de proyecto \u00b6 En la plantilla de workspace descargada abre el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Si lo has abierto correctamente, deber\u00edas ver dos proyectos, uno llamado Marvel , y otro llamado Pods . El proyecto principal es el primero, el segundo son librer\u00edas auxiliares. Si quieres ver m\u00e1s informaci\u00f3n sobre la estructura del proyecto, o c\u00f3mo crearlo partiendo de cero, puedes verlo en el Ap\u00e9ndice Primero hay que hacer un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Una vez hecho esto podemos ejecutar la app, en la consola aparecer\u00e1 una lista de personajes cuyo nombre empieza por \"Spider\". Puedes mirar el c\u00f3digo del View Controller para ver c\u00f3mo se ha hecho. Una vez hecho el build , puedes comprobar si la conexi\u00f3n con el API funciona bien ejecutando la aplicaci\u00f3n, no ver\u00e1s nada en la pantalla del simulador pero en la consola de Xcode deber\u00eda aparecer una lista de personajes que comienzan por \"spider\". Puedes examinar el c\u00f3digo del view controller para ver c\u00f3mo se ha hecho, usamos una librer\u00eda auxiliar llamada Marvelous que implementa el acceso al API de forma sencilla. Estructura que debe tener la aplicaci\u00f3n \u00b6 Para que te hagas una idea de la estructura, se muestra el storyboard de la aplicaci\u00f3n ya terminada En la aplicaci\u00f3n se podr\u00e1 buscar, listar y mostrar los detalles de alguno de los recursos que ofrece el API. Elige t\u00fa lo que prefieras: personajes, comics, creadores... Pantalla inicial \u00b6 Puedes comenzar creando un tab bar a partir de la pantalla inicial: selecci\u00f3nala y en el men\u00fa Editor elige Embed In > Tab Bar Controller . Vista maestro (2 puntos) \u00b6 Esta debe ser una pantalla con una barra de b\u00fasqueda y una vista de tabla en la que se puede buscar y listar el recurso elegido (por ejemplo personajes). El resultado final ser\u00e1 algo como: Ve a la primera (y por el momento \u00fanica) pantalla de contenido del tab bar , selecciona la barra inferior y en las propiedades bar item ponle un t\u00edtulo apropiado (por ejemplo \"Personajes\") y un icono relevante. Recuerda que tienes unas cuantas webs de donde puedes coger iconos \"planos\", por ejemplo https://www.iconfinder.com/iconsets/ios-7-icons o http://www.flaticon.com/packs/line-icon-set Crear los componentes de la interfaz \u00b6 La tabla: Arrastra una table view a la pantalla de \"personajes\" (o \"comics\", o lo que hayas elegido) Selecciona la tabla y en las propiedades crea un prototipo de celda incrementando el Prototype cells a 1. Selecciona el prototipo de celda reci\u00e9n creado (el table view cell ) y en las propiedades elige como style el valor Basic , para poder usar uno de los tipos predefinidos de celda y no tener que hacerlo t\u00fa. La barra de b\u00fasqueda: Arrastra un componente de tipo search bar a la pantalla y d\u00e9jalo justo arriba de la tabla. Nos falta fijar el autolayout : Selecciona barra y tabla manteniendo pulsada la tecla Cmd e inserta ambas en un stack view utilizando el primero de los botones de autolayout (parte inferior derecha del *storyboard) Haz que este stack view ocupe toda la pantalla. Lo m\u00e1s sencillo es ponerle 4 restricciones de distancia 0 a los bordes. Una vez hecho esto puedes poner en marcha la app para ver si la interfaz tiene buen aspecto. La tabla aparecer\u00e1 vac\u00eda, por supuesto. Gestionar la barra de b\u00fasqueda \u00b6 La barra de b\u00fasqueda utiliza el patr\u00f3n delegaci\u00f3n para gestionar los eventos de escribir en ella, pulsar \"buscar\" en el teclado, etc. El objeto que act\u00fae como delegate de la barra de b\u00fasqueda debe implementar el protocolo UISearchBarDelegate . Puede ser cualquiera, aunque siguiendo la filosof\u00eda MVC (Monster View Controller) haremos que sea el view controller de la pantalla actual :). Vamos a crear este view controller : Crea una nueva clase de Cocoa Touch llamada ListaController y haz que sea una subclase de UIViewController As\u00edgnale ese controller a la pantalla de lista que has creado antes. Recuerda que esto se hace a trav\u00e9s del identity inspector . Ahora vamos a conectar el view controller con la barra de b\u00fasqueda: Selecciona la search bar (te ser\u00e1 m\u00e1s f\u00e1cil si lo haces en el \u00e1rbol de componentes) y en el connections inspector (panel de la derecha de Xcode, icono de m\u00e1s a la derecha) conecta el outlet delegate con el controller de esta pantalla. Recuerda que el controller est\u00e1 representado gr\u00e1ficamente con un icono de color amarillo que aparece en la parte superior de cada pantalla de la app en el storyboard . Si has hecho esto ya no es necesario que establezcas la conexi\u00f3n por c\u00f3digo, asignando la propiedad delegate de la barra de b\u00fasqueda al controller Pon en la cabecera ListaController que esta clase implementa el protocolo UISearchBarDelegate En el ListaController implementa el m\u00e9todo searchBarSearchButtonClicked(_) , que se llamar\u00e1 cuando se escriba algo en la barra y se pulse el bot\u00f3n del teclado \"buscar\". Para probar que funciona de momento basta que imprimas en la consola el texto escrito en la barra y quites el teclado on screen . func searchBarSearchButtonClicked ( _ searchBar : UISearchBar ) { print ( \"Buscado: \\( searchBar . text ! ) \" ) searchBar . resignFirstResponder () } Ejecuta la app y comprueba que efectivamente funciona. Ahora tendr\u00e1s que poner c\u00f3digo propio para que cuando se pulse en el bot\u00f3n de buscar se haga la llamada a la API de Marvel. Por el momento lo m\u00e1s simple es mostrar los resultados con print . Puedes asign\u00e1rselos tambi\u00e9n a un array que sea una propiedad del controller , para que luego sean sencillos de mostrar en la tabla. Mostrar los resultados en la tabla \u00b6 Una vez conseguido esto, tendr\u00e1s que hacer que los resultados aparezcan en la tabla. Recuerda que necesitas un datasource para ella, y que para simplificar puedes hacer que sea el ListaController . A grandes rasgos esto implica: Que, como dec\u00edamos antes, el controller debe tener acceso a los datos, por ejemplo guard\u00e1ndolos en una propiedad que sea un array. Que tienes que conectar en el connections inspector el outlet datasource con el controller . Que el ListaController debe implementar el protocolo UITableViewDataSource . Hay que poner en la cabecera que esto es as\u00ed, y adem\u00e1s implementar los correspondientes m\u00e9todos en el c\u00f3digo del controller , uno para devolver el n\u00famero de filas en la tabla y otro para devolver una celda dado su indexPath . Cada vez que se haga una b\u00fasqueda y se a\u00f1adan datos al array tendr\u00e1s que decirle a iOS que vuelva a redibujar la tabla llamando a su m\u00e9todo reloadData . Cuidado, porque al ser una actualizaci\u00f3n de la interfaz debes asegurarte de que esto lo est\u00e1s haciendo desde el thread principal, algo como: //sustituye self.vistaTabla por el outlet que hayas definido //para acceder a la tabla desde el controlador OperationQueue . main . addOperation () { self . vistaTabla . reloadData (); } Obtener la cola principal de operaciones expl\u00edcitamente es necesario si, como es lo m\u00e1s l\u00f3gico, colocas el c\u00f3digo anterior en el bloque que obtiene la respuesta del API de Marvel. Recuerda que para evitar bloqueos, Marvelous funciona de modo as\u00edncrono en un thread distinto al principal Una vez terminado todo esto, esta pantalla deber\u00eda ser casi totalmente funcional. Solo quedar\u00eda ver los detalles de cada item al hacer tap sobre \u00e9l. Opcionalmente (0,25 puntos extra) , puedes hacer que aparezca un spinner mientras se est\u00e1 procesando la petici\u00f3n, para que el usuario sepa que el sistema est\u00e1 esperando datos. Los spinners en iOS se denominan Activity Indicators . Puedes consultar la referencia de la clase UIActivityIndicator para ver la forma de uso, aunque es muy sencillo, b\u00e1sicamente debes hacer startAnimating para que empiece a girar y stopAnimating para pararlo. Es posible que el activity indicator se te quede detr\u00e1s de los otros elementos de interfaz y no se vea. Puedes usar el m\u00e9todo bringSubviewToFront que se llama desde la vista \"madre\" para pasar a una vista \"hija\" a \"primer plano\". Si estamos en el controller ser\u00eda algo como self.view bringSubview(toFront:self.miActivityIndicator) , ya que recuerda que self.view en un controller es la vista principal. Tendr\u00e1s que sustituir la referencia self.miActivityIndicator por la apropiada en tu caso. Adem\u00e1s de esto lleva cuidado tambi\u00e9n con el color, otro problema t\u00edpico es usar uno del mismo color que el fondo. Vista de detalle (1,5 puntos) \u00b6 La nueva pantalla mostrar\u00e1 los datos de un item al hacer tap . Como una vez en los detalles queremos poder volver atr\u00e1s al listado de forma sencilla, lo mejor es usar un navigation controller : El navigation controller \u00b6 En este apartado todav\u00eda no estamos implementando la vista de detalle, solo creando la jerarqu\u00eda de navegaci\u00f3n. Selecciona la pantalla de lista y elige la opci\u00f3n de men\u00fa Editor > Embed In > Navigation Controller . Aparecer\u00e1 un nuevo navigation controller que tiene como primer nivel de navegaci\u00f3n a la pantalla de lista de items. Fijate que en la parte superior de la pantalla de items habr\u00e1 aparecido un espacio reservado para el t\u00edtulo y los botones de navegaci\u00f3n. Esto puede haber \"trastocado\" en modo dise\u00f1o el resto de los elementos de la interfaz (aunque cuando se ejecute la app deber\u00edan seguir funcionando bien). Recuerda que puedes volverlos \"a su sitio\" en modo dise\u00f1o con el Update Frames del autolayout . Selecciona la nueva barra de t\u00edtulo de la vista de lista y en las propiedades pon como title el recurso que est\u00e1s mostrando (personajes, autores, comics,...). La pantalla de detalles del item \u00b6 Esta ser\u00eda la que muestra todos los datos de un personaje, comic, creador,... junto a su imagen si es que la tiene. Si quieres usar una tabla est\u00e1tica para dise\u00f1ar esta pantalla debes usar como controller una clase que herede de UITableViewController Creaci\u00f3n de la interfaz y conexi\u00f3n con la pantalla anterior \u00b6 Arrastra un \"view controller\" al storyboard En la pantalla anterior, haz ctrl+arrastrar entre la celda prototipo y la pantalla actual. Elige el tipo adecuado de segue . Implementa una clase DetalleViewController que herede de UIViewController y as\u00f3ciala a esta pantalla. Implementaci\u00f3n de la funcionalidad \u00b6 Define en el DetalleViewController una propiedad del tipo de recurso que est\u00e9s mostrando ( RCCharacterObject , RCComicsObject , RCCreatorObject ,...) En el prepareForSegue de la pantalla de lista instancia esta propiedad para que contenga el objeto a mostrar. Para saber qu\u00e9 fila de la tabla se ha seleccionado puedes seleccionar la propiedad del objeto tabla llamada indexPathForSelectedRow , que almacena el indexPath de la fila seleccionada. La propiedad row de este index path es el n\u00famero de fila. Usa los componentes que consideres necesarios para mostrar los datos del objeto (no es necesario que sean todos, solo los que quieras, para probar que funciona). Tendr\u00e1s que crear un outlet por cada campo, y rellenar los campos en el viewDidLoad del controller . Puedes consultar la referencia de clases en la documentaci\u00f3n online de Marvelous para saber qu\u00e9 propiedades tiene cada objeto. La referencia est\u00e1 en Objective-C pero no es dif\u00edcil deducir qu\u00e9 es cada propiedad Entre otras cosas, en esta pantalla deber\u00edas mostrar la imagen del personaje, comic, creador o lo que sea que hayas elegido, a un tama\u00f1o relativamente peque\u00f1o. La carga de la imagen deber\u00edas hacerla en un hilo secundario, para no paralizar la interfaz de usuario si la imagen tarda en cargarse: let colaBackground = OperationQueue () colaBackground . addOperation { //SUPONIENDO que la variable con el personaje se llama \"personaje\" if let thumb = personaje . thumbnail { let url = \" \\( thumb . basePath ! ) /portrait_uncanny. \\( thumb . extension ! ) \" //cambiamos la URL por https://. Necesario en iOS>=9 let urlHttps = url . replacingOccurrences ( of : \"http\" , with : \"https\" ) if let urlFinal = URL ( string : urlHttps ) { do { let datos = try Data ( contentsOf : urlFinal ) if let img = UIImage ( data : datos ) { OperationQueue . main . addOperation { //suponiendo que el outlet de la imagen se llama \"miImagen\" self . miImagen . image = img } } } catch { } } } } Puedes consultar esta p\u00e1gina para ver el formato de las URL de las im\u00e1genes. B\u00e1sicamente se construyen con una trayectoria base seguidas de un \"modificador\" de aspecto y tama\u00f1o ( portrait_small , landscape_medium , ...) y la extensi\u00f3n del archivo. En el c\u00f3digo anterior se obtiene la URL de la imagen y luego se cambia el http: por https: . En iOS>=9 una app no puede hacer una petici\u00f3n a una URL web si no es con https: . Esto deber\u00eda cambiarse en la propia librer\u00eda Marvelous , pero podemos salir del paso con este peque\u00f1o parche . Imagen a tama\u00f1o completo (1 punto) \u00b6 Implementa una nueva pantalla en la que se pueda ver solo la imagen a mayor tama\u00f1o. Haz que la transici\u00f3n se realice con un segue modal pulsando sobre alg\u00fan bot\u00f3n \"ver imagen ampliada\" (si tienes activadas las size classes el tipo equivalente es present modally ). En el API de Marvel, la URL de la imagen a tama\u00f1o completo se consigue simplemente concatenando las propiedades basePath y extension , y a\u00f1adiendo un punto entre ellas, de modo que ser\u00eda pr\u00e1cticamente igual al c\u00f3digo para cargar la imagen en la pantalla anterior pero sin poner el \"modificador\" (en el ejemplo era portrait-uncanny ). La pantalla debe tener alg\u00fan bot\u00f3n o similar para volver a la anterior. Vista \"Acerca de\" (0,25 puntos) \u00b6 Esta es la segunda de las pantallas del tab bar . Simplemente debe consistir en una imagen est\u00e1tica y un text view con informaci\u00f3n sobre la aplicaci\u00f3n. Ap\u00e9ndice: creaci\u00f3n de la plantilla de proyecto desde cero \u00b6 Esta secci\u00f3n est\u00e1 solo para que veas c\u00f3mo se ha creado la plantilla de proyecto, no es necesario que lo hagas si has usado la plantilla que est\u00e1 en moodle. Hasta Xcode 11 no hab\u00eda ning\u00fan sistema de gesti\u00f3n de dependencias de librer\u00edas de terceros para iOS incluido en el IDE. Desde Xcode 11 tenemos el Swift Package Manager , pero durante todo el tiempo que no ha existido una herramienta propia de Apple, la comunidad ha tenido que \"cubrir ese hueco\" desarrollando gestores de paquetes para iOS. Probablemente el m\u00e1s conocido sea CocoaPods que es el que vamos a usar aqu\u00ed. Cocoapods es a la vez un repositorio de librer\u00edas y un gestor de dependencias para instalar autom\u00e1ticamente estas librer\u00edas en nuestros proyectos. Hay muchas librer\u00edas de terceros disponibles con este sistema, puedes buscarlas desde la p\u00e1gina de CocoaPods. Para instalar cocoapods , desde la terminal hacer #Con --pre decimos que queremos instalar la \u00faltima versi\u00f3n, aunque sea RC sudo gem install -n /usr/local/bin cocoapods --pre Esto instala la herramienta desde un repositorio de Internet, as\u00ed que necesitar\u00e1s conectividad...y paciencia, seg\u00fan vaya la red. Si todo va bien se instalar\u00e1 un comando llamado pod . Ejec\u00fatalo desde la terminal para comprobar que existe y no da error. Ahora debes seguir estos pasos: Crear un proyecto Xcode para la aplicaci\u00f3n. Ll\u00e1malo por ejemplo Marvel Con un editor de textos cualquiera, crear un fichero llamado Podfile en el directorio del proyecto (el que contiene el fichero .xcodeproj ). Este archivo debe contener la configuraci\u00f3n y las dependencias (o pods ) del proyecto #SUSTITUYE la versi\u00f3n de ios por la que quieras usar como target de tu app platform :ios , '16.0' use_frameworks! #SUSTITUYE 'Marvel' por el nombre de tu proyecto, si no se llama as\u00ed!!! target 'Marvel' do pod 'MarvelApiWrapper' pod 'SwiftyJSON' , '~> 4.0' end Abre una terminal. Mu\u00e9vete hasta el directorio donde est\u00e1 el Podfile y desde \u00e9l ejecuta el comando pod install . Las dependencias de nuestro proyecto se bajar\u00e1n autom\u00e1ticamente y se crear\u00e1 en el directorio actual un Marvel.xcworkspace A partir de ahora para trabajar en el proyecto siempre abriremos el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Veremos que en Xcode se muestra nuestro proyecto y adem\u00e1s un proyecto adicional llamado Pods , que contiene las dependencias. Este \u00faltimo no lo tocaremos, pero es necesario que est\u00e9 ah\u00ed para que funcione el nuestro. Uso de Marvelous \u00b6 ANTES de empezar a escribir c\u00f3digo aseg\u00farate de hacer en Xcode un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Para poder hacer llamadas al API de Marvel necesitas un par de claves. Las puedes ver, una vez dado de alta y autentificado en Marvel, en https://developer.marvel.com/account El siguiente c\u00f3digo ya est\u00e1 metido en la plantilla, si te la has bajado. Solo es necesario poner en marcha el proyecto para probar si sale en la consola la lista de personajes. Para probar de manera sencilla la librer\u00eda Marvelous puedes poner este import en el ViewController import Marvelous Y ahora copiar la siguiente funci\u00f3n en el view controller , quemuestran en la consola todos los personajes cuyo nombre comienza por una determinada cadena. func mostrarPersonajes ( comienzanPor cadena : String ) { let marvelAPI = RCMarvelAPI () //PUEDES CAMBIAR ESTO PARA PONER TUS CLAVES marvelAPI . publicKey = \"a6927e7e15930110aade56ef90244f6d\" marvelAPI . privateKey = \"487b621fc3c0d6f128b468ba86c99c508f24d357\" let filtro = RCCharacterFilter () filtro . nameStartsWith = cadena marvelAPI . characters ( by : filtro ) { resultados , info , error in if let personajes = resultados as ! [ RCCharacterObject ]? { for personaje in personajes { print ( personaje . name ) } print ( \"Hay \\( personajes . count ) personajes\" ) } } } Puedes llamar a la funci\u00f3n anterior desde el viewDidLoad del view controller override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view, typically from a nib. mostrarPersonajes ( comienzanPor : \"Spider\" ) }","title":"Proyecto de la asignatura de interfaces de usuario, parte de iOS b\u00e1sico"},{"location":"proyecto/marvel/#proyecto-de-la-asignatura-de-interfaces-de-usuario-parte-de-ios-basico","text":"Este \"miniproyecto\" trata de hacer una peque\u00f1a aplicaci\u00f3n bas\u00e1ndose en el API de la editorial Marvel, que nos permite consultar informaci\u00f3n sobre los personajes, los comics , las series ,...","title":"Proyecto de la asignatura de interfaces de usuario, parte de iOS b\u00e1sico"},{"location":"proyecto/marvel/#pasos-iniciales","text":"","title":"Pasos iniciales"},{"location":"proyecto/marvel/#registro-en-la-api-de-marvel","text":"Para poder usar la API de Marvel hacen falta claves de desarrollador. La plantilla de proyecto disponible en la web ya tiene unas incorporadas. Con esas claves se pueden hacer 3000 peticiones diarias al API, probablemente suficientes para su uso en clase. No obstante tambi\u00e9n puedes registrarte desde el portal de desarrolladores de Marvel para poder obtener claves propias.","title":"Registro en la API de Marvel"},{"location":"proyecto/marvel/#acceso-a-la-api","text":"La API de Marvel es REST, por lo que acepta peticiones HTTP. No obstante hacerlas directamente con los APIs de iOS ser\u00eda un poco engorroso, por lo que vamos a usar un par de librer\u00edas que nos faciliten no solo hacer la petici\u00f3n en s\u00ed sino sobre todo parsear el JSON. Usaremos una librer\u00eda adicional llamada Marvelous, que encapsula las llamadas al API en una serie de clases de modo que no tenemos que hacer peticiones HTTP directamente. IMPORTANTE : para acelerar el trabajo en el aula ten\u00e9is disponible en moodle la plantilla de workspace ya creada.","title":"Acceso a la API"},{"location":"proyecto/marvel/#uso-de-la-plantilla-de-proyecto","text":"En la plantilla de workspace descargada abre el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Si lo has abierto correctamente, deber\u00edas ver dos proyectos, uno llamado Marvel , y otro llamado Pods . El proyecto principal es el primero, el segundo son librer\u00edas auxiliares. Si quieres ver m\u00e1s informaci\u00f3n sobre la estructura del proyecto, o c\u00f3mo crearlo partiendo de cero, puedes verlo en el Ap\u00e9ndice Primero hay que hacer un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Una vez hecho esto podemos ejecutar la app, en la consola aparecer\u00e1 una lista de personajes cuyo nombre empieza por \"Spider\". Puedes mirar el c\u00f3digo del View Controller para ver c\u00f3mo se ha hecho. Una vez hecho el build , puedes comprobar si la conexi\u00f3n con el API funciona bien ejecutando la aplicaci\u00f3n, no ver\u00e1s nada en la pantalla del simulador pero en la consola de Xcode deber\u00eda aparecer una lista de personajes que comienzan por \"spider\". Puedes examinar el c\u00f3digo del view controller para ver c\u00f3mo se ha hecho, usamos una librer\u00eda auxiliar llamada Marvelous que implementa el acceso al API de forma sencilla.","title":"Uso de la plantilla de proyecto"},{"location":"proyecto/marvel/#estructura-que-debe-tener-la-aplicacion","text":"Para que te hagas una idea de la estructura, se muestra el storyboard de la aplicaci\u00f3n ya terminada En la aplicaci\u00f3n se podr\u00e1 buscar, listar y mostrar los detalles de alguno de los recursos que ofrece el API. Elige t\u00fa lo que prefieras: personajes, comics, creadores...","title":"Estructura que debe tener la aplicaci\u00f3n"},{"location":"proyecto/marvel/#pantalla-inicial","text":"Puedes comenzar creando un tab bar a partir de la pantalla inicial: selecci\u00f3nala y en el men\u00fa Editor elige Embed In > Tab Bar Controller .","title":"Pantalla inicial"},{"location":"proyecto/marvel/#vista-maestro-2-puntos","text":"Esta debe ser una pantalla con una barra de b\u00fasqueda y una vista de tabla en la que se puede buscar y listar el recurso elegido (por ejemplo personajes). El resultado final ser\u00e1 algo como: Ve a la primera (y por el momento \u00fanica) pantalla de contenido del tab bar , selecciona la barra inferior y en las propiedades bar item ponle un t\u00edtulo apropiado (por ejemplo \"Personajes\") y un icono relevante. Recuerda que tienes unas cuantas webs de donde puedes coger iconos \"planos\", por ejemplo https://www.iconfinder.com/iconsets/ios-7-icons o http://www.flaticon.com/packs/line-icon-set","title":"Vista maestro (2 puntos)"},{"location":"proyecto/marvel/#crear-los-componentes-de-la-interfaz","text":"La tabla: Arrastra una table view a la pantalla de \"personajes\" (o \"comics\", o lo que hayas elegido) Selecciona la tabla y en las propiedades crea un prototipo de celda incrementando el Prototype cells a 1. Selecciona el prototipo de celda reci\u00e9n creado (el table view cell ) y en las propiedades elige como style el valor Basic , para poder usar uno de los tipos predefinidos de celda y no tener que hacerlo t\u00fa. La barra de b\u00fasqueda: Arrastra un componente de tipo search bar a la pantalla y d\u00e9jalo justo arriba de la tabla. Nos falta fijar el autolayout : Selecciona barra y tabla manteniendo pulsada la tecla Cmd e inserta ambas en un stack view utilizando el primero de los botones de autolayout (parte inferior derecha del *storyboard) Haz que este stack view ocupe toda la pantalla. Lo m\u00e1s sencillo es ponerle 4 restricciones de distancia 0 a los bordes. Una vez hecho esto puedes poner en marcha la app para ver si la interfaz tiene buen aspecto. La tabla aparecer\u00e1 vac\u00eda, por supuesto.","title":"Crear los componentes de la interfaz"},{"location":"proyecto/marvel/#gestionar-la-barra-de-busqueda","text":"La barra de b\u00fasqueda utiliza el patr\u00f3n delegaci\u00f3n para gestionar los eventos de escribir en ella, pulsar \"buscar\" en el teclado, etc. El objeto que act\u00fae como delegate de la barra de b\u00fasqueda debe implementar el protocolo UISearchBarDelegate . Puede ser cualquiera, aunque siguiendo la filosof\u00eda MVC (Monster View Controller) haremos que sea el view controller de la pantalla actual :). Vamos a crear este view controller : Crea una nueva clase de Cocoa Touch llamada ListaController y haz que sea una subclase de UIViewController As\u00edgnale ese controller a la pantalla de lista que has creado antes. Recuerda que esto se hace a trav\u00e9s del identity inspector . Ahora vamos a conectar el view controller con la barra de b\u00fasqueda: Selecciona la search bar (te ser\u00e1 m\u00e1s f\u00e1cil si lo haces en el \u00e1rbol de componentes) y en el connections inspector (panel de la derecha de Xcode, icono de m\u00e1s a la derecha) conecta el outlet delegate con el controller de esta pantalla. Recuerda que el controller est\u00e1 representado gr\u00e1ficamente con un icono de color amarillo que aparece en la parte superior de cada pantalla de la app en el storyboard . Si has hecho esto ya no es necesario que establezcas la conexi\u00f3n por c\u00f3digo, asignando la propiedad delegate de la barra de b\u00fasqueda al controller Pon en la cabecera ListaController que esta clase implementa el protocolo UISearchBarDelegate En el ListaController implementa el m\u00e9todo searchBarSearchButtonClicked(_) , que se llamar\u00e1 cuando se escriba algo en la barra y se pulse el bot\u00f3n del teclado \"buscar\". Para probar que funciona de momento basta que imprimas en la consola el texto escrito en la barra y quites el teclado on screen . func searchBarSearchButtonClicked ( _ searchBar : UISearchBar ) { print ( \"Buscado: \\( searchBar . text ! ) \" ) searchBar . resignFirstResponder () } Ejecuta la app y comprueba que efectivamente funciona. Ahora tendr\u00e1s que poner c\u00f3digo propio para que cuando se pulse en el bot\u00f3n de buscar se haga la llamada a la API de Marvel. Por el momento lo m\u00e1s simple es mostrar los resultados con print . Puedes asign\u00e1rselos tambi\u00e9n a un array que sea una propiedad del controller , para que luego sean sencillos de mostrar en la tabla.","title":"Gestionar la barra de b\u00fasqueda"},{"location":"proyecto/marvel/#mostrar-los-resultados-en-la-tabla","text":"Una vez conseguido esto, tendr\u00e1s que hacer que los resultados aparezcan en la tabla. Recuerda que necesitas un datasource para ella, y que para simplificar puedes hacer que sea el ListaController . A grandes rasgos esto implica: Que, como dec\u00edamos antes, el controller debe tener acceso a los datos, por ejemplo guard\u00e1ndolos en una propiedad que sea un array. Que tienes que conectar en el connections inspector el outlet datasource con el controller . Que el ListaController debe implementar el protocolo UITableViewDataSource . Hay que poner en la cabecera que esto es as\u00ed, y adem\u00e1s implementar los correspondientes m\u00e9todos en el c\u00f3digo del controller , uno para devolver el n\u00famero de filas en la tabla y otro para devolver una celda dado su indexPath . Cada vez que se haga una b\u00fasqueda y se a\u00f1adan datos al array tendr\u00e1s que decirle a iOS que vuelva a redibujar la tabla llamando a su m\u00e9todo reloadData . Cuidado, porque al ser una actualizaci\u00f3n de la interfaz debes asegurarte de que esto lo est\u00e1s haciendo desde el thread principal, algo como: //sustituye self.vistaTabla por el outlet que hayas definido //para acceder a la tabla desde el controlador OperationQueue . main . addOperation () { self . vistaTabla . reloadData (); } Obtener la cola principal de operaciones expl\u00edcitamente es necesario si, como es lo m\u00e1s l\u00f3gico, colocas el c\u00f3digo anterior en el bloque que obtiene la respuesta del API de Marvel. Recuerda que para evitar bloqueos, Marvelous funciona de modo as\u00edncrono en un thread distinto al principal Una vez terminado todo esto, esta pantalla deber\u00eda ser casi totalmente funcional. Solo quedar\u00eda ver los detalles de cada item al hacer tap sobre \u00e9l. Opcionalmente (0,25 puntos extra) , puedes hacer que aparezca un spinner mientras se est\u00e1 procesando la petici\u00f3n, para que el usuario sepa que el sistema est\u00e1 esperando datos. Los spinners en iOS se denominan Activity Indicators . Puedes consultar la referencia de la clase UIActivityIndicator para ver la forma de uso, aunque es muy sencillo, b\u00e1sicamente debes hacer startAnimating para que empiece a girar y stopAnimating para pararlo. Es posible que el activity indicator se te quede detr\u00e1s de los otros elementos de interfaz y no se vea. Puedes usar el m\u00e9todo bringSubviewToFront que se llama desde la vista \"madre\" para pasar a una vista \"hija\" a \"primer plano\". Si estamos en el controller ser\u00eda algo como self.view bringSubview(toFront:self.miActivityIndicator) , ya que recuerda que self.view en un controller es la vista principal. Tendr\u00e1s que sustituir la referencia self.miActivityIndicator por la apropiada en tu caso. Adem\u00e1s de esto lleva cuidado tambi\u00e9n con el color, otro problema t\u00edpico es usar uno del mismo color que el fondo.","title":"Mostrar los resultados en la tabla"},{"location":"proyecto/marvel/#vista-de-detalle-15-puntos","text":"La nueva pantalla mostrar\u00e1 los datos de un item al hacer tap . Como una vez en los detalles queremos poder volver atr\u00e1s al listado de forma sencilla, lo mejor es usar un navigation controller :","title":"Vista de detalle (1,5 puntos)"},{"location":"proyecto/marvel/#el-navigation-controller","text":"En este apartado todav\u00eda no estamos implementando la vista de detalle, solo creando la jerarqu\u00eda de navegaci\u00f3n. Selecciona la pantalla de lista y elige la opci\u00f3n de men\u00fa Editor > Embed In > Navigation Controller . Aparecer\u00e1 un nuevo navigation controller que tiene como primer nivel de navegaci\u00f3n a la pantalla de lista de items. Fijate que en la parte superior de la pantalla de items habr\u00e1 aparecido un espacio reservado para el t\u00edtulo y los botones de navegaci\u00f3n. Esto puede haber \"trastocado\" en modo dise\u00f1o el resto de los elementos de la interfaz (aunque cuando se ejecute la app deber\u00edan seguir funcionando bien). Recuerda que puedes volverlos \"a su sitio\" en modo dise\u00f1o con el Update Frames del autolayout . Selecciona la nueva barra de t\u00edtulo de la vista de lista y en las propiedades pon como title el recurso que est\u00e1s mostrando (personajes, autores, comics,...).","title":"El navigation controller"},{"location":"proyecto/marvel/#la-pantalla-de-detalles-del-item","text":"Esta ser\u00eda la que muestra todos los datos de un personaje, comic, creador,... junto a su imagen si es que la tiene. Si quieres usar una tabla est\u00e1tica para dise\u00f1ar esta pantalla debes usar como controller una clase que herede de UITableViewController","title":"La pantalla de detalles del item"},{"location":"proyecto/marvel/#creacion-de-la-interfaz-y-conexion-con-la-pantalla-anterior","text":"Arrastra un \"view controller\" al storyboard En la pantalla anterior, haz ctrl+arrastrar entre la celda prototipo y la pantalla actual. Elige el tipo adecuado de segue . Implementa una clase DetalleViewController que herede de UIViewController y as\u00f3ciala a esta pantalla.","title":"Creaci\u00f3n de la interfaz y conexi\u00f3n con la pantalla anterior"},{"location":"proyecto/marvel/#implementacion-de-la-funcionalidad","text":"Define en el DetalleViewController una propiedad del tipo de recurso que est\u00e9s mostrando ( RCCharacterObject , RCComicsObject , RCCreatorObject ,...) En el prepareForSegue de la pantalla de lista instancia esta propiedad para que contenga el objeto a mostrar. Para saber qu\u00e9 fila de la tabla se ha seleccionado puedes seleccionar la propiedad del objeto tabla llamada indexPathForSelectedRow , que almacena el indexPath de la fila seleccionada. La propiedad row de este index path es el n\u00famero de fila. Usa los componentes que consideres necesarios para mostrar los datos del objeto (no es necesario que sean todos, solo los que quieras, para probar que funciona). Tendr\u00e1s que crear un outlet por cada campo, y rellenar los campos en el viewDidLoad del controller . Puedes consultar la referencia de clases en la documentaci\u00f3n online de Marvelous para saber qu\u00e9 propiedades tiene cada objeto. La referencia est\u00e1 en Objective-C pero no es dif\u00edcil deducir qu\u00e9 es cada propiedad Entre otras cosas, en esta pantalla deber\u00edas mostrar la imagen del personaje, comic, creador o lo que sea que hayas elegido, a un tama\u00f1o relativamente peque\u00f1o. La carga de la imagen deber\u00edas hacerla en un hilo secundario, para no paralizar la interfaz de usuario si la imagen tarda en cargarse: let colaBackground = OperationQueue () colaBackground . addOperation { //SUPONIENDO que la variable con el personaje se llama \"personaje\" if let thumb = personaje . thumbnail { let url = \" \\( thumb . basePath ! ) /portrait_uncanny. \\( thumb . extension ! ) \" //cambiamos la URL por https://. Necesario en iOS>=9 let urlHttps = url . replacingOccurrences ( of : \"http\" , with : \"https\" ) if let urlFinal = URL ( string : urlHttps ) { do { let datos = try Data ( contentsOf : urlFinal ) if let img = UIImage ( data : datos ) { OperationQueue . main . addOperation { //suponiendo que el outlet de la imagen se llama \"miImagen\" self . miImagen . image = img } } } catch { } } } } Puedes consultar esta p\u00e1gina para ver el formato de las URL de las im\u00e1genes. B\u00e1sicamente se construyen con una trayectoria base seguidas de un \"modificador\" de aspecto y tama\u00f1o ( portrait_small , landscape_medium , ...) y la extensi\u00f3n del archivo. En el c\u00f3digo anterior se obtiene la URL de la imagen y luego se cambia el http: por https: . En iOS>=9 una app no puede hacer una petici\u00f3n a una URL web si no es con https: . Esto deber\u00eda cambiarse en la propia librer\u00eda Marvelous , pero podemos salir del paso con este peque\u00f1o parche .","title":"Implementaci\u00f3n de la funcionalidad"},{"location":"proyecto/marvel/#imagen-a-tamano-completo-1-punto","text":"Implementa una nueva pantalla en la que se pueda ver solo la imagen a mayor tama\u00f1o. Haz que la transici\u00f3n se realice con un segue modal pulsando sobre alg\u00fan bot\u00f3n \"ver imagen ampliada\" (si tienes activadas las size classes el tipo equivalente es present modally ). En el API de Marvel, la URL de la imagen a tama\u00f1o completo se consigue simplemente concatenando las propiedades basePath y extension , y a\u00f1adiendo un punto entre ellas, de modo que ser\u00eda pr\u00e1cticamente igual al c\u00f3digo para cargar la imagen en la pantalla anterior pero sin poner el \"modificador\" (en el ejemplo era portrait-uncanny ). La pantalla debe tener alg\u00fan bot\u00f3n o similar para volver a la anterior.","title":"Imagen a tama\u00f1o completo (1 punto)"},{"location":"proyecto/marvel/#vista-acerca-de-025-puntos","text":"Esta es la segunda de las pantallas del tab bar . Simplemente debe consistir en una imagen est\u00e1tica y un text view con informaci\u00f3n sobre la aplicaci\u00f3n.","title":"Vista \"Acerca de\" (0,25 puntos)"},{"location":"proyecto/marvel/#apendice-creacion-de-la-plantilla-de-proyecto-desde-cero","text":"Esta secci\u00f3n est\u00e1 solo para que veas c\u00f3mo se ha creado la plantilla de proyecto, no es necesario que lo hagas si has usado la plantilla que est\u00e1 en moodle. Hasta Xcode 11 no hab\u00eda ning\u00fan sistema de gesti\u00f3n de dependencias de librer\u00edas de terceros para iOS incluido en el IDE. Desde Xcode 11 tenemos el Swift Package Manager , pero durante todo el tiempo que no ha existido una herramienta propia de Apple, la comunidad ha tenido que \"cubrir ese hueco\" desarrollando gestores de paquetes para iOS. Probablemente el m\u00e1s conocido sea CocoaPods que es el que vamos a usar aqu\u00ed. Cocoapods es a la vez un repositorio de librer\u00edas y un gestor de dependencias para instalar autom\u00e1ticamente estas librer\u00edas en nuestros proyectos. Hay muchas librer\u00edas de terceros disponibles con este sistema, puedes buscarlas desde la p\u00e1gina de CocoaPods. Para instalar cocoapods , desde la terminal hacer #Con --pre decimos que queremos instalar la \u00faltima versi\u00f3n, aunque sea RC sudo gem install -n /usr/local/bin cocoapods --pre Esto instala la herramienta desde un repositorio de Internet, as\u00ed que necesitar\u00e1s conectividad...y paciencia, seg\u00fan vaya la red. Si todo va bien se instalar\u00e1 un comando llamado pod . Ejec\u00fatalo desde la terminal para comprobar que existe y no da error. Ahora debes seguir estos pasos: Crear un proyecto Xcode para la aplicaci\u00f3n. Ll\u00e1malo por ejemplo Marvel Con un editor de textos cualquiera, crear un fichero llamado Podfile en el directorio del proyecto (el que contiene el fichero .xcodeproj ). Este archivo debe contener la configuraci\u00f3n y las dependencias (o pods ) del proyecto #SUSTITUYE la versi\u00f3n de ios por la que quieras usar como target de tu app platform :ios , '16.0' use_frameworks! #SUSTITUYE 'Marvel' por el nombre de tu proyecto, si no se llama as\u00ed!!! target 'Marvel' do pod 'MarvelApiWrapper' pod 'SwiftyJSON' , '~> 4.0' end Abre una terminal. Mu\u00e9vete hasta el directorio donde est\u00e1 el Podfile y desde \u00e9l ejecuta el comando pod install . Las dependencias de nuestro proyecto se bajar\u00e1n autom\u00e1ticamente y se crear\u00e1 en el directorio actual un Marvel.xcworkspace A partir de ahora para trabajar en el proyecto siempre abriremos el fichero Marvel.xcworkspace , que es un workspace de Xcode (un conjunto de proyectos), no el proyecto Marvel directamente ( NO ABRAS DIRECTAMENTE el Marvel.xcodeproj ). Veremos que en Xcode se muestra nuestro proyecto y adem\u00e1s un proyecto adicional llamado Pods , que contiene las dependencias. Este \u00faltimo no lo tocaremos, pero es necesario que est\u00e9 ah\u00ed para que funcione el nuestro.","title":"Ap\u00e9ndice: creaci\u00f3n de la plantilla de proyecto desde cero"},{"location":"proyecto/marvel/#uso-de-marvelous","text":"ANTES de empezar a escribir c\u00f3digo aseg\u00farate de hacer en Xcode un Product > Clean Build Folder , y Product > Build para asegurarse de que las dependencias est\u00e1n compiladas y accesibles en nuestro c\u00f3digo. Para poder hacer llamadas al API de Marvel necesitas un par de claves. Las puedes ver, una vez dado de alta y autentificado en Marvel, en https://developer.marvel.com/account El siguiente c\u00f3digo ya est\u00e1 metido en la plantilla, si te la has bajado. Solo es necesario poner en marcha el proyecto para probar si sale en la consola la lista de personajes. Para probar de manera sencilla la librer\u00eda Marvelous puedes poner este import en el ViewController import Marvelous Y ahora copiar la siguiente funci\u00f3n en el view controller , quemuestran en la consola todos los personajes cuyo nombre comienza por una determinada cadena. func mostrarPersonajes ( comienzanPor cadena : String ) { let marvelAPI = RCMarvelAPI () //PUEDES CAMBIAR ESTO PARA PONER TUS CLAVES marvelAPI . publicKey = \"a6927e7e15930110aade56ef90244f6d\" marvelAPI . privateKey = \"487b621fc3c0d6f128b468ba86c99c508f24d357\" let filtro = RCCharacterFilter () filtro . nameStartsWith = cadena marvelAPI . characters ( by : filtro ) { resultados , info , error in if let personajes = resultados as ! [ RCCharacterObject ]? { for personaje in personajes { print ( personaje . name ) } print ( \"Hay \\( personajes . count ) personajes\" ) } } } Puedes llamar a la funci\u00f3n anterior desde el viewDidLoad del view controller override func viewDidLoad () { super . viewDidLoad () // Do any additional setup after loading the view, typically from a nib. mostrarPersonajes ( comienzanPor : \"Spider\" ) }","title":"Uso de Marvelous"}]}