
<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.1, mkdocs-material-8.5.6">
    
    
      
        <title>Tablas - IUDM-iOS-basico</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.20d9efc8.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.cbb835fc.min.css">
        
          
          
          <meta name="theme-color" content="#009485">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="teal" data-md-color-accent="teal">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#tablas" class="md-skip">
          Saltar a contenido
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Cabecera">
    <a href="../.." title="IUDM-iOS-basico" class="md-header__button md-logo" aria-label="IUDM-iOS-basico" data-md-component="logo">
      
  <img src="../../logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            IUDM-iOS-basico
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tablas
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Búsqueda" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Limpiar" aria-label="Limpiar" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navegación" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="IUDM-iOS-basico" class="md-nav__button md-logo" aria-label="IUDM-iOS-basico" data-md-component="logo">
      
  <img src="../../logo.png" alt="logo">

    </a>
    IUDM-iOS-basico
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../2_vistas/apuntes/" class="md-nav__link">
        Vistas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../2_vistas/ejercicios/" class="md-nav__link">
        Ejercicios sobre vistas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../3_autolayout/apuntes/" class="md-nav__link">
        Autolayout
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Tablas
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Tablas
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduccion" class="md-nav__link">
    Introducción
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#creacion-de-vistas-de-tabla" class="md-nav__link">
    Creación de vistas de tabla
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tablas-estaticas" class="md-nav__link">
    Tablas estáticas
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tablas-dinamicas" class="md-nav__link">
    Tablas dinámicas
  </a>
  
    <nav class="md-nav" aria-label="Tablas dinámicas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#el-objeto-tabla" class="md-nav__link">
    El objeto Tabla
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#la-fuente-de-datos-o-datasource" class="md-nav__link">
    La fuente de datos o datasource
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gestion-de-tablas" class="md-nav__link">
    Gestión de tablas
  </a>
  
    <nav class="md-nav" aria-label="Gestión de tablas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#seleccionar-celdas" class="md-nav__link">
    Seleccionar celdas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insertar-y-eliminar-filas" class="md-nav__link">
    Insertar y eliminar filas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diffable-data-sources" class="md-nav__link">
    Diffable Data Sources
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../ejercicios/" class="md-nav__link">
        Ejercicios de tablas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../1_controllers/apuntes/" class="md-nav__link">
        Controladores
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../1_controllers/ejercicios/" class="md-nav__link">
        Ejercicios de controladores
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduccion" class="md-nav__link">
    Introducción
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#creacion-de-vistas-de-tabla" class="md-nav__link">
    Creación de vistas de tabla
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tablas-estaticas" class="md-nav__link">
    Tablas estáticas
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tablas-dinamicas" class="md-nav__link">
    Tablas dinámicas
  </a>
  
    <nav class="md-nav" aria-label="Tablas dinámicas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#el-objeto-tabla" class="md-nav__link">
    El objeto Tabla
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#la-fuente-de-datos-o-datasource" class="md-nav__link">
    La fuente de datos o datasource
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gestion-de-tablas" class="md-nav__link">
    Gestión de tablas
  </a>
  
    <nav class="md-nav" aria-label="Gestión de tablas">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#seleccionar-celdas" class="md-nav__link">
    Seleccionar celdas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insertar-y-eliminar-filas" class="md-nav__link">
    Insertar y eliminar filas
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diffable-data-sources" class="md-nav__link">
    Diffable Data Sources
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="tablas">Tablas<a class="headerlink" href="#tablas" title="Permanent link">&para;</a></h1>
<h2 id="introduccion">Introducción<a class="headerlink" href="#introduccion" title="Permanent link">&para;</a></h2>
<p>Las vistas de tabla (<code>UITableView</code>) se encargan de mostrar, gestionar y hacer <em>scrolling</em> de una tabla de elementos de una sola columna. Cada una de las filas se modela con un <code>UITableViewCell</code>.</p>
<blockquote>
<p>Si necesitamos más de una columna podemos usar <code>UICollectionView</code>, que veréis  en la parte “avanzada” de la asignatura. En las últimas versiones de iOS las funcionalidades de <code>UICollectionView</code> se han ampliado para permitir mostrar solo una columna. </p>
</blockquote>
<p>Descritas así, puede parecer que las tablas deben desempeñar un papel muy limitado en las aplicaciones iOS, pero nada más lejos de la realidad. Son la forma más habitual en aplicaciones móviles de mostrar listas de elementos, no solo en iOS sino en todas las plataformas. Además su aspecto visual es enormemente configurable, con lo que que muchas "pantallas" de <em>apps</em> que a primera vista no lo parecen, en realidad son tablas, por ejemplo en las aplicaciones de Mail, Ajustes, Reloj…</p>
<p><img alt="" src="../images/apps_tablas.png" /></p>
<p>Las tablas pueden ser <em>simples</em> (<code>UITableViewStylePlain</code>)
 o <em>agrupadas</em> (<code>UITableViewStyleGrouped</code>)</p>
<p>Hay varios estilos predefinidos para las filas, que nos permiten mostrar diversos elementos: título, subtítulo, icono a la izquierda, … También podemos crear nuestros propios estilos de celda bien por código o bien gráficamente en el <em>interface builder</em>.</p>
<h2 id="creacion-de-vistas-de-tabla">Creación de vistas de tabla<a class="headerlink" href="#creacion-de-vistas-de-tabla" title="Permanent link">&para;</a></h2>
<p>Una vista de tabla interactúa básicamente con tres objetos. Pueden ser distintos o puede ser el mismo objeto que desempeñe más de un papel:</p>
<ul>
<li>
<p>En primer lugar, el <em>view controller</em>. Ya hemos visto el papel que hace en las aplicaciones.</p>
</li>
<li>
<p>En segundo lugar, el <em>data source</em>: las vistas de tabla solo almacenan directamente los datos de las filas actualmente visibles en pantalla. El resto se los piden a un objeto que debe ser conforme al protocolo <code>UITableViewDataSource</code>. Este es obligatorio, no podemos crear una tabla sin él.</p>
</li>
<li>
<p>Y finalmente el <em>delegate</em>: para gestionar algunos eventos de manipulación de la tabla (como la edición, el borrado, o el mover una fila) y controlar algunos aspectos de la apariencia de las celdas, se usa el <code>UITableViewDelegate</code> </p>
</li>
</ul>
<p>Es muy habitual, al menos en los casos más simples, que el <em>controller</em>, el <em>delegate</em> y el <em>data source</em> sean el mismo objeto.</p>
<p>Si usamos una vista de tabla dibujada en el <em>storyboard</em> podemos conectarla con los dos “colaboradores” gráficamente mediante el “Connections Inspector” del panel “Utilities”. La otra opción es establecer la conexión por código, fijando ciertas propiedades de la tabla, que luego veremos.  </p>
<h2 id="tablas-estaticas">Tablas estáticas<a class="headerlink" href="#tablas-estaticas" title="Permanent link">&para;</a></h2>
<p>En algunos casos conocemos de partida los elementos que queremos dibujar en la tabla. Ejemplo típico de esto es la aplicación de <em>Ajustes</em>, en la que las opciones están colocadas en una tabla simplemente para que estén más organizadas y tengan un formato atractivo. Esto lo podemos conseguir con una <em>tabla estática</em>.</p>
<p>Para crear una pantalla con una tabla estática arrastramos un <code>Table View Controller</code> al <em>storyboard</em>. Es un <em>controller</em> asociado a una vista de tabla que ocupa toda la pantalla del dispositivo. Por defecto usa una tabla dinámica, pero podemos cambiarlo seleccionando la tabla en el <code>Attributes inspector</code> y seleccionando <code>Static Cells</code> en la primera propiedad, <code>Content</code>.</p>
<p>Podemos añadir secciones a la tabla y cambiar el número de celdas en cada sección. Para poder cambiar el número de celdas hay que tener seleccionada la sección deseada, lo que a veces es difícil con el ratón, por lo que podemos usar los nodos del <code>Document outline</code>:</p>
<p><img alt="" src="../images/outline.png" /></p>
<blockquote>
<p>Podemos aumentar el número de celdas de modo que no quepan en la pantalla. Para desplazarnos por la tabla podemos seleccionarla y hacer <em>scroll</em> con la rueda del ratón</p>
</blockquote>
<h2 id="tablas-dinamicas">Tablas dinámicas<a class="headerlink" href="#tablas-dinamicas" title="Permanent link">&para;</a></h2>
<p>En este tipo de tablas los datos son dinámicos: no se conocen por adelantado cuando se está diseñando la aplicación y suelen proceder de alguna fuente externa como una base de datos o un servidor.</p>
<p>Vamos a ver primero cómo crear la tabla en sí y luego el objeto que va a ocuparse de los datos que queremos mostrar en la tabla</p>
<h3 id="el-objeto-tabla">El objeto Tabla<a class="headerlink" href="#el-objeto-tabla" title="Permanent link">&para;</a></h3>
<p>La tabla en sí es una componente más de interfaz de usuario, como un botón, un <em>slider</em>,… Para crear una tabla, arrastramos un <em>table view</em> desde la librería de componentes de la parte inferior derecha de Xcode</p>
<p><img alt="" src="../images/table_view.png" /></p>
<blockquote>
<p>Cuidado: no uséis para este caso un <em>table view controller</em> sino un <em>table view</em>. El primero incluye no solo la tabla en sí sino también un <em>controller</em>, y la tabla ocupa todo el tamaño de la pantalla y no se puede cambiar de tamaño.</p>
</blockquote>
<p>Una vez creada la tabla, nos vamos al <em>attributes inspector</em> (icono <img alt="" src="../images/attr_inspector.png" />, en la parte superior derecha de Xcode) y hacemos que el  <code>Content</code> sea <code>Dynamic prototypes</code> y el número de <code>Prototype cells</code> al menos 1.</p>
<p><img alt="" src="../images/prototypes.png" /></p>
<p>Veremos que en la tabla aparece una “sección” titulada <code>Prototype cells</code>. En esta aparecen los <em>prototypes</em> o plantillas en las que se basarán las celdas de nuestra tabla. En   muchas tablas todas las celdas son iguales y por eso nos basta con un prototipo, pero podemos crear los necesarios.</p>
<p>Para editar gráficamente el prototipo basta con seleccionarlo con el ratón y editarlo cambiando sus atributos con el <em>attributes inspector</em>. El más importante es el <code>Style</code>. Podemos usar uno propio (<code>Custom</code>) o uno de los predefinidos </p>
<p><img alt="" src="../images/style_basic.png" /></p>
<p>Para cada estilo tenemos una serie de elementos con los que podemos “jugar”: un título, una imagen, en algunos casos un texto adicional…. En general, como queremos que el contenido concreto de la celda sea distinto para cada una, lo que haremos será fijarlos por código. Aquí solo elegimos el aspecto general y si ciertos elementos estarán o no presentes. Por ejemplo en el estilo <code>basic</code> la celda solo contiene un texto, mientras que en el <code>detail</code> contiene uno más grande y otro más pequeño.</p>
<blockquote>
<p>Otro atributo importante es el <code>reuse identifier</code>, donde escribiremos un identificador inventado por nosotros para este prototipo. Cuando hablemos del <em>datasource</em> veremos dónde referenciar este identificador en nuestro código.</p>
</blockquote>
<h3 id="la-fuente-de-datos-o-datasource">La fuente de datos o <em>datasource</em><a class="headerlink" href="#la-fuente-de-datos-o-datasource" title="Permanent link">&para;</a></h3>
<p>En iOS se usa el patrón <em>delegación</em> para delegar en otro objeto distinto a la propia tabla la responsabilidad de devolver los datos cuando es necesario pintarlos en pantalla. Este delegado se denomina en iOS <em>datasource</em>. Cuando iOS necesite pintar una celda le pedirá al <em>datasource</em> que se la devuelva rellenada con  sus contenidos.</p>
<p>El <em>datasource</em> puede ser cualquier objeto con tal de que implemente el <em>protocol</em> <code>UITableViewDataSource</code>. En los ejemplos más sencillos habitualmente es el <em>controller</em> de la pantalla en la que está la tabla, aunque este enfoque suele llevar a que acabe habiendo demasiado código en el <em>controller</em>. Por ello nosotros vamos a usar otra clase adicional</p>
<h4 id="implementar-el-datasource">Implementar el <em>datasource</em><a class="headerlink" href="#implementar-el-datasource" title="Permanent link">&para;</a></h4>
<p>Como hemos dicho, nuestro objeto debe implementar el protocolo <code>UITableViewDataSource</code>. Este protocolo tiene dos métodos obligatorios:</p>
<ul>
<li>Un método que dado un número de sección nos devuelva cuántas filas hay en esa sección.</li>
<li>Un método que dado un número de fila nos devuelva una <code>UITableViewCell</code>, que es un objeto de interfaz de usuario que representa una celda. Dicho objeto contiene básicamente el texto a mostrar en la celda, más alguna información adicional.</li>
</ul>
<p>Como vemos, son dos tareas que puede y debe hacer el objeto que controle los datos a mostrar, otro objeto no tendría esta información.</p>
<p>Antes de empezar a implementar los métodos tendremos que indicar que nuestra clase implementa el protocolo <code>UITableViewDataSource</code>. Un requisito adicional, “fruto” de la “era” de Objective-C  es que el <em>datasource</em> debe heredar de la clase Obj-C <code>NSObject</code>, definida en el <em>framework</em> <code>Foundation</code>, así que el esqueleto inicial de nuestra clase sería algo como:</p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">MiDataSource</span> <span class="p">:</span> <span class="bp">NSObject</span><span class="p">,</span> <span class="bp">UITableViewDataSource</span> <span class="p">{</span>
  <span class="c1">//Definición de la clase</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>Si usamos un <em>view controller</em> como <em>datasource</em>, como es habitual en la mayoría de ejemplos que verás en libros y en tutoriales en la web, no será necesario especificar la herencia de <code>NSObject</code> porque los <em>controller</em> ya heredan por defecto de esta clase.</p>
</blockquote>
<p>Vamos a hacer un ejemplo sencillo en el que cada celda simplemente muestra el número de fila en que está, y tenemos 1000 celdas. En un ejemplo algo más realista, los datos estarían almacenados en una BD, o bien en un array en memoria.</p>
<p>El método que devuelve el número de celdas para una sección debe tener la signatura <code>tableView(_:, numberOfRowsInSection:)</code>. Aquí tenemos la implementación para nuestro ejemplo sencillo, que devolverá simplemente 1000. En una BD tendríamos que devolver el número de registros, o en un array su propiedad <code>count</code></p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span>
               <span class="n">numberOfRowsInSection</span> <span class="n">section</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
     <span class="k">return</span> <span class="mi">1000</span>
<span class="p">}</span>
</code></pre></div>
<p>El método que devuelve una celda dada una fila debe tener la signatura <code>tableView(_:, cellForRowAt:)</code>, y es algo más complicado que el anterior. Vamos a ver primero una implementación “ingenua”, que simplemente crea la <code>UITableViewCell</code>, la rellena de contenido y la devuelve. En un momento veremos que <em>este código es muy ineficiente y no deberíamos usarlo tal cual en una aplicación real</em>. Pero por el momento nos sirve para discutir qué significan los parámetros y cómo construir un objeto celda.</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> 
              <span class="n">cellForRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="bp">UITableViewCell</span> <span class="p">{</span>
    <span class="c1">//instanciamos una nueva celda</span>
    <span class="kd">let</span> <span class="nv">celda</span> <span class="p">=</span> <span class="bp">UITableViewCell</span><span class="p">(</span><span class="n">style</span><span class="p">:</span> <span class="p">.</span><span class="k">default</span><span class="p">,</span> <span class="n">reuseIdentifier</span><span class="p">:</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
    <span class="c1">//la rellenamos de contenido</span>
    <span class="n">celda</span><span class="p">.</span><span class="n">textLabel</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Celda número </span><span class="si">\(</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="si">)</span><span class="s">&quot;</span>
    <span class="k">return</span> <span class="n">celda</span>
<span class="p">}</span>
</code></pre></div>
<p>Algunas consideraciones sobre el código anterior:
- Un <code>IndexPath</code> es un <em>struct</em> que almacena información sobre la posición de una celda. Contiene básicamente el número de fila (propiedad <code>row</code>) y el número de sección (propiedad <code>section</code>. Ignoramos este último ya que nuestro ejemplo tiene una única sección.
- Al inicializador de <code>UITableViewCell</code> le pasamos el estilo de la celda (en principio de entre los predefinidos) y luego el <code>reuseIdentifier</code>, que luego veremos qué es. De momento pasamos la cadena vacía.</p>
<p>Lo que acabamos de hacer, crear un nuevo <code>UITableViewCell</code>  por cada fila es muy ineficiente dado que una tabla puede tener cientos o miles de ellas. Por eso se suele usar un truco ingenioso: se crea un pequeño número de celdas (las que se ven simultáneamente en pantalla) y luego se reutilizan conforme se va haciendo <em>scroll</em> por la tabla, rellenándolas con los nuevos datos. iOS ofrece soporte para esta reutilización manteniendo un <em>pool</em> de celdas que podemos reutilizar para rellenar con nuevos datos.</p>
<p>Podemos sacar una celda del <em>pool</em> con el método de la vista de tabla <code>dequeueReusableCell(withIdentifier:)</code>. El identificador sirve para etiquetar el “tipo” de celda. En casos más complicados podríamos tener varios <em>pool</em> con distintos tipos de celda para reutilizar. En el ejemplo usaremos un único identificador (es arbitrario y lo elige el desarrollador).</p>
<blockquote>
<p>MUY IMPORTANTE: el identificador del <code>reuseIdentifier</code> <strong>debe ser el mismo que elegimos gráficamente</strong> al editar el prototipo de la celda. Si no fallará nuestro código</p>
</blockquote>
<p><img alt="" src="../images/reuse_identifier.png" /></p>
<p>La nueva versión del código queda así:</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> 
               <span class="n">cellForRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="bp">UITableViewCell</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">nuevaCelda</span> <span class="p">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&quot;unaCelda&quot;</span><span class="p">,</span> 
                          <span class="k">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>
    <span class="n">nuevaCelda</span><span class="p">.</span><span class="n">textLabel</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="n">datos</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nuevaCelda</span>
 <span class="p">}</span>
</code></pre></div>
<blockquote>
<p>Un detalle más: Xcode te avisará de que la propiedad <code>textLabel</code> está <em>deprecated</em> y que se dejará de usar en futuras versiones de iOS. Aunque no está claro a partir de qué versión de iOS dejará de ser compatible, debido al amplio uso de esta forma de trabajar con celdas de tabla, en la actualidad ésta no es la forma "sancionada" por Apple, que en su lugar promueve el uso de <em>Content Configurations</em>. La idea es, en lugar de modificar directamente las propiedades de la celda, crear y modificar una configuración que pudiéramos aplicar a muchas celdas, algo como lo que sigue (aunque en nuestro caso al ser un ejemplo modificamos la configuración para cada celda, deberíamos guardarla aparte).</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">content</span> <span class="p">=</span> <span class="n">cell</span><span class="p">.</span><span class="n">defaultContentConfiguration</span><span class="p">()</span>
<span class="n">content</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="n">datos</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
<span class="n">content</span><span class="p">?.</span><span class="n">textProperties</span><span class="p">.</span><span class="n">color</span> <span class="p">=</span> <span class="p">.</span><span class="n">blue</span>
<span class="n">celda</span><span class="p">.</span><span class="n">contentConfiguration</span> <span class="p">=</span> <span class="n">content</span>
</code></pre></div>
<h4 id="conectar-la-tabla-y-el-datasource">Conectar la tabla y el <em>datasource</em><a class="headerlink" href="#conectar-la-tabla-y-el-datasource" title="Permanent link">&para;</a></h4>
<p>Podemos hacer la conexión usando dos métodos alternativos: gráficamente o por código. Cuando el <em>datasource</em> es una clase adicional es algo más sencillo por código. Cuando es el <em>controller</em> la forma más directa es la gráfica.</p>
<p>Como en el ejemplo de la sección anterior hemos hecho que el <em>datasource</em> sea una clase adicional, vamos a ver en primer lugar cómo se haría la <strong>conexión por código</strong>. Basta con asignar la propiedad <code>dataSource</code> del objeto tabla a una instancia de nuestro objeto <em>datasource</em>. Por ejemplo podríamos hacer la asignación en el <code>viewDidLoad()</code> del <em>controller</em> de la pantalla donde está la tabla:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//Este outlet lo habríamos creado gráficamente con Xcode</span>
<span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">miTabla</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">!</span>
<span class="c1">//guardamos el datasource como una propiedad del controller</span>
<span class="kd">var</span> <span class="nv">miDS</span><span class="p">:</span> <span class="n">MiDataSource</span><span class="p">!</span>
<span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">miDS</span> <span class="p">=</span> <span class="n">MiDataSource</span><span class="p">()</span>
    <span class="c1">//asignamos el datasource como el delegado de la tabla</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">miTabla</span><span class="p">.</span><span class="n">dataSource</span> <span class="p">=</span> <span class="n">miDS</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>En el código anterior puede parecer que podríamos ahorrarnos la variable <code>miDS</code> y asignar directamente el dataSource a una nueva instancia, es decir <code>self.miTabla.dataSource = MiDataSource()</code>. Pero esto no funcionará y la tabla aparecerá vacía. Si consultamos la documentación del API de iOS veremos que la propiedad <code>dataSource</code> es <em>weak</em>, lo que significa que si el objeto referenciado por ella no está referenciado por ninguna variable más, iOS considerará que puede liberar la memoria ocupada por él. En consecuencia el <code>dataSource</code> se quedaría vacío y no aparecerían los datos.</p>
<p>En el código anterior accedemos al objeto tabla con un <em>outlet</em> creado previamente en Xcode de modo gráfico, pero esto no parece tener mucho sentido si hemos dicho que íbamos a establecer la conexión por código. Si no estamos usando el <em>outlet</em> para alguna tarea adicional, una alternativa sería asignar un <em>tag</em> fijo a la tabla (por ejemplo 100) y acceder a ella con <code>self.view.viewWithTag(tag:100)</code></p>
</blockquote>
<p>Otra alternativa a lo anterior es hacer la conexión con Xcode. Para <strong>conectar gráficamente la tabla con el <em>datasource</em></strong> primero necesitamos tener una “representación gráfica” en pantalla del objeto <code>MiDataSource</code> con el que queremos conectar. Podemos arrastrar a la pantalla un <code>Object</code> de la librería de objetos de la parte inferior derecha de Xcode. Este es como si fuera un componente más de la interfaz gráfica pero no tiene representación en pantalla. En lugar de arrastrarlo a la pantalla en sí como ocurre con los componentes gráficos convencionales, debemos arrastrarlo al árbol de componentes que aparece a su izquierda</p>
<p><img alt="" src="../images/object.png" /></p>
<p>Una vez colocado aquí, vamos a indicar que este objeto es de la clase <code>MiDataSource</code>. Para ello usamos el <code>Identity inspector</code>, y en la propiedad <code>Custom class</code> escribimos el nombre de la clase</p>
<p><img alt="" src="../images/class_name.png" /></p>
<p>Ya podemos conectar la propiedad <code>dataSource</code> de la tabla con este objeto. La propiedad la podemos ver si seleccionamos la tabla con el ratón y vamos al <code>Connections inspector</code> (el icono <img alt="" src="../images/conn_inspector.png" /> del área de <code>Utilities</code>). Arrastramos con el ratón (no hace falta <code>Ctrl</code>) desde el círculo que representa al <code>datasource</code> hasta el icono del objeto que representa a la clase <code>MiDataSource</code>  </p>
<p><img alt="" src="../images/connect.png" /></p>
<h2 id="gestion-de-tablas">Gestión de tablas<a class="headerlink" href="#gestion-de-tablas" title="Permanent link">&para;</a></h2>
<p>En las tablas dinámicas podemos por supuesto insertar y eliminar celdas. También podemos seleccionarlas haciendo <em>tap</em> sobre ellas. </p>
<p>Para evitar que la propia tabla se tenga que hacer cargo de estas tareas se usa de nuevo el patrón <em>delegación</em>: designamos una instancia de una clase determinada que se encargará de procesar la inserción y el borrado. Esta instancia se le debe asignar a la propiedad <code>delegate</code> de la tabla, bien por código o bien gráficamente, como hacíamos en el caso del <code>dataSource</code>.</p>
<blockquote>
<p>Aunque la tarea primaria es cosa del <em>delegate</em>, el <em>dataSource</em> será avisado si se va a insertar o eliminar alguna celda, para que procese los datos</p>
</blockquote>
<p>El <code>delegate</code> tendrá que ser de una clase que implemente el protocolo <code>UITableViewDelegate</code>. Este protocolo proporciona métodos para manejar secciones de la tabla, configurar las cabeceras y pies de cada sección, gestionar qué hacer cuando se selecciona una celda, insertar, eliminar y reordenar celdas, y algunas otras tareas.</p>
<blockquote>
<p>En casi todos los ejemplos que veréis en libros y en la web se suele hacer que el <em>controller</em> actúe de <em>delegate</em> para simplificar el código y reducir el número de clases del ejemplo, pero a cambio complicamos el código del <em>controller</em>.</p>
</blockquote>
<p>El código de una clase que actúe de <code>delegate</code> de tabla debe tener el siguiente esqueleto básico. Al igual que en el caso del <code>dataSource</code>, la herencia de <code>NSObject</code> es a su vez “herencia” de la época de Objective-C</p>
<div class="highlight"><pre><span></span><code><span class="kd">import</span> <span class="nc">Foundation</span>
<span class="kd">import</span> <span class="nc">UIKit</span>

<span class="kd">class</span> <span class="nc">MiDelegate</span><span class="p">:</span> <span class="bp">NSObject</span><span class="p">,</span> <span class="bp">UITableViewDelegate</span> <span class="p">{</span>
    <span class="c1">//definición de la clase</span>
<span class="p">}</span>
</code></pre></div>
<p>En los siguientes apartados solo vamos a discutir cómo implementar los métodos del protocolo <code>UITableViewDelegate</code>, no cómo hacer la conexión entre la tabla y el <code>delegate</code>, ya que la conexión se hace prácticamente igual que cuando hablábamos del <em>datasource</em>, sea por código o gráficamente.</p>
<h3 id="seleccionar-celdas">Seleccionar celdas<a class="headerlink" href="#seleccionar-celdas" title="Permanent link">&para;</a></h3>
<p>Cuando el usuario selecciona una celda haciendo <em>tap</em> sobre ella se llama al método <code>tableView(_: didSelectRowAt:) del</code> <em>delegate</em>. Como ejemplo vamos a ver cómo implementaríamos este método de forma que cuando se seleccione una celda se ponga en ella una marca de verificación, y que si ya está se quite. En las celdas predefinidas, esta marca (y otras similares) se controla con la propiedad <code>accessoryType</code> de la celda.</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">didSelectRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="kd">let</span> <span class="nv">celda</span> <span class="p">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">cellForRow</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//Si no hay marca de verificación la ponemos. Si la hay la quitamos      </span>
    <span class="k">if</span> <span class="n">celda</span><span class="p">.</span><span class="n">accessoryType</span><span class="p">==</span><span class="bp">UITableViewCell</span><span class="p">.</span><span class="n">AccessoryType</span><span class="p">.</span><span class="kr">none</span> <span class="p">{</span>
       <span class="n">celda</span><span class="p">.</span><span class="n">accessoryType</span> <span class="p">=</span> <span class="p">.</span><span class="n">checkmark</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
       <span class="n">celda</span><span class="p">.</span><span class="n">accessoryType</span> <span class="p">=</span> <span class="p">.</span><span class="kr">none</span>
    <span class="p">}</span>
    <span class="c1">//deseleccionamos la celda, si no se quedará con el fondo gris</span>
    <span class="n">tableView</span><span class="p">.</span><span class="n">deselectRow</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="insertar-y-eliminar-filas">Insertar y eliminar filas<a class="headerlink" href="#insertar-y-eliminar-filas" title="Permanent link">&para;</a></h3>
<p>iOS nos ofrece de forma automática el “modo edición”, en el que en la parte izquierda de cada celda aparece un icono indicador de las operaciones que se pueden hacer con ella. Hay dos indicadores: </p>
<ul>
<li><img alt="" src="../images/prohibido.png" /> Una señal de "prohibido" para poder borrar la celda (pulsando sobre la señal y luego sobre el botón “Borrar” que aparece).</li>
<li><img alt="" src="../images/mas.png" /> Un símbolo de ‘+’ que sirve para insertar una nueva celda</li>
</ul>
<p>Podemos activar el modo edición con el método <code>setEditing</code> del objeto tabla:</p>
<div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="o">//</span><span class="nt">suponemos</span><span class="w"> </span><span class="nt">que</span><span class="w"> </span><span class="s2">&quot;miTabla&quot;</span><span class="w"> </span><span class="nt">es</span><span class="w"> </span><span class="nt">un</span><span class="w"> </span><span class="nt">outlet</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">la</span><span class="w"> </span><span class="nt">tabla</span><span class="w"></span>
<span class="nt">self</span><span class="p">.</span><span class="nc">miTabla</span><span class="p">.</span><span class="nc">setEditing</span><span class="o">(</span><span class="nt">true</span><span class="o">,</span><span class="w"> </span><span class="nt">animated</span><span class="p">:</span><span class="nd">true</span><span class="o">);</span><span class="w"></span>
</code></pre></div></td></tr></table></div>

<p>Por defecto al activar el modo edición en todas las celdas aparecerá la señal de “prohibido”. Implementando en el <em>delegate</em> el método <code>tableView(_:,editingStyleForRowAt:)</code> podemos especificar qué tipo de estilo de edición queremos para una celda determinada. El sistema nos “preguntará” el estilo de edición para un número de celda y debemos devolver <code>UITableViewCellEditingStyle.delete</code>o bien <code>UITableViewCellEditingStyle.insert</code>.</p>
<p>Aunque el modo edición es automático, los iconos de "prohibido" o "más" no harán nada por sí solos. El borrado efectivo de las celdas y de su contenido lo tenemos que hacer nosotros, al igual que la inserción. iOS <strong>avisará al <em>datasource</em> de que se está intentando insertar o eliminar una celda, NO al <em>delegate</em> </strong>. Esto es lógico ya que los datos los gestiona el <em>datasource</em>.</p>
<p>Así, cuando se pulse sobre el <img alt="" src="../images/prohibido.png" /> y luego sobre “delete” o sobre el <img alt="" src="../images/mas.png" />, se llamará al método del <em>datasource</em> llamado <code>tableView(_:, commit:, forRowAt:)</code>. En este método tenemos que hacer dos cosas:</p>
<ul>
<li>Actualizar los datos (borrar el dato o insertar uno nuevo)</li>
<li>Llamar a un método del API de la tabla para que esta inserción o borrado se represente de manera visual (que gráficamente aparezca o desaparezca la celda)</li>
</ul>
<p>Es muy importante destacar que <strong>primero hay que actualizar los datos</strong> y luego ocuparse de la parte gráfica. Si lo hacemos al revés no funcionará bien, ya que iOS intentará redibujar la tabla usando los datos “antiguos”.</p>
<p>Simplemente implementando el siguiente método (aunque estuviera vacío) activaremos el <em>swipe to delete</em>, lo que quiere decir que por ejemplo al pulsar sobre el "prohibido" aparecerá deslizándose desde la derecha de la celda un bótón "delete". No obstante este botón no va a hacer nada salvo que implementemos el borrado como aquí se muestra:</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">commit</span> <span class="n">editingStyle</span><span class="p">:</span> <span class="bp">UITableViewCell</span><span class="p">.</span><span class="n">EditingStyle</span><span class="p">,</span> <span class="n">forRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">editingStyle</span><span class="p">==</span><span class="bp">UITableViewCell</span><span class="p">.</span><span class="n">EditingStyle</span><span class="p">.</span><span class="n">delete</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">datos</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">)</span>
            <span class="n">tableView</span><span class="p">.</span><span class="n">deleteRows</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="p">[</span><span class="n">indexPath</span><span class="p">],</span> <span class="n">with</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">.</span><span class="n">RowAnimation</span><span class="p">.</span><span class="n">fade</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="n">editingStyle</span><span class="p">==</span><span class="bp">UITableViewCell</span><span class="p">.</span><span class="n">EditingStyle</span><span class="p">.</span><span class="bp">insert</span> <span class="p">{</span>
            <span class="kc">self</span><span class="p">.</span><span class="n">datos</span><span class="p">.</span><span class="bp">insert</span><span class="p">(</span><span class="s">&quot;Nueva celda&quot;</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">)</span>
            <span class="n">tableView</span><span class="p">.</span><span class="n">insertRows</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="p">[</span><span class="n">indexPath</span><span class="p">],</span> <span class="n">with</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">.</span><span class="n">RowAnimation</span><span class="p">.</span><span class="n">bottom</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>Nótese que los métodos <code>insertRows</code> y <code>deleteRows</code> permiten insertar o borrar varias celdas a la vez y por ello como primer parámetro requieren un array de <code>indexPath</code>, y no un <code>indexPath</code> directamente. Si insertamos/borramos una única celda será un array de un único componente.</p>
<p>Esto que hemos visto se aplica a cuando la inserción o eliminación las dispara el propio iOS pulsando en los botones del sistema. Pero también podemos disparar nosotros manualmente la inserción o eliminación. Por ejemplo veamos cómo se insertaría una nueva celda “manualmente” al principio de la tabla. </p>
<div class="highlight"><pre><span></span><code><span class="c1">//primero hay que actualizar los datos</span>
<span class="kc">self</span><span class="p">.</span><span class="n">datos</span><span class="p">.</span><span class="bp">insert</span><span class="p">(</span><span class="s">&quot;Nueva celda&quot;</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">//y ahora visualmente insertar la celda</span>
<span class="kd">let</span> <span class="nv">indexPath</span> <span class="p">=</span> <span class="n">IndexPath</span><span class="p">(</span><span class="n">row</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="n">section</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">//suponemos que tenemos accesible la tabla, la necesitamos</span>
<span class="n">tabla</span><span class="p">.</span><span class="n">insertRows</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="p">[</span><span class="n">indexPath</span><span class="p">],</span> 
                     <span class="n">with</span><span class="p">:</span> <span class="n">UITableViewRowAnimation</span><span class="p">.</span><span class="n">fade</span><span class="p">)</span>
</code></pre></div>
<h2 id="diffable-data-sources">Diffable Data Sources<a class="headerlink" href="#diffable-data-sources" title="Permanent link">&para;</a></h2>
<p>Como hemos visto, el encargado de gestionar los datos mostrados en la tabla y sincronizar el estado de la propia interfaz es el propio programador. Pero esto da lugar a código tedioso y propenso a errores. Sería mucho mejor que iOS se encargara de seguir automáticamente la pista de los datos si estos cambian y actualizara visualmente la tabla de manera automática. Esto lo podemos conseguir con los <em>Diffable Data Sources</em>, que se introdujeron en iOS13.</p>
<p>Para crear un <em>Diffable Data Source</em> necesitamos especificar:</p>
<ul>
<li>El tipo de los <em>items</em> de la tabla. Además este debe ser conforme al protocolo <em>hashable</em> (lo son automáticamente tipos básicos como String o Int, luego veremos qué implicaciones tiene esto)</li>
<li>El tipo de las secciones de la tabla. En iOS por defecto son simplemente enteros, pero aquí podemos especificar el tipo que queramos (siempre que como antes, sea <em>hashable</em>)</li>
<li>La <code>UITableView</code> asociada al <em>data source</em></li>
<li>El código que crea cada celda (lo que hacíamos en el método <code>tableView(_:, cellForRowAt:)</code>)</li>
</ul>
<p>Por ejemplo, supongamos para simplificar que los identificadores de sección van a ser enteros y los datos de la tabla <code>String</code>s. Podríamos crear nuestro <em>diffable data source</em> como sigue:</p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">MiDiffableDS</span> <span class="p">:</span> <span class="bp">UITableViewDiffableDataSource</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">tabla</span> <span class="p">:</span> <span class="bp">UITableView</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span>
            <span class="n">tableView</span><span class="p">:</span> <span class="n">tabla</span><span class="p">,</span>
            <span class="n">cellProvider</span><span class="p">:</span> <span class="p">{</span>  <span class="n">tableView</span><span class="p">,</span> <span class="n">indexPath</span><span class="p">,</span> <span class="n">item</span> <span class="k">in</span>
                <span class="kd">let</span> <span class="nv">cell</span> <span class="p">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span>
                    <span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&quot;miCelda&quot;</span><span class="p">,</span>
                    <span class="k">for</span><span class="p">:</span> <span class="n">indexPath</span>
                <span class="p">)</span>

                <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="n">item</span>
                <span class="k">return</span> <span class="n">cell</span>
            <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>cosas interesantes:</p>
<ul>
<li>Nuestra clase hereda de  <code>UITableViewDiffableDataSource</code>, que es la clase base de los <em>diffable data sources</em> en iOS. </li>
<li>Esta clase es genérica y está parametrizada por <code>&lt;TipoDeSeccion, TipoDeItem&gt;</code>, en nuestro caso <code>Int</code> y <code>String</code> como ya hemos dicho</li>
<li>En el constructor de la clase base hay que pasar como parámetros:<ul>
<li>La <code>UITableView</code> asociada. Aquí es donde se hace la conexión entre <em>datasource</em> y tabla. En nuestro ejemplo este parámetro se lo pasamos al inicializador de la clase derivada, así se lo podemos pasar desde el <em>controller</em> que es el "dueño" de la tabla.</li>
<li>en <code>cellProvider</code> pasamos una clausura que básicamente es la implementación que hacíamos antes del <code>tableView(_:, cellForRowAt:)</code> (obtener la celda reutilizada, rellenarla de datos y devolverla)</li>
</ul>
</li>
</ul>
<p>Si no queremos "molestarnos" en definir una clase propia también podemos crear directamente una instancia de la clase base y luego asignársela a la tabla como su datasouce:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//suponiendo que el UITableView se llame &quot;tabla&quot;</span>
<span class="c1">//Este código podría estar en el viewDidLoad del controller</span>
<span class="kd">let</span> <span class="nv">miDataSource</span> <span class="p">=</span> <span class="bp">UITableViewDiffableDataSource</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">&gt;(</span>
  <span class="n">tableview</span><span class="p">:</span> <span class="n">miTabla</span><span class="p">,</span>
  <span class="c1">//cellProvider igual que antes</span>
  <span class="p">...</span>
<span class="p">)</span>
<span class="n">miTabla</span><span class="p">.</span><span class="n">dataSource</span> <span class="p">=</span> <span class="n">miDataSource</span>
</code></pre></div>
<p>De momento no hemos sacado ningún beneficio apreciable de usar un <em>diffable data source</em>. Los beneficios empiezan cuando queremos modificar los datos asociados a la tabla. La idea es que el conjunto de datos se representa con lo que se llama un <em>snapshot</em>, que podemos modificar (crear de nuevo, añadir datos, borrar datos,...). Una vez modificado el <em>snapshot</em> llamamos al método <code>apply</code> sobre el <em>datasource</em> para que visualmente se apliquen los cambios correspondientes.</p>
<p>Por ejemplo podríamos inicializar los datos como sigue:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="bp">NSDiffableDataSourceSnapshot</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">&gt;()</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">appendSections</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">appendItems</span><span class="p">([</span><span class="s">&quot;uno&quot;</span><span class="p">,</span> <span class="s">&quot;dos&quot;</span><span class="p">,</span> <span class="s">&quot;tres&quot;</span><span class="p">],</span> <span class="n">toSection</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ds</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">animatingDifferences</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span>
</code></pre></div>
<p>Como vemos en este ejemplo, podemos añadir secciones a la tabla e items dentro de cada sección. Al llamar a <code>apply</code> se actualizará la tabla, con una animación si el parámetro <code>animatingDifferences</code> es <code>true</code>.</p>
<p>En el <em>snapshot</em> tenemos métodos para insertar, modificar o eliminar items, por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//aquí ds sería el diffable data source que hemos creado</span>
<span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="n">ds</span><span class="p">.</span><span class="n">snapshot</span><span class="p">()</span>
<span class="n">snapshot</span><span class="p">.</span><span class="n">deleteItems</span><span class="p">([</span><span class="s">&quot;uno&quot;</span><span class="p">])</span>
<span class="n">ds</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">)</span>
</code></pre></div>
<p>Los items se borran especificando un <code>id</code>, que en el caso de un tipo simple como <code>String</code> se corresponde con el propio contenido. La tabla se actualizará automáticamente tras el <code>apply</code>.</p>
<p>Para implementar el borrado de celdas haciendo <em>tap</em> sobre ellas en el modo edición tendremos que sobreescribir el método <code>tableView(_,commit:,atIndexPath:)</code> en nuestro <em>diffable data source</em>:</p>
<div class="highlight"><pre><span></span><code><span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">commit</span> <span class="n">editingStyle</span><span class="p">:</span> <span class="bp">UITableViewCell</span><span class="p">.</span><span class="n">EditingStyle</span><span class="p">,</span> <span class="n">forRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">snapshot</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">snapshot</span><span class="p">()</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">item</span> <span class="p">=</span> <span class="n">itemIdentifier</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">snapshot</span><span class="p">.</span><span class="n">deleteItems</span><span class="p">([</span><span class="n">item</span><span class="p">])</span>
            <span class="n">apply</span><span class="p">(</span><span class="n">snapshot</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>La diferencia es que ahora no tenemos que actualizar visualmente la tabla, solo modificar el snapshot y aplicarlo al <em>datasource</em>. Para saber qué item está en la posición <code>indexPath</code> usamos el método <code>itemIdentifier</code>.</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Pie" >
      
        
        <a href="../../3_autolayout/apuntes/" class="md-footer__link md-footer__link--prev" aria-label="Anterior: Autolayout" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Anterior
              </span>
              Autolayout
            </div>
          </div>
        </a>
      
      
        
        <a href="../ejercicios/" class="md-footer__link md-footer__link--next" aria-label="Siguiente: Ejercicios de tablas" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Siguiente
              </span>
              Ejercicios de tablas
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.5bf1dace.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.config.lang": "es", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "B\u00fasqueda", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version.title": "Seleccionar versi\u00f3n"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.078830c0.min.js"></script>
      
    
  </body>
</html>